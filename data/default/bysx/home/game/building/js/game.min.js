!function(){
var cc = cc || {};
cc._tmp = cc._tmp || {}, cc._LogInfos = {}, window._p, _p = window, _p.gl, _p.WebGLRenderingContext, _p.DeviceOrientationEvent, _p.DeviceMotionEvent, _p.AudioContext, _p.webkitAudioContext, _p.mozAudioContext, _p = Object.prototype, _p._super, _p.ctor, delete window._p, cc.newElement = function(e) {
    return document.createElement(e)
}, cc._addEventListener = function(e, t, n, r) {
    e.addEventListener(t, n, r)
}, cc._isNodeJs = typeof require != "undefined" && require("fs"), cc.each = function(e, t, n) {
    if (!e)
        return;
    if (e instanceof Array) {
        for (var r = 0, i = e.length; r < i; r++)
            if (t.call(n, e[r], r) === !1)
                return
    } else
        for (var s in e)
            if (t.call(n, e[s], s) === !1)
                return
}, cc.extend = function(e) {
    var t = arguments.length >= 2 ? Array.prototype.slice.call(arguments, 1) : [];
    return cc.each(t, function(t) {
        for (var n in t)
            t.hasOwnProperty(n) && (e[n] = t[n])
    }), e
}, cc.isFunction = function(e) {
    return typeof e == "function"
}, cc.isNumber = function(e) {
    return typeof e == "number" || Object.prototype.toString.call(e) == "[object Number]"
}, cc.isString = function(e) {
    return typeof e == "string" || Object.prototype.toString.call(e) == "[object String]"
}, cc.isArray = function(e) {
    return Object.prototype.toString.call(e) == "[object Array]"
}, cc.isUndefined = function(e) {
    return typeof e == "undefined"
}, cc.isObject = function(e) {
    var t = typeof e;
    return t == "function" || e && t == "object"
}, cc.isCrossOrigin = function(e) {
    if (!e)
        return cc.log("invalid URL"), !1;
    var t = e.indexOf("://");
    if (t == -1)
        return !1;
    var n = e.indexOf("/", t + 3),
        r = n == -1 ? e : e.substring(0, n);
    return r != location.origin
}, cc.AsyncPool = function(e, t, n, r, i) {
    var s = this;
    s._srcObj = e, s._limit = t, s._pool = [], s._iterator = n, s._iteratorTarget = i, s._onEnd = r, s._onEndTarget = i, s._results = e instanceof Array ? [] : {}, s._isErr = !1, cc.each(e, function(e, t) {
        s._pool.push({
            index: t,
            value: e
        })
    }), s.size = s._pool.length, s.finishedSize = 0, s._workingSize = 0, s._limit = s._limit || s.size, s.onIterator = function(e, t) {
        s._iterator = e, s._iteratorTarget = t
    }, s.onEnd = function(e, t) {
        s._onEnd = e, s._onEndTarget = t
    }, s._handleItem = function() {
        var e = this;
        if (e._pool.length == 0)
            return;
        if (e._workingSize >= e._limit)
            return;
        var t = e._pool.shift(),
            n = t.value,
            r = t.index;
        e._workingSize++, e._iterator.call(e._iteratorTarget, n, r, function(t) {
            if (e._isErr)
                return;
            e.finishedSize++, e._workingSize--;
            if (t) {
                e._isErr = !0, e._onEnd && e._onEnd.call(e._onEndTarget, t);
                return
            }
            var n = Array.prototype.slice.call(arguments, 1);
            e._results[this.index] = n[0];
            if (e.finishedSize == e.size) {
                e._onEnd && e._onEnd.call(e._onEndTarget, null, e._results);
                return
            }
            e._handleItem()
        }.bind(t), e)
    }, s.flow = function() {
        var e = this;
        if (e._pool.length == 0) {
            e._onEnd && e._onEnd.call(e._onEndTarget, null, []);
            return
        }
        for (var t = 0; t < e._limit; t++)
            e._handleItem()
    }
}, cc.async = {
    series: function(e, t, n) {
        var r = new cc.AsyncPool(e, 1, function(e, t, r) {
            e.call(n, r)
        }, t, n);
        return r.flow(), r
    },
    parallel: function(e, t, n) {
        var r = new cc.AsyncPool(e, 0, function(e, t, r) {
            e.call(n, r)
        }, t, n);
        return r.flow(), r
    },
    waterfall: function(e, t, n) {
        var r = [],
            i = new cc.AsyncPool(e, 1, function(e, t, i) {
                r.push(function(e) {
                    r = Array.prototype.slice.call(arguments, 1), i.apply(null, arguments)
                }), e.apply(n, r)
            }, function(e, r) {
                if (!t)
                    return;
                if (e)
                    return t.call(n, e);
                t.call(n, null, r[r.length - 1])
            });
        return i.flow(), i
    },
    map: function(e, t, n, r) {
        var i = t;
        typeof t == "object" && (n = t.cb, r = t.iteratorTarget, i = t.iterator);
        var s = new cc.AsyncPool(e, 0, i, n, r);
        return s.flow(), s
    },
    mapLimit: function(e, t, n, r, i) {
        var s = new cc.AsyncPool(e, t, n, r, i);
        return s.flow(), s
    }
}, cc.path = {
    join: function() {
        var e = arguments.length,
            t = "";
        for (var n = 0; n < e; n++)
            t = (t + (t == "" ? "" : "/") + arguments[n]).replace(/(\/|\\\\)$/, "");
        return t
    },
    extname: function(e) {
        var t = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(e);
        return t ? t[1] : null
    },
    mainFileName: function(e) {
        if (e) {
            var t = e.lastIndexOf(".");
            if (t !== -1)
                return e.substring(0, t)
        }
        return e
    },
    basename: function(e, t) {
        var n = e.indexOf("?");
        n > 0 && (e = e.substring(0, n));
        var r = /(\/|\\\\)([^(\/|\\\\)]+)$/g,
            i = r.exec(e.replace(/(\/|\\\\)$/, ""));
        if (!i)
            return null;
        var s = i[2];
        return t && e.substring(e.length - t.length).toLowerCase() == t.toLowerCase() ? s.substring(0, s.length - t.length) : s
    },
    dirname: function(e) {
        return e.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
    },
    changeExtname: function(e, t) {
        t = t || "";
        var n = e.indexOf("?"),
            r = "";
        return n > 0 && (r = e.substring(n), e = e.substring(0, n)), n = e.lastIndexOf("."), n < 0 ? e + t + r : e.substring(0, n) + t + r
    },
    changeBasename: function(e, t, n) {
        if (t.indexOf(".") == 0)
            return this.changeExtname(e, t);
        var r = e.indexOf("?"),
            i = "",
            s = n ? this.extname(e) : "";
        return r > 0 && (i = e.substring(r), e = e.substring(0, r)), r = e.lastIndexOf("/"), r = r <= 0 ? 0 : r + 1, e.substring(0, r) + t + s + i
    }
}, cc.loader = {
    _jsCache: {},
    _register: {},
    _langPathCache: {},
    _aliases: {},
    resPath: "",
    audioPath: "",
    cache: {},
    getXMLHttpRequest: function() {
        return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
    },
    _getArgs4Js: function(e) {
        var t = e[0],
            n = e[1],
            r = e[2],
            i = ["", null, null];
        if (e.length === 1)
            i[1] = t instanceof Array ? t : [t];
        else if (e.length === 2)
            typeof n == "function" ? (i[1] = t instanceof Array ? t : [t], i[2] = n) : (i[0] = t || "", i[1] = n instanceof Array ? n : [n]);
        else {
            if (e.length !== 3)
                throw "arguments error to load js!";
            i[0] = t || "", i[1] = n instanceof Array ? n : [n], i[2] = r
        }
        return i
    },
    loadJs: function(e, t, n) {
        var r = this,
            i = r._jsCache,
            s = r._getArgs4Js(arguments),
            o = s[0],
            u = s[1],
            a = s[2];
        navigator.userAgent.indexOf("Trident/5") > -1 ? r._loadJs4Dependency(o, u, 0, a) : cc.async.map(u, function(e, t, n) {
            var s = cc.path.join(o, e);
            if (i[s])
                return n(null);
            r._createScript(s, !1, n)
        }, a)
    },
    loadJsWithImg: function(e, t, n) {
        var r = this,
            i = r._loadJsImg(),
            s = r._getArgs4Js(arguments);
        this.loadJs(s[0], s[1], function(e) {
            if (e)
                throw e;
            i.parentNode.removeChild(i), s[2] && s[2]()
        })
    },
    _createScript: function(e, t, n) {
        var r = document,
            i = this,
            s = cc.newElement("script");
        s.async = t, s.src = e, i._jsCache[e] = !0, cc._addEventListener(s, "load", function() {
            s.parentNode.removeChild(s), this.removeEventListener("load", arguments.callee, !1), n()
        }, !1), cc._addEventListener(s, "error", function() {
            s.parentNode.removeChild(s), n("Load " + e + " failed!")
        }, !1), r.body.appendChild(s)
    },
    _loadJs4Dependency: function(e, t, n, r) {
        if (n >= t.length) {
            r && r();
            return
        }
        var i = this;
        i._createScript(cc.path.join(e, t[n]), !1, function(s) {
            if (s)
                return r(s);
            i._loadJs4Dependency(e, t, n + 1, r)
        })
    },
    _loadJsImg: function() {
        var e = document,
            t = e.getElementById("cocos2d_loadJsImg");
        if (!t) {
            t = cc.newElement("img"), cc._loadingImage && (t.src = cc._loadingImage);
            var n = e.getElementById(cc.game.config.id);
            n.style.backgroundColor = "black", n.parentNode.appendChild(t);
            var r = getComputedStyle ? getComputedStyle(n) : n.currentStyle;
            r || (r = {
                width: n.width,
                height: n.height
            }), t.style.left = n.offsetLeft + (parseFloat(r.width) - t.width) / 2 + "px", t.style.top = n.offsetTop + (parseFloat(r.height) - t.height) / 2 + "px", t.style.position = "absolute"
        }
        return t
    },
    loadTxt: function(e, t) {
        if (!cc._isNodeJs) {
            var n = this.getXMLHttpRequest(),
                r = "load " + e + " failed!";
            n.open("GET", e, !0), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (n.setRequestHeader("Accept-Charset", "utf-8"), n.onreadystatechange = function() {
                n.readyState == 4 && (n.status == 200 ? t(null, n.responseText) : t(r))
            }) : (n.overrideMimeType && n.overrideMimeType("text/plain; charset=utf-8"), n.onload = function() {
                n.readyState == 4 && (n.status == 200 ? t(null, n.responseText) : t(r))
            }), n.send(null)
        } else {
            var i = require("fs");
            i.readFile(e, function(e, n) {
                e ? t(e) : t(null, n.toString())
            })
        }
    },
    _loadTxtSync: function(e) {
        if (!cc._isNodeJs) {
            var t = this.getXMLHttpRequest();
            return t.open("GET", e, !1), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? t.setRequestHeader("Accept-Charset", "utf-8") : t.overrideMimeType && t.overrideMimeType("text/plain; charset=utf-8"), t.send(null), !t.readyState == 4 || t.status != 200 ? null : t.responseText
        }
        var n = require("fs");
        return n.readFileSync(e).toString()
    },
    loadJson: function(e, t) {
        this.loadTxt(e, function(n, r) {
            try {
                n ? t(n) : t(null, JSON.parse(r))
            } catch (i) {
                throw "load json [" + e + "] failed : " + i
            }
        })
    },
    _checkIsImageURL: function(e) {
        var t = /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(e);
        return t != null
    },
    loadImg: function(e, t, n) {
        var r = {
            isCrossOrigin: !0
        };
        n !== undefined ? r.isCrossOrigin = t.isCrossOrigin == null ? r.isCrossOrigin : t.isCrossOrigin : t !== undefined && (n = t);
        var i = new Image;
        r.isCrossOrigin && location.origin != "file://" && (i.crossOrigin = "Anonymous");
        var s = function() {
                this.removeEventListener("load", s, !1), this.removeEventListener("error", o, !1), n && n(null, i)
            },
            o = function() {
                this.removeEventListener("error", o, !1), i.crossOrigin.toLowerCase() == "anonymous" ? (r.isCrossOrigin = !1, cc.loader.loadImg(e, r, n)) : typeof n == "function" && n("load image failed")
            };
        return cc._addEventListener(i, "load", s), cc._addEventListener(i, "error", o), i.src = e, i
    },
    _loadResIterator: function(e, t, n) {
        var r = this,
            i = null,
            s = e.type;
        s ? (s = "." + s.toLowerCase(), i = e.src ? e.src : e.name + s) : (i = e, s = cc.path.extname(i));
        var o = r.cache[i];
        if (o)
            return n(null, o);
        var u = r._register[s.toLowerCase()];
        if (!u)
            return cc.error("loader for [" + s + "] not exists!"), n();
        var a = u.getBasePath ? u.getBasePath() : r.resPath,
            f = r.getUrl(a, i);
        u.load(f, i, e, function(e, t) {
            e ? (cc.log(e), r.cache[i] = null, delete r.cache[i], n()) : (r.cache[i] = t, n(null, t))
        })
    },
    getUrl: function(e, t) {
        var n = this,
            r = n._langPathCache,
            i = cc.path;
        if (e !== undefined && t === undefined) {
            t = e;
            var s = i.extname(t);
            s = s ? s.toLowerCase() : "";
            var o = n._register[s];
            o ? e = o.getBasePath ? o.getBasePath() : n.resPath : e = n.resPath
        }
        t = cc.path.join(e || "", t);
        if (t.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
            if (r[t])
                return r[t];
            var u = i.extname(t) || "";
            t = r[t] = t.substring(0, t.length - u.length) + "_" + cc.sys.language + u
        }
        return t
    },
    load: function(e, t, n) {
        var r = this,
            i = arguments.length;
        if (i == 0)
            throw "arguments error!";
        i == 3 ? typeof t == "function" && (typeof n == "function" ? t = {
            trigger: t,
            cb: n
        } : t = {
            cb: t,
            cbTarget: n
        }) : i == 2 ? typeof t == "function" && (t = {
            cb: t
        }) : i == 1 && (t = {}), e instanceof Array || (e = [e]);
        var s = new cc.AsyncPool(e, 0, function(e, n, i, s) {
            r._loadResIterator(e, n, function(e) {
                if (e)
                    return i(e);
                var n = Array.prototype.slice.call(arguments, 1);
                t.trigger && t.trigger.call(t.triggerTarget, n[0], s.size, s.finishedSize), i(null, n[0])
            })
        }, t.cb, t.cbTarget);
        return s.flow(), s
    },
    _handleAliases: function(e, t) {
        var n = this,
            r = n._aliases,
            i = [];
        for (var s in e) {
            var o = e[s];
            r[s] = o, i.push(o)
        }
        this.load(i, t)
    },
    loadAliases: function(e, t) {
        var n = this,
            r = n.getRes(e);
        r ? n._handleAliases(r.filenames, t) : n.load(e, function(e, r) {
            n._handleAliases(r[0].filenames, t)
        })
    },
    register: function(e, t) {
        if (!e || !t)
            return;
        var n = this;
        if (typeof e == "string")
            return this._register[e.trim().toLowerCase()] = t;
        for (var r = 0, i = e.length; r < i; r++)
            n._register["." + e[r].trim().toLowerCase()] = t
    },
    getRes: function(e) {
        return this.cache[e] || this.cache[this._aliases[e]]
    },
    release: function(e) {
        var t = this.cache,
            n = this._aliases;
        delete t[e], delete t[n[e]], delete n[e]
    },
    releaseAll: function() {
        var e = this.cache,
            t = this._aliases;
        for (var n in e)
            delete e[n];
        for (var n in t)
            delete t[n]
    }
}, cc.formatStr = function() {
    var e = arguments,
        t = e.length;
    if (t < 1)
        return "";
    var n = e[0],
        r = !0;
    typeof n == "object" && (r = !1);
    for (var i = 1; i < t; ++i) {
        var s = e[i];
        if (r)
            for (;;) {
                var o = null;
                if (typeof s == "number") {
                    o = n.match(/(%d)|(%s)/);
                    if (o) {
                        n = n.replace(/(%d)|(%s)/, s);
                        break
                    }
                }
                o = n.match(/%s/), o ? n = n.replace(/%s/, s) : n += "    " + s;
                break
            } else
            n += "    " + s
    }
    return n
},
function() {
    var e = window,
        t, n, r = "undefined";
    cc.isUndefined(document.hidden) ? cc.isUndefined(document.mozHidden) ? cc.isUndefined(document.msHidden) ? cc.isUndefined(document.webkitHidden) || (t = "webkitHidden", n = "webkitvisibilitychange") : (t = "msHidden", n = "msvisibilitychange") : (t = "mozHidden", n = "mozvisibilitychange") : (t = "hidden", n = "visibilitychange");
    var i = function() {
            cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
        },
        s = function() {
            cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow), cc.game._intervalId && (window.cancelAnimationFrame(cc.game._intervalId), cc.game._runMainLoop())
        };
    t ? cc._addEventListener(document, n, function() {
        document[t] ? i() : s()
    }, !1) : (cc._addEventListener(e, "blur", i, !1), cc._addEventListener(e, "focus", s, !1)), navigator.userAgent.indexOf("MicroMessenger") > -1 && (e.onfocus = function() {
        s()
    }), "onpageshow" in window && "onpagehide" in window && (cc._addEventListener(e, "pagehide", i, !1), cc._addEventListener(e, "pageshow", s, !1)), e = null, n = null
}(), cc.log = cc.warn = cc.error = cc.assert = function() {}, cc.create3DContext = function(e, t) {
    var n = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"],
        r = null;
    for (var i = 0; i < n.length; ++i) {
        try {
            r = e.getContext(n[i], t)
        } catch (s) {}
        if (r)
            break
    }
    return r
}, cc._initSys = function(e, t) {
    cc._RENDER_TYPE_CANVAS = 0, cc._RENDER_TYPE_WEBGL = 1, cc.sys = {};
    var n = cc.sys;
    n.LANGUAGE_ENGLISH = "en", n.LANGUAGE_CHINESE = "zh", n.LANGUAGE_FRENCH = "fr", n.LANGUAGE_ITALIAN = "it", n.LANGUAGE_GERMAN = "de", n.LANGUAGE_SPANISH = "es", n.LANGUAGE_DUTCH = "du", n.LANGUAGE_RUSSIAN = "ru", n.LANGUAGE_KOREAN = "ko", n.LANGUAGE_JAPANESE = "ja", n.LANGUAGE_HUNGARIAN = "hu", n.LANGUAGE_PORTUGUESE = "pt", n.LANGUAGE_ARABIC = "ar", n.LANGUAGE_NORWEGIAN = "no", n.LANGUAGE_POLISH = "pl", n.OS_WINDOWS = "Windows", n.OS_IOS = "iOS", n.OS_OSX = "OS X", n.OS_UNIX = "UNIX", n.OS_LINUX = "Linux", n.OS_ANDROID = "Android", n.OS_UNKNOWN = "Unknown", n.WINDOWS = 0, n.LINUX = 1, n.MACOS = 2, n.ANDROID = 3, n.IPHONE = 4, n.IPAD = 5, n.BLACKBERRY = 6, n.NACL = 7, n.EMSCRIPTEN = 8, n.TIZEN = 9, n.WINRT = 10, n.WP8 = 11, n.MOBILE_BROWSER = 100, n.DESKTOP_BROWSER = 101, n.BROWSER_TYPE_WECHAT = "wechat", n.BROWSER_TYPE_ANDROID = "androidbrowser", n.BROWSER_TYPE_IE = "ie", n.BROWSER_TYPE_QQ = "qqbrowser", n.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser", n.BROWSER_TYPE_UC = "ucbrowser", n.BROWSER_TYPE_360 = "360browser", n.BROWSER_TYPE_BAIDU_APP = "baiduboxapp", n.BROWSER_TYPE_BAIDU = "baidubrowser", n.BROWSER_TYPE_MAXTHON = "maxthon", n.BROWSER_TYPE_OPERA = "opera", n.BROWSER_TYPE_OUPENG = "oupeng", n.BROWSER_TYPE_MIUI = "miuibrowser", n.BROWSER_TYPE_FIREFOX = "firefox", n.BROWSER_TYPE_SAFARI = "safari", n.BROWSER_TYPE_CHROME = "chrome", n.BROWSER_TYPE_UNKNOWN = "unknown", n.isNative = !1;
    var r = [n.BROWSER_TYPE_BAIDU, n.BROWSER_TYPE_OPERA, n.BROWSER_TYPE_FIREFOX, n.BROWSER_TYPE_CHROME, n.BROWSER_TYPE_SAFARI],
        i = [n.BROWSER_TYPE_BAIDU, n.BROWSER_TYPE_OPERA, n.BROWSER_TYPE_FIREFOX, n.BROWSER_TYPE_CHROME, n.BROWSER_TYPE_BAIDU_APP, n.BROWSER_TYPE_SAFARI, n.BROWSER_TYPE_UC, n.BROWSER_TYPE_QQ, n.BROWSER_TYPE_MOBILE_QQ, n.BROWSER_TYPE_IE],
        s = window,
        o = s.navigator,
        u = document,
        a = u.documentElement,
        f = o.userAgent.toLowerCase();
    n.isMobile = f.indexOf("mobile") != -1 || f.indexOf("android") != -1, n.platform = n.isMobile ? n.MOBILE_BROWSER : n.DESKTOP_BROWSER;
    var l = o.language;
    l = l ? l : o.browserLanguage, l = l ? l.split("-")[0] : n.LANGUAGE_ENGLISH, n.language = l;
    var c = n.BROWSER_TYPE_UNKNOWN,
        h = f.match(/micromessenger|qqbrowser|mqqbrowser|ucbrowser|360browser|baiduboxapp|baidubrowser|maxthon|trident|oupeng|opera|miuibrowser|firefox/i) || f.match(/chrome|safari/i);
    h && h.length > 0 && (c = h[0].toLowerCase(), c == "micromessenger" ? c = n.BROWSER_TYPE_WECHAT : c === "safari" && f.match(/android.*applewebkit/) ? c = n.BROWSER_TYPE_ANDROID : c == "trident" && (c = n.BROWSER_TYPE_IE)), n.browserType = c, n._supportMultipleAudio = i.indexOf(n.browserType) > -1;
    var p = parseInt(e[t.renderMode]),
        d = cc._RENDER_TYPE_WEBGL,
        v = cc.newElement("Canvas");
    cc._supportRender = !0;
    var m = r.indexOf(n.browserType) == -1;
    if (p === 1 || p === 0 && (n.isMobile || m) || location.origin == "file://")
        d = cc._RENDER_TYPE_CANVAS;
    n._canUseCanvasNewBlendModes = function() {
        var e = document.createElement("canvas");
        e.width = 1, e.height = 1;
        var t = e.getContext("2d");
        t.fillStyle = "#000", t.fillRect(0, 0, 1, 1), t.globalCompositeOperation = "multiply";
        var n = document.createElement("canvas");
        n.width = 1, n.height = 1;
        var r = n.getContext("2d");
        return r.fillStyle = "#fff", r.fillRect(0, 0, 1, 1), t.drawImage(n, 0, 0, 1, 1), t.getImageData(0, 0, 1, 1).data[0] === 0
    }, n._supportCanvasNewBlendModes = n._canUseCanvasNewBlendModes(), d == cc._RENDER_TYPE_WEBGL && (!s.WebGLRenderingContext || !cc.create3DContext(v, {
        stencil: !0,
        preserveDrawingBuffer: !0
    })) && (p == 0 ? d = cc._RENDER_TYPE_CANVAS : cc._supportRender = !1);
    if (d == cc._RENDER_TYPE_CANVAS)
        try {
            v.getContext("2d")
        } catch (g) {
            cc._supportRender = !1
        }
    cc._renderType = d;
    try {
        n._supportWebAudio = !!(new(s.AudioContext || s.webkitAudioContext || s.mozAudioContext))
    } catch (g) {
        n._supportWebAudio = !1
    }
    try {
        var y = n.localStorage = s.localStorage;
        y.setItem("storage", ""), y.removeItem("storage"), y = null
    } catch (g) {
        (g.name === "SECURITY_ERR" || g.name === "QuotaExceededError") && cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option"), n.localStorage = function() {}
    }
    var b = n.capabilities = {
        canvas: !0
    };
    cc._renderType == cc._RENDER_TYPE_WEBGL && (b.opengl = !0);
    if (a.ontouchstart !== undefined || o.msPointerEnabled)
        b.touches = !0;
    a.onmouseup !== undefined && (b.mouse = !0), a.onkeyup !== undefined && (b.keyboard = !0);
    if (s.DeviceMotionEvent || s.DeviceOrientationEvent)
        b.accelerometer = !0;
    var w = f.match(/(iPad|iPhone|iPod)/i) ? !0 : !1,
        E = f.match(/android/i) || o.platform.match(/android/i) ? !0 : !1,
        S = n.OS_UNKNOWN;
    o.appVersion.indexOf("Win") != -1 ? S = n.OS_WINDOWS : w ? S = n.OS_IOS : o.appVersion.indexOf("Mac") != -1 ? S = n.OS_OSX : o.appVersion.indexOf("X11") != -1 ? S = n.OS_UNIX : E ? S = n.OS_ANDROID : o.appVersion.indexOf("Linux") != -1 && (S = n.OS_LINUX), n.os = S, n.garbageCollect = function() {}, n.dumpRoot = function() {}, n.restartVM = function() {}, n.dump = function() {
        var e = this,
            t = "";
        t += "isMobile : " + e.isMobile + "\r\n", t += "language : " + e.language + "\r\n", t += "browserType : " + e.browserType + "\r\n", t += "capabilities : " + JSON.stringify(e.capabilities) + "\r\n", t += "os : " + e.os + "\r\n", t += "platform : " + e.platform + "\r\n", cc.log(t)
    }
}, cc.ORIENTATION_PORTRAIT = 0, cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1, cc.ORIENTATION_LANDSCAPE_LEFT = 2, cc.ORIENTATION_LANDSCAPE_RIGHT = 3, cc._drawingUtil = null, cc._renderContext = null, cc._canvas = null, cc._gameDiv = null, cc._rendererInitialized = !1, cc._setupCalled = !1, cc._setup = function(e, t, n) {
    if (cc._setupCalled)
        return;
    cc._setupCalled = !0;
    var r = window,
        i = new Date,
        s = 1e3 / cc.game.config[cc.game.CONFIG_KEY.frameRate],
        o = function(e) {
            var t = (new Date).getTime(),
                n = Math.max(0, s - (t - i)),
                r = window.setTimeout(function() {
                    e()
                }, n);
            return i = t + n, r
        },
        u = function(e) {
            clearTimeout(e)
        };
    cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT ? (r.requestAnimFrame = o, r.cancelAnimationFrame = u) : cc.game.config[cc.game.CONFIG_KEY.frameRate] != 60 ? (r.requestAnimFrame = o, r.cancelAnimationFrame = u) : (r.requestAnimFrame = r.requestAnimationFrame || r.webkitRequestAnimationFrame || r.mozRequestAnimationFrame || r.oRequestAnimationFrame || r.msRequestAnimationFrame || o, r.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || u);
    var a = cc.$(e) || cc.$("#" + e),
        f, l, c;
    a.tagName == "CANVAS" ? (t = t || a.width, n = n || a.height, l = cc.container = cc.newElement("DIV"), f = cc._canvas = a, f.parentNode.insertBefore(l, f), f.appendTo(l), l.setAttribute("id", "Cocos2dGameContainer")) : (a.tagName != "DIV" && cc.log("Warning: target element is not a DIV or CANVAS"), t = t || a.clientWidth, n = n || a.clientHeight, l = cc.container = a, f = cc._canvas = cc.$(cc.newElement("CANVAS")), a.appendChild(f)), f.addClass("gameCanvas"), f.setAttribute("width", t || 480), f.setAttribute("height", n || 320), f.setAttribute("tabindex", 99), f.style.outline = "none", c = l.style, c.width = (t || 480) + "px", c.height = (n || 320) + "px", c.margin = "0 auto", c.position = "relative", c.overflow = "hidden", l.top = "100%", cc._renderType == cc._RENDER_TYPE_WEBGL && (cc._renderContext = cc.webglContext = cc.create3DContext(f, {
        stencil: !0,
        preserveDrawingBuffer: !0,
        antialias: !cc.sys.isMobile,
        alpha: !1
    })), cc._renderContext ? (r.gl = cc._renderContext, cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext), cc._rendererInitialized = !0, cc.textureCache._initializingRenderer(), cc.shaderCache._init()) : (cc._renderContext = f.getContext("2d"), cc._mainRenderContextBackup = cc._renderContext, cc._renderContext.translate(0, f.height), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null), cc._gameDiv = l, cc.log(cc.ENGINE_VERSION), cc._setContextMenuEnable(!1);
    if (cc.sys.isMobile) {
        var h = cc.newElement("style");
        h.type = "text/css", document.body.appendChild(h), h.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}"
    }
    cc.view = cc.EGLView._getInstance(), cc.inputManager.registerSystemEvent(cc._canvas), cc.director = cc.Director._getInstance(), cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view), cc.winSize = cc.director.getWinSize(), cc.saxParser = new cc.SAXParser, cc.plistParser = new cc.PlistParser
}, cc._checkWebGLRenderMode = function() {
    if (cc._renderType !== cc._RENDER_TYPE_WEBGL)
        throw "This feature supports WebGL render mode only."
}, cc._isContextMenuEnable = !1, cc._setContextMenuEnable = function(e) {
    cc._isContextMenuEnable = e, cc._canvas.oncontextmenu = function() {
        if (!cc._isContextMenuEnable)
            return !1
    }
}, cc.game = {
    DEBUG_MODE_NONE: 0,
    DEBUG_MODE_INFO: 1,
    DEBUG_MODE_WARN: 2,
    DEBUG_MODE_ERROR: 3,
    DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
    DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
    DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
    EVENT_HIDE: "game_on_hide",
    EVENT_SHOW: "game_on_show",
    _eventHide: null,
    _eventShow: null,
    _onBeforeStartArr: [],
    CONFIG_KEY: {
        engineDir: "engineDir",
        dependencies: "dependencies",
        debugMode: "debugMode",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        jsList: "jsList",
        classReleaseMode: "classReleaseMode"
    },
    _prepareCalled: !1,
    _prepared: !1,
    _paused: !0,
    _intervalId: null,
    config: null,
    onStart: null,
    onStop: null,
    setFrameRate: function(e) {
        var t = this,
            n = t.config,
            r = t.CONFIG_KEY;
        n[r.frameRate] = e, t._intervalId && window.cancelAnimationFrame(t._intervalId), t._paused = !0, t._runMainLoop()
    },
    _runMainLoop: function() {
        var e = this,
            t, n = e.config,
            r = e.CONFIG_KEY,
            i = cc.director;
        i.setDisplayStats(n[r.showFPS]), t = function() {
            e._paused || (i.mainLoop(), e._intervalId = window.requestAnimFrame(t))
        }, window.requestAnimFrame(t), e._paused = !1
    },
    run: function(e) {
        var t = this,
            n = function() {
                e && (t.config[t.CONFIG_KEY.id] = e), t._prepareCalled || t.prepare(function() {
                    t._prepared = !0
                }), cc._supportRender && (t._checkPrepare = setInterval(function() {
                    t._prepared && (cc._setup(t.config[t.CONFIG_KEY.id]), t._runMainLoop(), t._eventHide = t._eventHide || new cc.EventCustom(t.EVENT_HIDE), t._eventHide.setUserData(t), t._eventShow = t._eventShow || new cc.EventCustom(t.EVENT_SHOW), t._eventShow.setUserData(t), t.onStart(), clearInterval(t._checkPrepare))
                }, 10))
            };
        document.body ? n() : cc._addEventListener(window, "load", function() {
            this.removeEventListener("load", arguments.callee, !1), n()
        }, !1)
    },
    _initConfig: function() {
        var e = this,
            t = e.CONFIG_KEY,
            n = function(e) {
                return e[t.engineDir] = e[t.engineDir] || "frameworks/cocos2d-html5", e[t.debugMode] == null && (e[t.debugMode] = 0), e[t.frameRate] = e[t.frameRate] || 60, e[t.renderMode] == null && (e[t.renderMode] = 1), e
            };
        if (document.ccConfig)
            e.config = n(document.ccConfig);
        else
            try {
                var r = document.getElementsByTagName("script");
                for (var i = 0; i < r.length; i++) {
                    var s = r[i].getAttribute("cocos");
                    if (s == "" || s)
                        break
                }
                var o, u, a;
                i < r.length && (o = r[i].src, o && (a = /(.*)\//.exec(o)[0], cc.loader.resPath = a, o = cc.path.join(a, "project.json")), u = cc.loader._loadTxtSync(o)), u || (u = cc.loader._loadTxtSync(""));
                var f = JSON.parse(u);
                e.config = n(f || {})
            } catch (l) {
                cc.log("Failed to read or parse project.json"), e.config = n({})
            }
        cc._initSys(e.config, t)
    },
    _jsAddedCache: {},
    _getJsListOfModule: function(e, t, n) {
        var r = this._jsAddedCache;
        if (r[t])
            return null;
        n = n || "";
        var i = [],
            s = e[t];
        if (!s)
            throw "can not find module [" + t + "]";
        var o = cc.path;
        for (var u = 0, a = s.length; u < a; u++) {
            var f = s[u];
            if (r[f])
                continue;
            var l = o.extname(f);
            if (!l) {
                var c = this._getJsListOfModule(e, f, n);
                c && (i = i.concat(c))
            } else
                l.toLowerCase() == ".js" && i.push(o.join(n, f));
            r[f] = 1
        }
        return i
    },
    prepare: function(e) {
        var t = this,
            n = t.config,
            r = t.CONFIG_KEY,
            i = n[r.engineDir],
            s = cc.loader;
        if (!cc._supportRender)
            throw "The renderer doesn't support the renderMode " + n[r.renderMode];
        t._prepareCalled = !0;
        var o = n[r.jsList] || [];
        if (cc.Class)
            s.loadJsWithImg("", o, function(n) {
                if (n)
                    throw n;
                t._prepared = !0, e && e()
            });
        else {
            var u = cc.path.join(i, "moduleConfig.json");
            s.loadJson(u, function(r, s) {
                if (r)
                    throw r;
                var u = n.modules || [],
                    a = s.module,
                    f = [];
                cc._renderType == cc._RENDER_TYPE_WEBGL ? u.splice(0, 0, "shaders") : u.indexOf("core") < 0 && u.splice(0, 0, "core");
                for (var l = 0, c = u.length; l < c; l++) {
                    var h = t._getJsListOfModule(a, u[l], i);
                    h && (f = f.concat(h))
                }
                f = f.concat(o), cc.loader.loadJsWithImg(f, function(n) {
                    if (n)
                        throw n;
                    t._prepared = !0, e && e()
                })
            })
        }
    }
}, cc.game._initConfig(), Function.prototype.bind = Function.prototype.bind || function(e) {
    if (!cc.isFunction(this))
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    var t = Array.prototype.slice.call(arguments, 1),
        n = this,
        r = function() {},
        i = function() {
            return n.apply(this instanceof r && e ? this : e, t.concat(Array.prototype.slice.call(arguments)))
        };
    return r.prototype = this.prototype, i.prototype = new r, i
};
var cc = cc || {};
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7", cc._fpsImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII=", cc._loaderImage = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k=", cc.loader.loadBinary = function(e, t) {
    var n = this,
        r = this.getXMLHttpRequest(),
        i = "load " + e + " failed!";
    r.open("GET", e, !0), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (r.setRequestHeader("Accept-Charset", "x-user-defined"), r.onreadystatechange = function() {
        if (r.readyState == 4 && r.status == 200) {
            var e = cc._convertResponseBodyToText(r.responseBody);
            t(null, n._str2Uint8Array(e))
        } else
            t(i)
    }) : (r.overrideMimeType && r.overrideMimeType("text/plain; charset=x-user-defined"), r.onload = function() {
        r.readyState == 4 && r.status == 200 ? t(null, n._str2Uint8Array(r.responseText)) : t(i)
    }), r.send(null)
}, cc.loader._str2Uint8Array = function(e) {
    if (!e)
        return null;
    var t = new Uint8Array(e.length);
    for (var n = 0; n < e.length; n++)
        t[n] = e.charCodeAt(n) & 255;
    return t
}, cc.loader.loadBinarySync = function(e) {
    var t = this,
        n = this.getXMLHttpRequest(),
        r = "load " + e + " failed!";
    n.open("GET", e, !1);
    var i = null;
    if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        n.setRequestHeader("Accept-Charset", "x-user-defined"), n.send(null);
        if (n.status != 200)
            return cc.log(r), null;
        var s = cc._convertResponseBodyToText(n.responseBody);
        s && (i = t._str2Uint8Array(s))
    } else {
        n.overrideMimeType && n.overrideMimeType("text/plain; charset=x-user-defined"), n.send(null);
        if (n.status != 200)
            return cc.log(r), null;
        i = this._str2Uint8Array(n.responseText)
    }
    return i
};
var Uint8Array = Uint8Array || Array;
if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    var IEBinaryToArray_ByteStr_Script = '<!-- IEBinaryToArray_ByteStr -->\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr = CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex = LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last = ""\r\n   End If\r\nEnd Function\r\n',
        myVBScript = cc.newElement("script");
    myVBScript.type = "text/vbscript", myVBScript.textContent = IEBinaryToArray_ByteStr_Script, document.body.appendChild(myVBScript), cc._convertResponseBodyToText = function(e) {
        var t = {};
        for (var n = 0; n < 256; n++)
            for (var r = 0; r < 256; r++)
                t[String.fromCharCode(n + r * 256)] = String.fromCharCode(n) + String.fromCharCode(r);
        var i = IEBinaryToArray_ByteStr(e),
            s = IEBinaryToArray_ByteStr_Last(e);
        return i.replace(/[\s\S]/g, function(e) {
            return t[e]
        }) + s
    }
}
var cc = cc || {},
    ClassManager = {
        id: 0 | Math.random() * 998,
        instanceId: 0 | Math.random() * 998,
        compileSuper: function(e, t, n) {
            var r = e.toString(),
                i = r.indexOf("("),
                s = r.indexOf(")"),
                o = r.substring(i + 1, s);
            o = o.trim();
            var u = r.indexOf("{"),
                a = r.lastIndexOf("}"),
                r = r.substring(u + 1, a);
            while (r.indexOf("this._super") != -1) {
                var f = r.indexOf("this._super"),
                    l = r.indexOf("(", f),
                    c = r.indexOf(")", l),
                    h = r.substring(l + 1, c);
                h = h.trim();
                var p = h ? "," : "";
                r = r.substring(0, f) + "ClassManager[" + n + "]." + t + ".call(this" + p + r.substring(l + 1)
            }
            return Function(o, r)
        },
        getNewID: function() {
            return this.id++
        },
        getNewInstanceId: function() {
            return this.instanceId++
        }
    };
ClassManager.compileSuper.ClassManager = ClassManager,
function() {
    var e = /\b_super\b/,
        t = cc.game.config,
        n = t[cc.game.CONFIG_KEY.classReleaseMode];
    n && console.log("release Mode"), cc.Class = function() {}, cc.Class.extend = function(t) {
        function u() {
            this.__instanceId = ClassManager.getNewInstanceId(), this.ctor && this.ctor.apply(this, arguments)
        }
        var r = this.prototype,
            i = Object.create(r),
            s = ClassManager.getNewID();
        ClassManager[s] = r;
        var o = {
            writable: !0,
            enumerable: !1,
            configurable: !0
        };
        i.__instanceId = null, u.id = s, o.value = s, Object.defineProperty(i, "__pid", o), u.prototype = i, o.value = u, Object.defineProperty(u.prototype, "constructor", o), this.__getters__ && (u.__getters__ = cc.clone(this.__getters__)), this.__setters__ && (u.__setters__ = cc.clone(this.__setters__));
        for (var a = 0, f = arguments.length; a < f; ++a) {
            var l = arguments[a];
            for (var c in l) {
                var h = typeof l[c] == "function",
                    p = typeof r[c] == "function",
                    d = e.test(l[c]);
                n && h && p && d ? (o.value = ClassManager.compileSuper(l[c], c, s), Object.defineProperty(i, c, o)) : h && p && d ? (o.value = function(e, t) {
                    return function() {
                        var n = this._super;
                        this._super = r[e];
                        var i = t.apply(this, arguments);
                        return this._super = n, i
                    }
                }(c, l[c]), Object.defineProperty(i, c, o)) : h ? (o.value = l[c], Object.defineProperty(i, c, o)) : i[c] = l[c];
                if (h) {
                    var v, m, g;
                    if (this.__getters__ && this.__getters__[c]) {
                        g = this.__getters__[c];
                        for (var y in this.__setters__)
                            if (this.__setters__[y] == g) {
                                m = y;
                                break
                            }
                        cc.defineGetterSetter(i, g, l[c], l[m] ? l[m] : i[m], c, m)
                    }
                    if (this.__setters__ && this.__setters__[c]) {
                        g = this.__setters__[c];
                        for (var y in this.__getters__)
                            if (this.__getters__[y] == g) {
                                v = y;
                                break
                            }
                        cc.defineGetterSetter(i, g, l[v] ? l[v] : i[v], l[c], v, c)
                    }
                }
            }
        }
        return u.extend = cc.Class.extend, u.implement = function(e) {
            for (var t in e)
                i[t] = e[t]
        }, u
    }
}(), cc.defineGetterSetter = function(e, t, n, r, i, s) {
    if (e.__defineGetter__)
        n && e.__defineGetter__(t, n), r && e.__defineSetter__(t, r);
    else {
        if (!Object.defineProperty)
            throw new Error("browser does not support getters");
        var o = {
            enumerable: !1,
            configurable: !0
        };
        n && (o.get = n), r && (o.set = r), Object.defineProperty(e, t, o)
    }
    if (!i && !s) {
        var u = n != null,
            a = r != undefined,
            f = Object.getOwnPropertyNames(e);
        for (var l = 0; l < f.length; l++) {
            var c = f[l];
            if ((e.__lookupGetter__ ? e.__lookupGetter__(c) : Object.getOwnPropertyDescriptor(e, c)) || typeof e[c] != "function")
                continue;
            var h = e[c];
            if (u && h === n) {
                i = c;
                if (!a || s)
                    break
            }
            if (a && h === r) {
                s = c;
                if (!u || i)
                    break
            }
        }
    }
    var p = e.constructor;
    i && (p.__getters__ || (p.__getters__ = {}), p.__getters__[i] = t), s && (p.__setters__ || (p.__setters__ = {}), p.__setters__[s] = t)
}, cc.clone = function(e) {
    var t = e.constructor ? new e.constructor : {};
    for (var n in e) {
        var r = e[n];
        typeof r != "object" || !r || r instanceof cc.Node || r instanceof HTMLElement ? t[n] = r : t[n] = cc.clone(r)
    }
    return t
}, cc.Point = function(e, t) {
    this.x = e || 0, this.y = t || 0
}, cc.p = function(e, t) {
    return e == undefined ? {
        x: 0,
        y: 0
    } : t == undefined ? {
        x: e.x,
        y: e.y
    } : {
        x: e,
        y: t
    }
}, cc.pointEqualToPoint = function(e, t) {
    return e && t && e.x === t.x && e.y === t.y
}, cc.Size = function(e, t) {
    this.width = e || 0, this.height = t || 0
}, cc.size = function(e, t) {
    return e === undefined ? {
        width: 0,
        height: 0
    } : t === undefined ? {
        width: e.width,
        height: e.height
    } : {
        width: e,
        height: t
    }
}, cc.sizeEqualToSize = function(e, t) {
    return e && t && e.width == t.width && e.height == t.height
}, cc.Rect = function(e, t, n, r) {
    this.x = e || 0, this.y = t || 0, this.width = n || 0, this.height = r || 0
}, cc.rect = function(e, t, n, r) {
    return e === undefined ? {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    } : t === undefined ? {
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
    } : {
        x: e,
        y: t,
        width: n,
        height: r
    }
}, cc.rectEqualToRect = function(e, t) {
    return e && t && e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height
}, cc._rectEqualToZero = function(e) {
    return e && e.x === 0 && e.y === 0 && e.width === 0 && e.height === 0
}, cc.rectContainsRect = function(e, t) {
    return !e || !t ? !1 : !(e.x >= t.x || e.y >= t.y || e.x + e.width <= t.x + t.width || e.y + e.height <= t.y + t.height)
}, cc.rectGetMaxX = function(e) {
    return e.x + e.width
}, cc.rectGetMidX = function(e) {
    return e.x + e.width / 2
}, cc.rectGetMinX = function(e) {
    return e.x
}, cc.rectGetMaxY = function(e) {
    return e.y + e.height
}, cc.rectGetMidY = function(e) {
    return e.y + e.height / 2
}, cc.rectGetMinY = function(e) {
    return e.y
}, cc.rectContainsPoint = function(e, t) {
    return t.x >= cc.rectGetMinX(e) && t.x <= cc.rectGetMaxX(e) && t.y >= cc.rectGetMinY(e) && t.y <= cc.rectGetMaxY(e)
}, cc.rectIntersectsRect = function(e, t) {
    var n = e.x + e.width,
        r = e.y + e.height,
        i = t.x + t.width,
        s = t.y + t.height;
    return !(n < t.x || i < e.x || r < t.y || s < e.y)
}, cc.rectOverlapsRect = function(e, t) {
    return !(e.x + e.width < t.x || t.x + t.width < e.x || e.y + e.height < t.y || t.y + t.height < e.y)
}, cc.rectUnion = function(e, t) {
    var n = cc.rect(0, 0, 0, 0);
    return n.x = Math.min(e.x, t.x), n.y = Math.min(e.y, t.y), n.width = Math.max(e.x + e.width, t.x + t.width) - n.x, n.height = Math.max(e.y + e.height, t.y + t.height) - n.y, n
}, cc.rectIntersection = function(e, t) {
    var n = cc.rect(Math.max(cc.rectGetMinX(e), cc.rectGetMinX(t)), Math.max(cc.rectGetMinY(e), cc.rectGetMinY(t)), 0, 0);
    return n.width = Math.min(cc.rectGetMaxX(e), cc.rectGetMaxX(t)) - cc.rectGetMinX(n), n.height = Math.min(cc.rectGetMaxY(e), cc.rectGetMaxY(t)) - cc.rectGetMinY(n), n
}, cc.SAXParser = cc.Class.extend({
    _parser: null,
    _isSupportDOMParser: null,
    ctor: function() {
        window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
    },
    parse: function(e) {
        return this._parseXML(e)
    },
    _parseXML: function(e) {
        var t;
        return this._isSupportDOMParser ? t = this._parser.parseFromString(e, "text/xml") : (t = new ActiveXObject("Microsoft.XMLDOM"), t.async = "false", t.loadXML(e)), t
    }
}), cc.PlistParser = cc.SAXParser.extend({
    parse: function(e) {
        var t = this._parseXML(e),
            n = t.documentElement;
        if (n.tagName != "plist")
            throw "Not a plist file!";
        var r = null;
        for (var i = 0, s = n.childNodes.length; i < s; i++) {
            r = n.childNodes[i];
            if (r.nodeType == 1)
                break
        }
        return t = null, this._parseNode(r)
    },
    _parseNode: function(e) {
        var t = null,
            n = e.tagName;
        if (n == "dict")
            t = this._parseDict(e);
        else if (n == "array")
            t = this._parseArray(e);
        else if (n == "string")
            if (e.childNodes.length == 1)
                t = e.firstChild.nodeValue;
            else {
                t = "";
                for (var r = 0; r < e.childNodes.length; r++)
                    t += e.childNodes[r].nodeValue
            } else
            n == "false" ? t = !1 : n == "true" ? t = !0 : n == "real" ? t = parseFloat(e.firstChild.nodeValue) : n == "integer" && (t = parseInt(e.firstChild.nodeValue, 10));
        return t
    },
    _parseArray: function(e) {
        var t = [];
        for (var n = 0, r = e.childNodes.length; n < r; n++) {
            var i = e.childNodes[n];
            if (i.nodeType != 1)
                continue;
            t.push(this._parseNode(i))
        }
        return t
    },
    _parseDict: function(e) {
        var t = {},
            n = null;
        for (var r = 0, i = e.childNodes.length; r < i; r++) {
            var s = e.childNodes[r];
            if (s.nodeType != 1)
                continue;
            s.tagName == "key" ? n = s.firstChild.nodeValue : t[n] = this._parseNode(s)
        }
        return t
    }
}), cc._txtLoader = {
    load: function(e, t, n, r) {
        cc.loader.loadTxt(e, r)
    }
}, cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader), cc._jsonLoader = {
    load: function(e, t, n, r) {
        cc.loader.loadJson(e, r)
    }
}, cc.loader.register(["json", "ExportJson"], cc._jsonLoader), cc._imgLoader = {
    load: function(e, t, n, r) {
        cc.loader.cache[t] = cc.loader.loadImg(e, function(e, n) {
            if (e)
                return r(e);
            cc.textureCache.handleLoadedTexture(t), r(null, n)
        })
    }
}, cc.loader.register(["png", "jpg", "bmp", "jpeg", "gif", "ico"], cc._imgLoader), cc._serverImgLoader = {
    load: function(e, t, n, r) {
        cc.loader.cache[t] = cc.loader.loadImg(n.src, function(e, n) {
            if (e)
                return r(e);
            cc.textureCache.handleLoadedTexture(t), r(null, n)
        })
    }
}, cc.loader.register(["serverImg"], cc._serverImgLoader), cc._plistLoader = {
    load: function(e, t, n, r) {
        cc.loader.loadTxt(e, function(e, t) {
            if (e)
                return r(e);
            r(null, cc.plistParser.parse(t))
        })
    }
}, cc.loader.register(["plist"], cc._plistLoader), cc._fontLoader = {
    TYPE: {
        ".eot": "embedded-opentype",
        ".ttf": "truetype",
        ".woff": "woff",
        ".svg": "svg"
    },
    _loadFont: function(e, t, n) {
        var r = document,
            i = cc.path,
            s = this.TYPE,
            o = cc.newElement("style");
        o.type = "text/css", r.body.appendChild(o);
        var u = "@font-face { font-family:" + e + "; src:";
        if (t instanceof Array)
            for (var a = 0, f = t.length; a < f; a++) {
                var l = t[a];
                n = i.extname(l).toLowerCase(), u += "url('" + t[a] + "') format('" + s[n] + "')", u += a == f - 1 ? ";" : ","
            } else
            u += "url('" + t + "') format('" + s[n] + "');";
        o.textContent += u + "};";
        var c = cc.newElement("div"),
            h = c.style;
        h.fontFamily = e, c.innerHTML = ".", h.position = "absolute", h.left = "-100px", h.top = "-100px", r.body.appendChild(c)
    },
    load: function(e, t, n, r) {
        var i = this,
            s = n.type,
            o = n.name,
            u = n.srcs;
        cc.isString(n) ? (s = cc.path.extname(n), o = cc.path.basename(n, s), i._loadFont(o, n, s)) : i._loadFont(o, u), r(null, !0)
    }
}, cc.loader.register(["font", "eot", "ttf", "woff", "svg"], cc._fontLoader), cc._binaryLoader = {
    load: function(e, t, n, r) {
        cc.loader.loadBinary(e, r)
    }
}, window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.0 Final", cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0, cc.DIRECTOR_STATS_POSITION = cc.p(0, 0), cc.DIRECTOR_FPS_INTERVAL = .5, cc.COCOSNODE_RENDER_SUBPIXEL = 1, cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1, cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 0, cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0, cc.TEXTURE_ATLAS_USE_VAO = 0, cc.TEXTURE_NPOT_SUPPORT = 0, cc.RETINA_DISPLAY_SUPPORT = 1, cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd", cc.USE_LA88_LABELS = 1, cc.SPRITE_DEBUG_DRAW = 0, cc.SPRITEBATCHNODE_DEBUG_DRAW = 0, cc.LABELBMFONT_DEBUG_DRAW = 0, cc.LABELATLAS_DEBUG_DRAW = 0, cc.IS_RETINA_DISPLAY_SUPPORTED = 1, cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas", cc.ENABLE_STACKABLE_ACTIONS = 1, cc.ENABLE_GL_STATE_CACHE = 1, cc.$ = function(e) {
    var t = this == cc ? document : this,
        n = e instanceof HTMLElement ? e : t.querySelector(e);
    return n && (n.find = n.find || cc.$, n.hasClass = n.hasClass || function(e) {
        return this.className.match(new RegExp("(\\s|^)" + e + "(\\s|$)"))
    }, n.addClass = n.addClass || function(e) {
        return this.hasClass(e) || (this.className && (this.className += " "), this.className += e), this
    }, n.removeClass = n.removeClass || function(e) {
        return this.hasClass(e) && (this.className = this.className.replace(e, "")), this
    }, n.remove = n.remove || function() {
        return this.parentNode && this.parentNode.removeChild(this), this
    }, n.appendTo = n.appendTo || function(e) {
        return e.appendChild(this), this
    }, n.prependTo = n.prependTo || function(e) {
        return e.childNodes[0] ? e.insertBefore(this, e.childNodes[0]) : e.appendChild(this), this
    }, n.transforms = n.transforms || function() {
        return this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew), this
    }, n.position = n.position || {
        x: 0,
        y: 0
    }, n.rotation = n.rotation || 0, n.scale = n.scale || {
        x: 1,
        y: 1
    }, n.skew = n.skew || {
        x: 0,
        y: 0
    }, n.translates = function(e, t) {
        return this.position.x = e, this.position.y = t, this.transforms(), this
    }, n.rotate = function(e) {
        return this.rotation = e, this.transforms(), this
    }, n.resize = function(e, t) {
        return this.scale.x = e, this.scale.y = t, this.transforms(), this
    }, n.setSkew = function(e, t) {
        return this.skew.x = e, this.skew.y = t, this.transforms(), this
    }), n
};
switch (cc.sys.browserType) {
    case cc.sys.BROWSER_TYPE_FIREFOX:
        cc.$.pfx = "Moz", cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.$.pfx = "webkit", cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_OPERA:
        cc.$.pfx = "O", cc.$.hd = !1;
        break;
    case cc.sys.BROWSER_TYPE_IE:
        cc.$.pfx = "ms", cc.$.hd = !1;
        break;
    default:
        cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform", cc.$.translate = cc.$.hd ? function(e) {
    return "translate3d(" + e.x + "px, " + e.y + "px, 0) "
} : function(e) {
    return "translate(" + e.x + "px, " + e.y + "px) "
}, cc.$.rotate = cc.$.hd ? function(e) {
    return "rotateZ(" + e + "deg) "
} : function(e) {
    return "rotate(" + e + "deg) "
}, cc.$.scale = function(e) {
    return "scale(" + e.x + ", " + e.y + ") "
}, cc.$.skew = function(e) {
    return "skewX(" + -e.x + "deg) skewY(" + e.y + "deg)"
}, cc.$new = function(e) {
    return cc.$(document.createElement(e))
}, cc.$.findpos = function(e) {
    var t = 0,
        n = 0;
    do
        t += e.offsetLeft, n += e.offsetTop;
    while (e = e.offsetParent);
    return {
        x: t,
        y: n
    }
}, cc.INVALID_INDEX = -1, cc.PI = Math.PI, cc.FLT_MAX = parseFloat("3.402823466e+38F"), cc.FLT_MIN = parseFloat("1.175494351e-38F"), cc.RAD = cc.PI / 180, cc.DEG = 180 / cc.PI, cc.UINT_MAX = 4294967295, cc.swap = function(e, t, n) {
    if (cc.isObject(n) && !cc.isUndefined(n.x) && !cc.isUndefined(n.y)) {
        var r = n[e];
        n[e] = n[t], n[t] = r
    } else
        cc.log(cc._LogInfos.swap)
}, cc.lerp = function(e, t, n) {
    return e + (t - e) * n
}, cc.rand = function() {
    return Math.random() * 16777215
}, cc.randomMinus1To1 = function() {
    return (Math.random() - .5) * 2
}, cc.random0To1 = Math.random, cc.degreesToRadians = function(e) {
    return e * cc.RAD
}, cc.radiansToDegrees = function(e) {
    return e * cc.DEG
}, cc.radiansToDegress = function(e) {
    return cc.log(cc._LogInfos.radiansToDegress), e * cc.DEG
}, cc.REPEAT_FOREVER = Number.MAX_VALUE - 1, cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 770, cc.BLEND_DST = 771, cc.nodeDrawSetup = function(e) {
    e._shaderProgram && (e._shaderProgram.use(), e._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
}, cc.enableDefaultGLStates = function() {}, cc.disableDefaultGLStates = function() {}, cc.incrementGLDraws = function(e) {
    cc.g_NumberOfDraws += e
}, cc.FLT_EPSILON = 1.192092896e-7, cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
    return cc.director.getContentScaleFactor()
} : function() {
    return 1
}, cc.pointPointsToPixels = function(e) {
    var t = cc.contentScaleFactor();
    return cc.p(e.x * t, e.y * t)
}, cc.pointPixelsToPoints = function(e) {
    var t = cc.contentScaleFactor();
    return cc.p(e.x / t, e.y / t)
}, cc._pointPixelsToPointsOut = function(e, t) {
    var n = cc.contentScaleFactor();
    t.x = e.x / n, t.y = e.y / n
}, cc.sizePointsToPixels = function(e) {
    var t = cc.contentScaleFactor();
    return cc.size(e.width * t, e.height * t)
}, cc.sizePixelsToPoints = function(e) {
    var t = cc.contentScaleFactor();
    return cc.size(e.width / t, e.height / t)
}, cc._sizePixelsToPointsOut = function(e, t) {
    var n = cc.contentScaleFactor();
    t.width = e.width / n, t.height = e.height / n
}, cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(e) {
    var t = cc.contentScaleFactor();
    return cc.rect(e.x / t, e.y / t, e.width / t, e.height / t)
} : function(e) {
    return e
}, cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(e) {
    var t = cc.contentScaleFactor();
    return cc.rect(e.x * t, e.y * t, e.width * t, e.height * t)
} : function(e) {
    return e
}, cc.ONE = 1, cc.ZERO = 0, cc.SRC_ALPHA = 770, cc.SRC_ALPHA_SATURATE = 776, cc.SRC_COLOR = 768, cc.DST_ALPHA = 772, cc.DST_COLOR = 774, cc.ONE_MINUS_SRC_ALPHA = 771, cc.ONE_MINUS_SRC_COLOR = 769, cc.ONE_MINUS_DST_ALPHA = 773, cc.ONE_MINUS_DST_COLOR = 775, cc.ONE_MINUS_CONSTANT_ALPHA = 32772, cc.ONE_MINUS_CONSTANT_COLOR = 32770, cc.checkGLErrorDebug = function() {
    if (cc.renderMode == cc._RENDER_TYPE_WEBGL) {
        var e = cc._renderContext.getError();
        e && cc.log(cc._LogInfos.checkGLErrorDebug, e)
    }
}, cc.DEVICE_ORIENTATION_PORTRAIT = 0, cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1, cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2, cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3, cc.DEVICE_MAX_ORIENTATIONS = 2, cc.VERTEX_ATTRIB_FLAG_NONE = 0, cc.VERTEX_ATTRIB_FLAG_POSITION = 1, cc.VERTEX_ATTRIB_FLAG_COLOR = 2, cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4, cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS, cc.GL_ALL = 0, cc.VERTEX_ATTRIB_POSITION = 0, cc.VERTEX_ATTRIB_COLOR = 1, cc.VERTEX_ATTRIB_TEX_COORDS = 2, cc.VERTEX_ATTRIB_MAX = 3, cc.UNIFORM_PMATRIX = 0, cc.UNIFORM_MVMATRIX = 1, cc.UNIFORM_MVPMATRIX = 2, cc.UNIFORM_TIME = 3, cc.UNIFORM_SINTIME = 4, cc.UNIFORM_COSTIME = 5, cc.UNIFORM_RANDOM01 = 6, cc.UNIFORM_SAMPLER = 7, cc.UNIFORM_MAX = 8, cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor", cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest", cc.SHADER_POSITION_COLOR = "ShaderPositionColor", cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture", cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor", cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color", cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor", cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor", cc.UNIFORM_PMATRIX_S = "CC_PMatrix", cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix", cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix", cc.UNIFORM_TIME_S = "CC_Time", cc.UNIFORM_SINTIME_S = "CC_SinTime", cc.UNIFORM_COSTIME_S = "CC_CosTime", cc.UNIFORM_RANDOM01_S = "CC_Random01", cc.UNIFORM_SAMPLER_S = "CC_Texture0", cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value", cc.ATTRIBUTE_NAME_COLOR = "a_color", cc.ATTRIBUTE_NAME_POSITION = "a_position", cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord", cc.ITEM_SIZE = 32, cc.CURRENT_ITEM = 3233828865, cc.ZOOM_ACTION_TAG = 3233828866, cc.NORMAL_TAG = 8801, cc.SELECTED_TAG = 8802, cc.DISABLE_TAG = 8803, cc.arrayVerifyType = function(e, t) {
    if (e && e.length > 0)
        for (var n = 0; n < e.length; n++)
            if (!(e[n] instanceof t))
                return cc.log("element type is wrong!"), !1;
    return !0
}, cc.arrayRemoveObject = function(e, t) {
    for (var n = 0, r = e.length; n < r; n++)
        if (e[n] == t) {
            e.splice(n, 1);
            break
        }
}, cc.arrayRemoveArray = function(e, t) {
    for (var n = 0, r = t.length; n < r; n++)
        cc.arrayRemoveObject(e, t[n])
}, cc.arrayAppendObjectsToIndex = function(e, t, n) {
    return e.splice.apply(e, [n, 0].concat(t)), e
}, cc.copyArray = function(e) {
    var t, n = e.length,
        r = new Array(n);
    for (t = 0; t < n; t += 1)
        r[t] = e[t];
    return r
}, cc._tmp.PrototypeColor = function() {
    var e = cc.color;
    e._getWhite = function() {
        return e(255, 255, 255)
    }, e._getYellow = function() {
        return e(255, 255, 0)
    }, e._getBlue = function() {
        return e(0, 0, 255)
    }, e._getGreen = function() {
        return e(0, 255, 0)
    }, e._getRed = function() {
        return e(255, 0, 0)
    }, e._getMagenta = function() {
        return e(255, 0, 255)
    }, e._getBlack = function() {
        return e(0, 0, 0)
    }, e._getOrange = function() {
        return e(255, 127, 0)
    }, e._getGray = function() {
        return e(166, 166, 166)
    }, e.WHITE, cc.defineGetterSetter(e, "WHITE", e._getWhite), e.YELLOW, cc.defineGetterSetter(e, "YELLOW", e._getYellow), e.BLUE, cc.defineGetterSetter(e, "BLUE", e._getBlue), e.GREEN, cc.defineGetterSetter(e, "GREEN", e._getGreen), e.RED, cc.defineGetterSetter(e, "RED", e._getRed), e.MAGENTA, cc.defineGetterSetter(e, "MAGENTA", e._getMagenta), e.BLACK, cc.defineGetterSetter(e, "BLACK", e._getBlack), e.ORANGE, cc.defineGetterSetter(e, "ORANGE", e._getOrange), e.GRAY, cc.defineGetterSetter(e, "GRAY", e._getGray), cc.BlendFunc._disable = function() {
        return new cc.BlendFunc(cc.ONE, cc.ZERO)
    }, cc.BlendFunc._alphaPremultiplied = function() {
        return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA)
    }, cc.BlendFunc._alphaNonPremultiplied = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA)
    }, cc.BlendFunc._additive = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE)
    }, cc.BlendFunc.DISABLE, cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable), cc.BlendFunc.ALPHA_PREMULTIPLIED, cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied), cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied), cc.BlendFunc.ADDITIVE, cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive)
}, cc.Color = function(e, t, n, r) {
    this.r = e || 0, this.g = t || 0, this.b = n || 0, this.a = r == null ? 255 : r
}, cc.color = function(e, t, n, r) {
    return e === undefined ? {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    } : cc.isString(e) ? cc.hexToColor(e) : cc.isObject(e) ? {
        r: e.r,
        g: e.g,
        b: e.b,
        a: e.a == null ? 255 : e.a
    } : {
        r: e,
        g: t,
        b: n,
        a: r == null ? 255 : r
    }
}, cc.colorEqual = function(e, t) {
    return e.r === t.r && e.g === t.g && e.b === t.b
}, cc.Acceleration = function(e, t, n, r) {
    this.x = e || 0, this.y = t || 0, this.z = n || 0, this.timestamp = r || 0
}, cc.Vertex2F = function(e, t) {
    this.x = e || 0, this.y = t || 0
}, cc.vertex2 = function(e, t) {
    return new cc.Vertex2F(e, t)
}, cc.Vertex3F = function(e, t, n) {
    this.x = e || 0, this.y = t || 0, this.z = n || 0
}, cc.vertex3 = function(e, t, n) {
    return new cc.Vertex3F(e, t, n)
}, cc.Tex2F = function(e, t) {
    this.u = e || 0, this.v = t || 0
}, cc.tex2 = function(e, t) {
    return new cc.Tex2F(e, t)
}, cc.BlendFunc = function(e, t) {
    this.src = e, this.dst = t
}, cc.blendFuncDisable = function() {
    return new cc.BlendFunc(cc.ONE, cc.ZERO)
}, cc.hexToColor = function(e) {
    e = e.replace(/^#?/, "0x");
    var t = parseInt(e),
        n = t >> 16,
        r = (t >> 8) % 256,
        i = t % 256;
    return cc.color(n, r, i)
}, cc.colorToHex = function(e) {
    var t = e.r.toString(16),
        n = e.g.toString(16),
        r = e.b.toString(16);
    return "#" + (e.r < 16 ? "0" + t : t) + (e.g < 16 ? "0" + n : n) + (e.b < 16 ? "0" + r : r)
}, cc.TEXT_ALIGNMENT_LEFT = 0, cc.TEXT_ALIGNMENT_CENTER = 1, cc.TEXT_ALIGNMENT_RIGHT = 2, cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0, cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2, cc._Dictionary = cc.Class.extend({
    _keyMapTb: null,
    _valueMapTb: null,
    __currId: 0,
    ctor: function() {
        this._keyMapTb = {}, this._valueMapTb = {}, this.__currId = 2 << (0 | Math.random() * 10)
    },
    __getKey: function() {
        return this.__currId++, "key_" + this.__currId
    },
    setObject: function(e, t) {
        if (t == null)
            return;
        var n = this.__getKey();
        this._keyMapTb[n] = t, this._valueMapTb[n] = e
    },
    objectForKey: function(e) {
        if (e == null)
            return null;
        var t = this._keyMapTb;
        for (var n in t)
            if (t[n] === e)
                return this._valueMapTb[n];
        return null
    },
    valueForKey: function(e) {
        return this.objectForKey(e)
    },
    removeObjectForKey: function(e) {
        if (e == null)
            return;
        var t = this._keyMapTb;
        for (var n in t)
            if (t[n] === e) {
                delete this._valueMapTb[n], delete t[n];
                return
            }
    },
    removeObjectsForKeys: function(e) {
        if (e == null)
            return;
        for (var t = 0; t < e.length; t++)
            this.removeObjectForKey(e[t])
    },
    allKeys: function() {
        var e = [],
            t = this._keyMapTb;
        for (var n in t)
            e.push(t[n]);
        return e
    },
    removeAllObjects: function() {
        this._keyMapTb = {}, this._valueMapTb = {}
    },
    count: function() {
        return this.allKeys().length
    }
}), cc.FontDefinition = function() {
    var e = this;
    e.fontName = "Arial", e.fontSize = 12, e.textAlign = cc.TEXT_ALIGNMENT_CENTER, e.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP, e.fillStyle = cc.color(255, 255, 255, 255), e.boundingWidth = 0, e.boundingHeight = 0, e.strokeEnabled = !1, e.strokeStyle = cc.color(255, 255, 255, 255), e.lineWidth = 1, e.shadowEnabled = !1, e.shadowOffsetX = 0, e.shadowOffsetY = 0, e.shadowBlur = 0, e.shadowOpacity = 1
}, cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLColor), cc._LogInfos.MissingFile, "CCTypesWebGL.js"), cc._tmp.WebGLColor(), delete cc._tmp.WebGLColor), cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js"), cc._tmp.PrototypeColor(), delete cc._tmp.PrototypeColor, cc.Touches = [], cc.TouchesIntergerDict = {}, cc.DENSITYDPI_DEVICE = "device-dpi", cc.DENSITYDPI_HIGH = "high-dpi", cc.DENSITYDPI_MEDIUM = "medium-dpi", cc.DENSITYDPI_LOW = "low-dpi", cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
    _retinaEnabled: !1,
    _autoFullScreen: !0,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: !1,
    _captured: !1,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: !1,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1,
    __resizeWithBrowserSize: !1,
    _isAdjustViewPort: !0,
    _targetDensityDPI: null,
    ctor: function() {
        var e = this,
            t = document,
            n = cc.ContainerStrategy,
            r = cc.ContentStrategy;
        e._frame = cc.container.parentNode === t.body ? t.documentElement : cc.container.parentNode, e._frameSize = cc.size(0, 0), e._initFrameSize();
        var i = cc._canvas.width,
            s = cc._canvas.height;
        e._designResolutionSize = cc.size(i, s), e._originalDesignResolutionSize = cc.size(i, s), e._viewPortRect = cc.rect(0, 0, i, s), e._visibleRect = cc.rect(0, 0, i, s), e._contentTranslateLeftTop = {
            left: 0,
            top: 0
        }, e._viewName = "Cocos2dHTML5";
        var o = cc.sys;
        e.enableRetina(o.os == o.OS_IOS || o.os == o.OS_OSX), cc.visibleRect && cc.visibleRect.init(e._visibleRect), e._rpExactFit = new cc.ResolutionPolicy(n.EQUAL_TO_FRAME, r.EXACT_FIT), e._rpShowAll = new cc.ResolutionPolicy(n.PROPORTION_TO_FRAME, r.SHOW_ALL), e._rpNoBorder = new cc.ResolutionPolicy(n.EQUAL_TO_FRAME, r.NO_BORDER), e._rpFixedHeight = new cc.ResolutionPolicy(n.EQUAL_TO_FRAME, r.FIXED_HEIGHT), e._rpFixedWidth = new cc.ResolutionPolicy(n.EQUAL_TO_FRAME, r.FIXED_WIDTH), e._hDC = cc._canvas, e._hRC = cc._renderContext, e._targetDensityDPI = cc.DENSITYDPI_HIGH
    },
    _resizeEvent: function() {
        var e = this._originalDesignResolutionSize.width,
            t = this._originalDesignResolutionSize.height;
        this._resizeCallback && (this._initFrameSize(), this._resizeCallback.call()), e > 0 && this.setDesignResolutionSize(e, t, this._resolutionPolicy)
    },
    setTargetDensityDPI: function(e) {
        this._targetDensityDPI = e, this._setViewPortMeta()
    },
    getTargetDensityDPI: function() {
        return this._targetDensityDPI
    },
    resizeWithBrowserSize: function(e) {
        var t, n = this;
        e ? n.__resizeWithBrowserSize || (n.__resizeWithBrowserSize = !0, t = n._resizeEvent.bind(n), cc._addEventListener(window, "resize", t, !1)) : n.__resizeWithBrowserSize && (n.__resizeWithBrowserSize = !0, t = n._resizeEvent.bind(n), window.removeEventListener("resize", t, !1))
    },
    setResizeCallback: function(e) {
        if (cc.isFunction(e) || e == null)
            this._resizeCallback = e
    },
    _initFrameSize: function() {
        var e = this._frameSize,
            t = Math.min(window.screen.availWidth, window.screen.width) * window.devicePixelRatio,
            n = Math.min(window.screen.availHeight, window.screen.height) * window.devicePixelRatio;
        cc.sys.isMobile && this._frame.clientWidth >= t * .8 ? e.width = t / window.devicePixelRatio : e.width = this._frame.clientWidth, cc.sys.isMobile && this._frame.clientWidth >= n * .8 ? e.height = n / window.devicePixelRatio : e.height = this._frame.clientHeight
    },
    _adjustSizeKeepCanvasSize: function() {
        var e = this._originalDesignResolutionSize.width,
            t = this._originalDesignResolutionSize.height;
        e > 0 && this.setDesignResolutionSize(e, t, this._resolutionPolicy)
    },
    _setViewPortMeta: function(e, t) {
        if (this._isAdjustViewPort) {
            var n = document.getElementById("cocosMetaElement");
            n && document.head.removeChild(n);
            var r, i = document.getElementsByName("viewport"),
                s;
            n = cc.newElement("meta"), n.id = "cocosMetaElement", n.name = "viewport", n.content = "", cc.sys.isMobile && cc.sys.browserType == cc.sys.BROWSER_TYPE_FIREFOX ? r = {
                width: "device-width",
                "initial-scale": "1.0"
            } : r = {
                width: "device-width",
                "user-scalable": "no",
                "maximum-scale": "1.0",
                "initial-scale": "1.0"
            }, cc.sys.isMobile && (r["target-densitydpi"] = this._targetDensityDPI), s = i && i.length > 0 ? i[0].content : "";
            for (var o in r) {
                var u = new RegExp(o);
                u.test(s) || (s += "," + o + "=" + r[o])
            }!i && s != "" && (s = s.substr(1)), n.content = s, document.head.appendChild(n)
        }
    },
    _setScaleXYForRenderTexture: function() {
        var e = cc.contentScaleFactor();
        this._scaleX = e, this._scaleY = e
    },
    _resetScale: function() {
        this._scaleX = this._originalScaleX, this._scaleY = this._originalScaleY
    },
    _adjustSizeToBrowser: function() {},
    initialize: function() {
        this._initialized = !0
    },
    adjustViewPort: function(e) {
        this._isAdjustViewPort = e
    },
    enableRetina: function(e) {
        this._retinaEnabled = e ? !0 : !1
    },
    isRetinaEnabled: function() {
        return this._retinaEnabled
    },
    enableAutoFullScreen: function(e) {
        this._autoFullScreen = e ? !0 : !1
    },
    isAutoFullScreenEnabled: function() {
        return this._autoFullScreen
    },
    end: function() {},
    isOpenGLReady: function() {
        return this._hDC != null && this._hRC != null
    },
    setFrameZoomFactor: function(e) {
        this._frameZoomFactor = e, this.centerWindow(), cc.director.setProjection(cc.director.getProjection())
    },
    swapBuffers: function() {},
    setIMEKeyboardState: function(e) {},
    setContentTranslateLeftTop: function(e, t) {
        this._contentTranslateLeftTop = {
            left: e,
            top: t
        }
    },
    getContentTranslateLeftTop: function() {
        return this._contentTranslateLeftTop
    },
    getFrameSize: function() {
        return cc.size(this._frameSize.width, this._frameSize.height)
    },
    setFrameSize: function(e, t) {
        this._frameSize.width = e, this._frameSize.height = t, this._frame.style.width = e + "px", this._frame.style.height = t + "px", this._resizeEvent(), cc.director.setProjection(cc.director.getProjection())
    },
    centerWindow: function() {},
    getVisibleSize: function() {
        return cc.size(this._visibleRect.width, this._visibleRect.height)
    },
    getVisibleOrigin: function() {
        return cc.p(this._visibleRect.x, this._visibleRect.y)
    },
    canSetContentScaleFactor: function() {
        return !0
    },
    getResolutionPolicy: function() {
        return this._resolutionPolicy
    },
    setResolutionPolicy: function(e) {
        var t = this;
        if (e instanceof cc.ResolutionPolicy)
            t._resolutionPolicy = e;
        else {
            var n = cc.ResolutionPolicy;
            e === n.EXACT_FIT && (t._resolutionPolicy = t._rpExactFit), e === n.SHOW_ALL && (t._resolutionPolicy = t._rpShowAll), e === n.NO_BORDER && (t._resolutionPolicy = t._rpNoBorder), e === n.FIXED_HEIGHT && (t._resolutionPolicy = t._rpFixedHeight), e === n.FIXED_WIDTH && (t._resolutionPolicy = t._rpFixedWidth)
        }
    },
    setDesignResolutionSize: function(e, t, n) {
        if (isNaN(e) || e == 0 || isNaN(t) || t == 0) {
            cc.log(cc._LogInfos.EGLView_setDesignResolutionSize);
            return
        }
        var r = this,
            i = r._resolutionPolicy;
        r.setResolutionPolicy(n);
        var s = r._resolutionPolicy;
        if (!s) {
            cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2);
            return
        }
        s.preApply(r);
        var o = r._frameSize.width,
            u = r._frameSize.height;
        cc.sys.isMobile && r._setViewPortMeta(r._frameSize.width, r._frameSize.height), r._initFrameSize();
        if (i == r._resolutionPolicy && e == r._originalDesignResolutionSize.width && t == r._originalDesignResolutionSize.height && o == r._frameSize.width && u == r._frameSize.height)
            return;
        r._designResolutionSize = cc.size(e, t), r._originalDesignResolutionSize = cc.size(e, t);
        var a = s.apply(r, r._designResolutionSize);
        a.scale && a.scale.length == 2 && (r._scaleX = a.scale[0], r._scaleY = a.scale[1]);
        if (a.viewport) {
            var f = r._viewPortRect = a.viewport,
                l = r._visibleRect;
            l.width = cc._canvas.width / r._scaleX, l.height = cc._canvas.height / r._scaleY, l.x = -f.x / r._scaleX, l.y = -f.y / r._scaleY
        }
        var c = cc.director;
        c._winSizeInPoints.width = r._designResolutionSize.width, c._winSizeInPoints.height = r._designResolutionSize.height, cc.winSize.width = c._winSizeInPoints.width, cc.winSize.height = c._winSizeInPoints.height, s.postApply(r), cc._renderType == cc._RENDER_TYPE_WEBGL && (c._createStatsLabel(), c.setGLDefaultValues()), r._originalScaleX = r._scaleX, r._originalScaleY = r._scaleY, cc.DOM && cc.DOM._resetEGLViewDiv(), cc.visibleRect && cc.visibleRect.init(r._visibleRect)
    },
    getDesignResolutionSize: function() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
    },
    setViewPortInPoints: function(e, t, n, r) {
        var i = this._frameZoomFactor,
            s = this._scaleX,
            o = this._scaleY;
        cc._renderContext.viewport(e * s * i + this._viewPortRect.x * i, t * o * i + this._viewPortRect.y * i, n * s * i, r * o * i)
    },
    setScissorInPoints: function(e, t, n, r) {
        var i = this._frameZoomFactor,
            s = this._scaleX,
            o = this._scaleY;
        cc._renderContext.scissor(e * s * i + this._viewPortRect.x * i, t * o * i + this._viewPortRect.y * i, n * s * i, r * o * i)
    },
    isScissorEnabled: function() {
        var e = cc._renderContext;
        return e.isEnabled(e.SCISSOR_TEST)
    },
    getScissorRect: function() {
        var e = cc._renderContext,
            t = this._scaleX,
            n = this._scaleY,
            r = e.getParameter(e.SCISSOR_BOX);
        return cc.rect((r[0] - this._viewPortRect.x) / t, (r[1] - this._viewPortRect.y) / n, r[2] / t, r[3] / n)
    },
    setViewName: function(e) {
        e != null && e.length > 0 && (this._viewName = e)
    },
    getViewName: function() {
        return this._viewName
    },
    getViewPortRect: function() {
        return this._viewPortRect
    },
    getScaleX: function() {
        return this._scaleX
    },
    getScaleY: function() {
        return this._scaleY
    },
    getDevicePixelRatio: function() {
        return this._devicePixelRatio
    },
    convertToLocationInView: function(e, t, n) {
        return {
            x: this._devicePixelRatio * (e - n.left),
            y: this._devicePixelRatio * (n.top + n.height - t)
        }
    },
    _convertMouseToLocationInView: function(e, t) {
        var n = this._viewPortRect,
            r = this;
        e.x = (r._devicePixelRatio * (e.x - t.left) - n.x) / r._scaleX, e.y = (r._devicePixelRatio * (t.top + t.height - e.y) - n.y) / r._scaleY
    },
    _convertTouchesWithScale: function(e) {
        var t = this._viewPortRect,
            n = this._scaleX,
            r = this._scaleY,
            i, s, o;
        for (var u = 0; u < e.length; u++)
            i = e[u], s = i._point, o = i._prevPoint, i._setPoint((s.x - t.x) / n, (s.y - t.y) / r), i._setPrevPoint((o.x - t.x) / n, (o.y - t.y) / r)
    }
}), cc.EGLView._getInstance = function() {
    return this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize()), this._instance
}, cc.ContainerStrategy = cc.Class.extend({
    preApply: function(e) {},
    apply: function(e, t) {},
    postApply: function(e) {},
    _setupContainer: function(e, t, n) {
        var r = e._frame;
        cc.view._autoFullScreen && cc.sys.isMobile && r == document.documentElement && cc.screen.autoFullScreen(r);
        var i = cc._canvas,
            s = cc.container;
        s.style.width = i.style.width = t + "px", s.style.height = i.style.height = n + "px";
        var o = e._devicePixelRatio = 1;
        e.isRetinaEnabled() && (o = e._devicePixelRatio = window.devicePixelRatio || 1), i.width = t * o, i.height = n * o;
        var u = document.body,
            a;
        u && (a = u.style) && (a.paddingTop = a.paddingTop || "0px", a.paddingRight = a.paddingRight || "0px", a.paddingBottom = a.paddingBottom || "0px", a.paddingLeft = a.paddingLeft || "0px", a.borderTop = a.borderTop || "0px", a.borderRight = a.borderRight || "0px", a.borderBottom = a.borderBottom || "0px", a.borderLeft = a.borderLeft || "0px", a.marginTop = a.marginTop || "0px", a.marginRight = a.marginRight || "0px", a.marginBottom = a.marginBottom || "0px", a.marginLeft = a.marginLeft || "0px")
    },
    _fixContainer: function() {
        document.body.insertBefore(cc.container, document.body.firstChild);
        var e = document.body.style;
        e.width = window.innerWidth + "px", e.height = window.innerHeight + "px", e.overflow = "hidden";
        var t = cc.container.style;
        t.position = "fixed", t.left = t.top = "0px", document.body.scrollTop = 0
    }
}), cc.ContentStrategy = cc.Class.extend({
    _result: {
        scale: [1, 1],
        viewport: null
    },
    _buildResult: function(e, t, n, r, i, s) {
        Math.abs(e - n) < 2 && (n = e), Math.abs(t - r) < 2 && (r = t);
        var o = cc.rect(Math.round((e - n) / 2), Math.round((t - r) / 2), n, r);
        return cc._renderType == cc._RENDER_TYPE_CANVAS && cc._renderContext.translate(o.x, o.y + r), this._result.scale = [i, s], this._result.viewport = o, this._result
    },
    preApply: function(e) {},
    apply: function(e, t) {
        return {
            scale: [1, 1]
        }
    },
    postApply: function(e) {}
}),
function() {
    var e = cc.ContainerStrategy.extend({
            apply: function(e) {
                this._setupContainer(e, e._frameSize.width, e._frameSize.height)
            }
        }),
        t = cc.ContainerStrategy.extend({
            apply: function(e, t) {
                var n = e._frameSize.width,
                    r = e._frameSize.height,
                    i = cc.container.style,
                    s = t.width,
                    o = t.height,
                    u = n / s,
                    a = r / o,
                    f, l;
                u < a ? (f = n, l = o * u) : (f = s * a, l = r);
                var c = Math.round((n - f) / 2),
                    h = Math.round((r - l) / 2);
                f = n - 2 * c, l = r - 2 * h, this._setupContainer(e, f, l), i.marginLeft = c + "px", i.marginRight = c + "px", i.marginTop = h + "px", i.marginBottom = h + "px"
            }
        }),
        n = e.extend({
            preApply: function(e) {
                this._super(e), e._frame = document.documentElement
            },
            apply: function(e) {
                this._super(e), this._fixContainer()
            }
        }),
        r = t.extend({
            preApply: function(e) {
                this._super(e), e._frame = document.documentElement
            },
            apply: function(e, t) {
                this._super(e, t), this._fixContainer()
            }
        }),
        i = cc.ContainerStrategy.extend({
            apply: function(e) {
                this._setupContainer(e, cc._canvas.width, cc._canvas.height)
            }
        });
    cc.ContainerStrategy.EQUAL_TO_FRAME = new e, cc.ContainerStrategy.PROPORTION_TO_FRAME = new t, cc.ContainerStrategy.ORIGINAL_CONTAINER = new i;
    var s = cc.ContentStrategy.extend({
            apply: function(e, t) {
                var n = cc._canvas.width,
                    r = cc._canvas.height,
                    i = n / t.width,
                    s = r / t.height;
                return this._buildResult(n, r, n, r, i, s)
            }
        }),
        o = cc.ContentStrategy.extend({
            apply: function(e, t) {
                var n = cc._canvas.width,
                    r = cc._canvas.height,
                    i = t.width,
                    s = t.height,
                    o = n / i,
                    u = r / s,
                    a = 0,
                    f, l;
                return o < u ? (a = o, f = n, l = s * a) : (a = u, f = i * a, l = r), this._buildResult(n, r, f, l, a, a)
            }
        }),
        u = cc.ContentStrategy.extend({
            apply: function(e, t) {
                var n = cc._canvas.width,
                    r = cc._canvas.height,
                    i = t.width,
                    s = t.height,
                    o = n / i,
                    u = r / s,
                    a;
                return o < u ? a = u : a = o, this._buildResult(n, r, n, r, a, a)
            }
        }),
        a = cc.ContentStrategy.extend({
            apply: function(e, t) {
                var n = cc._canvas.width,
                    r = cc._canvas.height,
                    i = t.height,
                    s = r / i,
                    o = n,
                    u = r;
                return this._buildResult(n, r, o, u, s, s)
            },
            postApply: function(e) {
                cc.director._winSizeInPoints = e.getVisibleSize()
            }
        }),
        f = cc.ContentStrategy.extend({
            apply: function(e, t) {
                var n = cc._canvas.width,
                    r = cc._canvas.height,
                    i = t.width,
                    s = n / i,
                    o = n,
                    u = r;
                return this._buildResult(n, r, o, u, s, s)
            },
            postApply: function(e) {
                cc.director._winSizeInPoints = e.getVisibleSize()
            }
        });
    cc.ContentStrategy.EXACT_FIT = new s, cc.ContentStrategy.SHOW_ALL = new o, cc.ContentStrategy.NO_BORDER = new u, cc.ContentStrategy.FIXED_HEIGHT = new a, cc.ContentStrategy.FIXED_WIDTH = new f
}(), cc.ResolutionPolicy = cc.Class.extend({
    _containerStrategy: null,
    _contentStrategy: null,
    ctor: function(e, t) {
        this.setContainerStrategy(e), this.setContentStrategy(t)
    },
    preApply: function(e) {
        this._containerStrategy.preApply(e), this._contentStrategy.preApply(e)
    },
    apply: function(e, t) {
        return this._containerStrategy.apply(e, t), this._contentStrategy.apply(e, t)
    },
    postApply: function(e) {
        this._containerStrategy.postApply(e), this._contentStrategy.postApply(e)
    },
    setContainerStrategy: function(e) {
        e instanceof cc.ContainerStrategy && (this._containerStrategy = e)
    },
    setContentStrategy: function(e) {
        e instanceof cc.ContentStrategy && (this._contentStrategy = e)
    }
}), cc.ResolutionPolicy.EXACT_FIT = 0, cc.ResolutionPolicy.NO_BORDER = 1, cc.ResolutionPolicy.SHOW_ALL = 2, cc.ResolutionPolicy.FIXED_HEIGHT = 3, cc.ResolutionPolicy.FIXED_WIDTH = 4, cc.ResolutionPolicy.UNKNOWN = 5, cc.screen = {
    _supportsFullScreen: !1,
    _preOnFullScreenChange: null,
    _touchEvent: "",
    _fn: null,
    _fnMap: [
        ["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"],
        ["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"],
        ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"],
        ["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement"],
        ["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]
    ],
    init: function() {
        this._fn = {};
        var e, t, n = this._fnMap,
            r;
        for (e = 0, l = n.length; e < l; e++) {
            t = n[e];
            if (t && t[1] in document) {
                for (e = 0, r = t.length; e < r; e++)
                    this._fn[n[0][e]] = t[e];
                break
            }
        }
        this._supportsFullScreen = this._fn.requestFullscreen != undefined, this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown"
    },
    fullScreen: function() {
        return this._supportsFullScreen && document[this._fn.fullscreenEnabled]
    },
    requestFullScreen: function(e, t) {
        if (!this._supportsFullScreen)
            return;
        e = e || document.documentElement, e[this._fn.requestFullscreen]();
        if (t) {
            var n = this._fn.fullscreenchange;
            this._preOnFullScreenChange && document.removeEventListener(n, this._preOnFullScreenChange), this._preOnFullScreenChange = t, cc._addEventListener(document, n, t, !1)
        }
        return e[this._fn.requestFullscreen]()
    },
    exitFullScreen: function() {
        return this._supportsFullScreen ? document[this._fn.exitFullscreen]() : !0
    },
    autoFullScreen: function(e, t) {
        function i() {
            r.requestFullScreen(e, t), n.removeEventListener(r._touchEvent, i)
        }
        e = e || document.body;
        var n = cc._canvas || e,
            r = this;
        this.requestFullScreen(e, t), cc._addEventListener(n, this._touchEvent, i)
    }
}, cc.screen.init(), cc.visibleRect = {
    topLeft: cc.p(0, 0),
    topRight: cc.p(0, 0),
    top: cc.p(0, 0),
    bottomLeft: cc.p(0, 0),
    bottomRight: cc.p(0, 0),
    bottom: cc.p(0, 0),
    center: cc.p(0, 0),
    left: cc.p(0, 0),
    right: cc.p(0, 0),
    width: 0,
    height: 0,
    init: function(e) {
        var t = this.width = e.width,
            n = this.height = e.height,
            r = e.x,
            i = e.y,
            s = i + n,
            o = r + t;
        this.topLeft.x = r, this.topLeft.y = s, this.topRight.x = o, this.topRight.y = s, this.top.x = r + t / 2, this.top.y = s, this.bottomLeft.x = r, this.bottomLeft.y = i, this.bottomRight.x = o, this.bottomRight.y = i, this.bottom.x = r + t / 2, this.bottom.y = i, this.center.x = r + t / 2, this.center.y = i + n / 2, this.left.x = r, this.left.y = i + n / 2, this.right.x = o, this.right.y = i + n / 2
    }
}, cc.UIInterfaceOrientationLandscapeLeft = -90, cc.UIInterfaceOrientationLandscapeRight = 90, cc.UIInterfaceOrientationPortraitUpsideDown = 180, cc.UIInterfaceOrientationPortrait = 0, cc.inputManager = {
    _mousePressed: !1,
    _isRegisterEvent: !1,
    _preTouchPoint: cc.p(0, 0),
    _prevMousePoint: cc.p(0, 0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict: {},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: !1,
    _accelInterval: 1 / 30,
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    _getUnUsedIndex: function() {
        var e = this._indexBitsUsed;
        for (var t = 0; t < this._maxTouches; t++) {
            if (!(e & 1))
                return this._indexBitsUsed |= 1 << t, t;
            e >>= 1
        }
        return -1
    },
    _removeUsedIndexBit: function(e) {
        if (e < 0 || e >= this._maxTouches)
            return;
        var t = 1 << e;
        t = ~t, this._indexBitsUsed &= t
    },
    _glView: null,
    handleTouchesBegin: function(e) {
        var t, n, r, i, s = [],
            o = this._touchesIntegerDict;
        for (var u = 0, a = e.length; u < a; u++) {
            t = e[u], i = t.getID(), n = o[i];
            if (n == null) {
                var f = this._getUnUsedIndex();
                if (f == -1) {
                    cc.log(cc._LogInfos.inputManager_handleTouchesBegin, f);
                    continue
                }
                r = this._touches[f] = new cc.Touch(t._point.x, t._point.y, t.getID()), r._setPrevPoint(t._prevPoint), o[i] = f, s.push(r)
            }
        }
        if (s.length > 0) {
            this._glView._convertTouchesWithScale(s);
            var l = new cc.EventTouch(s);
            l._eventCode = cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(l)
        }
    },
    handleTouchesMove: function(e) {
        var t, n, r, i = [],
            s = this._touches;
        for (var o = 0, u = e.length; o < u; o++) {
            t = e[o], r = t.getID(), n = this._touchesIntegerDict[r];
            if (n == null)
                continue;
            s[n] && (s[n]._setPoint(t._point), s[n]._setPrevPoint(t._prevPoint), i.push(s[n]))
        }
        if (i.length > 0) {
            this._glView._convertTouchesWithScale(i);
            var a = new cc.EventTouch(i);
            a._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(a)
        }
    },
    handleTouchesEnd: function(e) {
        var t = this.getSetOfTouchesEndOrCancel(e);
        if (t.length > 0) {
            this._glView._convertTouchesWithScale(t);
            var n = new cc.EventTouch(t);
            n._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(n)
        }
    },
    handleTouchesCancel: function(e) {
        var t = this.getSetOfTouchesEndOrCancel(e);
        if (t.length > 0) {
            this._glView._convertTouchesWithScale(t);
            var n = new cc.EventTouch(t);
            n._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(n)
        }
    },
    getSetOfTouchesEndOrCancel: function(e) {
        var t, n, r, i = [],
            s = this._touches,
            o = this._touchesIntegerDict;
        for (var u = 0, a = e.length; u < a; u++) {
            t = e[u], r = t.getID(), n = o[r];
            if (n == null)
                continue;
            s[n] && (s[n]._setPoint(t._point), s[n]._setPrevPoint(t._prevPoint), i.push(s[n]), this._removeUsedIndexBit(n), delete o[r])
        }
        return i
    },
    getHTMLElementPosition: function(e) {
        var t = document.documentElement,
            n = window,
            r = null;
        return cc.isFunction(e.getBoundingClientRect) ? r = e.getBoundingClientRect() : e instanceof HTMLCanvasElement ? r = {
            left: 0,
            top: 0,
            width: e.width,
            height: e.height
        } : r = {
            left: 0,
            top: 0,
            width: parseInt(e.style.width),
            height: parseInt(e.style.height)
        }, {
            left: r.left + n.pageXOffset - t.clientLeft,
            top: r.top + n.pageYOffset - t.clientTop,
            width: r.width,
            height: r.height
        }
    },
    getPreTouch: function(e) {
        var t = null,
            n = this._preTouchPool,
            r = e.getID();
        for (var i = n.length - 1; i >= 0; i--)
            if (n[i].getID() == r) {
                t = n[i];
                break
            }
        return t || (t = e), t
    },
    setPreTouch: function(e) {
        var t = !1,
            n = this._preTouchPool,
            r = e.getID();
        for (var i = n.length - 1; i >= 0; i--)
            if (n[i].getID() == r) {
                n[i] = e, t = !0;
                break
            }
        t || (n.length <= 50 ? n.push(e) : (n[this._preTouchPoolPointer] = e, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
    },
    getTouchByXY: function(e, t, n) {
        var r = this._preTouchPoint,
            i = this._glView.convertToLocationInView(e, t, n),
            s = new cc.Touch(i.x, i.y);
        return s._setPrevPoint(r.x, r.y), r.x = i.x, r.y = i.y, s
    },
    getMouseEvent: function(e, t, n) {
        var r = this._prevMousePoint;
        this._glView._convertMouseToLocationInView(e, t);
        var i = new cc.EventMouse(n);
        return i.setLocation(e.x, e.y), i._setPrevCursor(r.x, r.y), r.x = e.x, r.y = e.y, i
    },
    getPointByEvent: function(e, t) {
        return e.pageX != null ? {
            x: e.pageX,
            y: e.pageY
        } : (t.left -= document.body.scrollLeft, t.top -= document.body.scrollTop, {
            x: e.clientX,
            y: e.clientY
        })
    },
    getTouchesByEvent: function(e, t) {
        var n = [],
            r = this._glView,
            i, s, o, u = this._preTouchPoint,
            a = e.changedTouches.length;
        for (var f = 0; f < a; f++) {
            i = e.changedTouches[f];
            if (i) {
                var l;
                cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? l = r.convertToLocationInView(i.pageX, i.pageY, t) : l = r.convertToLocationInView(i.clientX, i.clientY, t), i.identifier != null ? (s = new cc.Touch(l.x, l.y, i.identifier), o = this.getPreTouch(s).getLocation(), s._setPrevPoint(o.x, o.y), this.setPreTouch(s)) : (s = new cc.Touch(l.x, l.y), s._setPrevPoint(u.x, u.y)), u.x = l.x, u.y = l.y, n.push(s)
            }
        }
        return n
    },
    registerSystemEvent: function(e) {
        if (this._isRegisterEvent)
            return;
        var t = this._glView = cc.view,
            n = this,
            r = "mouse" in cc.sys.capabilities,
            i = "touches" in cc.sys.capabilities;
        r && (cc._addEventListener(window, "mousedown", function() {
            n._mousePressed = !0
        }, !1), cc._addEventListener(window, "mouseup", function(t) {
            var r = n._mousePressed;
            n._mousePressed = !1;
            if (!r)
                return;
            var s = n.getHTMLElementPosition(e),
                o = n.getPointByEvent(t, s);
            if (!cc.rectContainsPoint(new cc.Rect(s.left, s.top, s.width, s.height), o)) {
                i || n.handleTouchesEnd([n.getTouchByXY(o.x, o.y, s)]);
                var u = n.getMouseEvent(o, s, cc.EventMouse.UP);
                u.setButton(t.button), cc.eventManager.dispatchEvent(u)
            }
        }, !1), cc._addEventListener(e, "mousedown", function(t) {
            n._mousePressed = !0;
            var r = n.getHTMLElementPosition(e),
                s = n.getPointByEvent(t, r);
            i || n.handleTouchesBegin([n.getTouchByXY(s.x, s.y, r)]);
            var o = n.getMouseEvent(s, r, cc.EventMouse.DOWN);
            o.setButton(t.button), cc.eventManager.dispatchEvent(o), t.stopPropagation(), t.preventDefault(), e.focus()
        }, !1), cc._addEventListener(e, "mouseup", function(t) {
            n._mousePressed = !1;
            var r = n.getHTMLElementPosition(e),
                s = n.getPointByEvent(t, r);
            i || n.handleTouchesEnd([n.getTouchByXY(s.x, s.y, r)]);
            var o = n.getMouseEvent(s, r, cc.EventMouse.UP);
            o.setButton(t.button), cc.eventManager.dispatchEvent(o), t.stopPropagation(), t.preventDefault()
        }, !1), cc._addEventListener(e, "mousemove", function(t) {
            var r = n.getHTMLElementPosition(e),
                s = n.getPointByEvent(t, r);
            i || n.handleTouchesMove([n.getTouchByXY(s.x, s.y, r)]);
            var o = n.getMouseEvent(s, r, cc.EventMouse.MOVE);
            n._mousePressed ? o.setButton(t.button) : o.setButton(null), cc.eventManager.dispatchEvent(o), t.stopPropagation(), t.preventDefault()
        }, !1), cc._addEventListener(e, "mousewheel", function(t) {
            var r = n.getHTMLElementPosition(e),
                i = n.getPointByEvent(t, r),
                s = n.getMouseEvent(i, r, cc.EventMouse.SCROLL);
            s.setButton(t.button), s.setScrollData(0, t.wheelDelta), cc.eventManager.dispatchEvent(s), t.stopPropagation(), t.preventDefault()
        }, !1), cc._addEventListener(e, "DOMMouseScroll", function(t) {
            var r = n.getHTMLElementPosition(e),
                i = n.getPointByEvent(t, r),
                s = n.getMouseEvent(i, r, cc.EventMouse.SCROLL);
            s.setButton(t.button), s.setScrollData(0, t.detail * -120), cc.eventManager.dispatchEvent(s), t.stopPropagation(), t.preventDefault()
        }, !1));
        if (window.navigator.msPointerEnabled) {
            var s = {
                MSPointerDown: n.handleTouchesBegin,
                MSPointerMove: n.handleTouchesMove,
                MSPointerUp: n.handleTouchesEnd,
                MSPointerCancel: n.handleTouchesCancel
            };
            for (var o in s)
                (function(t, r) {
                    cc._addEventListener(e, t, function(t) {
                        var i = n.getHTMLElementPosition(e);
                        i.left -= document.documentElement.scrollLeft, i.top -= document.documentElement.scrollTop, r.call(n, [n.getTouchByXY(t.clientX, t.clientY, i)]), t.stopPropagation()
                    }, !1)
                })(o, s[o])
        }
        i && (cc._addEventListener(e, "touchstart", function(t) {
            if (!t.changedTouches)
                return;
            var r = n.getHTMLElementPosition(e);
            r.left -= document.body.scrollLeft, r.top -= document.body.scrollTop, n.handleTouchesBegin(n.getTouchesByEvent(t, r)), t.stopPropagation(), t.preventDefault(), e.focus()
        }, !1), cc._addEventListener(e, "touchmove", function(t) {
            if (!t.changedTouches)
                return;
            var r = n.getHTMLElementPosition(e);
            r.left -= document.body.scrollLeft, r.top -= document.body.scrollTop, n.handleTouchesMove(n.getTouchesByEvent(t, r)), t.stopPropagation(), t.preventDefault()
        }, !1), cc._addEventListener(e, "touchend", function(t) {
            if (!t.changedTouches)
                return;
            var r = n.getHTMLElementPosition(e);
            r.left -= document.body.scrollLeft, r.top -= document.body.scrollTop, n.handleTouchesEnd(n.getTouchesByEvent(t, r)), t.stopPropagation(), t.preventDefault()
        }, !1), cc._addEventListener(e, "touchcancel", function(r) {
            if (!r.changedTouches)
                return;
            var i = n.getHTMLElementPosition(e);
            i.left -= document.body.scrollLeft, i.top -= document.body.scrollTop, t.handleTouchesCancel(n.getTouchesByEvent(r, i)), r.stopPropagation(), r.preventDefault()
        }, !1)), this._registerKeyboardEvent(), this._registerAccelerometerEvent(), this._isRegisterEvent = !0
    },
    _registerKeyboardEvent: function() {},
    _registerAccelerometerEvent: function() {},
    update: function(e) {
        this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration))), this._accelCurTime += e
    }
}, cc.AffineTransform = function(e, t, n, r, i, s) {
    this.a = e, this.b = t, this.c = n, this.d = r, this.tx = i, this.ty = s
}, cc.affineTransformMake = function(e, t, n, r, i, s) {
    return {
        a: e,
        b: t,
        c: n,
        d: r,
        tx: i,
        ty: s
    }
}, cc.pointApplyAffineTransform = function(e, t) {
    return {
        x: t.a * e.x + t.c * e.y + t.tx,
        y: t.b * e.x + t.d * e.y + t.ty
    }
}, cc._pointApplyAffineTransform = function(e, t, n) {
    return {
        x: n.a * e + n.c * t + n.tx,
        y: n.b * e + n.d * t + n.ty
    }
}, cc.sizeApplyAffineTransform = function(e, t) {
    return {
        width: t.a * e.width + t.c * e.height,
        height: t.b * e.width + t.d * e.height
    }
}, cc.affineTransformMakeIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
}, cc.affineTransformIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
}, cc.rectApplyAffineTransform = function(e, t) {
    var n = cc.rectGetMinY(e),
        r = cc.rectGetMinX(e),
        i = cc.rectGetMaxX(e),
        s = cc.rectGetMaxY(e),
        o = cc._pointApplyAffineTransform(r, n, t),
        u = cc._pointApplyAffineTransform(i, n, t),
        a = cc._pointApplyAffineTransform(r, s, t),
        f = cc._pointApplyAffineTransform(i, s, t),
        l = Math.min(o.x, u.x, a.x, f.x),
        c = Math.max(o.x, u.x, a.x, f.x),
        h = Math.min(o.y, u.y, a.y, f.y),
        p = Math.max(o.y, u.y, a.y, f.y);
    return cc.rect(l, h, c - l, p - h)
}, cc._rectApplyAffineTransformIn = function(e, t) {
    var n = cc.rectGetMinY(e),
        r = cc.rectGetMinX(e),
        i = cc.rectGetMaxX(e),
        s = cc.rectGetMaxY(e),
        o = cc._pointApplyAffineTransform(r, n, t),
        u = cc._pointApplyAffineTransform(i, n, t),
        a = cc._pointApplyAffineTransform(r, s, t),
        f = cc._pointApplyAffineTransform(i, s, t),
        l = Math.min(o.x, u.x, a.x, f.x),
        c = Math.max(o.x, u.x, a.x, f.x),
        h = Math.min(o.y, u.y, a.y, f.y),
        p = Math.max(o.y, u.y, a.y, f.y);
    return e.x = l, e.y = h, e.width = c - l, e.height = p - h, e
}, cc.affineTransformTranslate = function(e, t, n) {
    return {
        a: e.a,
        b: e.b,
        c: e.c,
        d: e.d,
        tx: e.tx + e.a * t + e.c * n,
        ty: e.ty + e.b * t + e.d * n
    }
}, cc.affineTransformScale = function(e, t, n) {
    return {
        a: e.a * t,
        b: e.b * t,
        c: e.c * n,
        d: e.d * n,
        tx: e.tx,
        ty: e.ty
    }
}, cc.affineTransformRotate = function(e, t) {
    var n = Math.sin(t),
        r = Math.cos(t);
    return {
        a: e.a * r + e.c * n,
        b: e.b * r + e.d * n,
        c: e.c * r - e.a * n,
        d: e.d * r - e.b * n,
        tx: e.tx,
        ty: e.ty
    }
}, cc.affineTransformConcat = function(e, t) {
    return {
        a: e.a * t.a + e.b * t.c,
        b: e.a * t.b + e.b * t.d,
        c: e.c * t.a + e.d * t.c,
        d: e.c * t.b + e.d * t.d,
        tx: e.tx * t.a + e.ty * t.c + t.tx,
        ty: e.tx * t.b + e.ty * t.d + t.ty
    }
}, cc.affineTransformEqualToTransform = function(e, t) {
    return e.a === t.a && e.b === t.b && e.c === t.c && e.d === t.d && e.tx === t.tx && e.ty === t.ty
}, cc.affineTransformInvert = function(e) {
    var t = 1 / (e.a * e.d - e.b * e.c);
    return {
        a: t * e.d,
        b: -t * e.b,
        c: -t * e.c,
        d: t * e.a,
        tx: t * (e.c * e.ty - e.d * e.tx),
        ty: t * (e.b * e.tx - e.a * e.ty)
    }
}, cc.POINT_EPSILON = parseFloat("1.192092896e-07F"), cc.pNeg = function(e) {
    return cc.p(-e.x, -e.y)
}, cc.pAdd = function(e, t) {
    return cc.p(e.x + t.x, e.y + t.y)
}, cc.pSub = function(e, t) {
    return cc.p(e.x - t.x, e.y - t.y)
}, cc.pMult = function(e, t) {
    return cc.p(e.x * t, e.y * t)
}, cc.pMidpoint = function(e, t) {
    return cc.pMult(cc.pAdd(e, t), .5)
}, cc.pDot = function(e, t) {
    return e.x * t.x + e.y * t.y
}, cc.pCross = function(e, t) {
    return e.x * t.y - e.y * t.x
}, cc.pPerp = function(e) {
    return cc.p(-e.y, e.x)
}, cc.pRPerp = function(e) {
    return cc.p(e.y, -e.x)
}, cc.pProject = function(e, t) {
    return cc.pMult(t, cc.pDot(e, t) / cc.pDot(t, t))
}, cc.pRotate = function(e, t) {
    return cc.p(e.x * t.x - e.y * t.y, e.x * t.y + e.y * t.x)
}, cc.pUnrotate = function(e, t) {
    return cc.p(e.x * t.x + e.y * t.y, e.y * t.x - e.x * t.y)
}, cc.pLengthSQ = function(e) {
    return cc.pDot(e, e)
}, cc.pDistanceSQ = function(e, t) {
    return cc.pLengthSQ(cc.pSub(e, t))
}, cc.pLength = function(e) {
    return Math.sqrt(cc.pLengthSQ(e))
}, cc.pDistance = function(e, t) {
    return cc.pLength(cc.pSub(e, t))
}, cc.pNormalize = function(e) {
    return cc.pMult(e, 1 / cc.pLength(e))
}, cc.pForAngle = function(e) {
    return cc.p(Math.cos(e), Math.sin(e))
}, cc.pToAngle = function(e) {
    return Math.atan2(e.y, e.x)
}, cc.clampf = function(e, t, n) {
    if (t > n) {
        var r = t;
        t = n, n = r
    }
    return e < t ? t : e < n ? e : n
}, cc.pClamp = function(e, t, n) {
    return cc.p(cc.clampf(e.x, t.x, n.x), cc.clampf(e.y, t.y, n.y))
}, cc.pFromSize = function(e) {
    return cc.p(e.width, e.height)
}, cc.pCompOp = function(e, t) {
    return cc.p(t(e.x), t(e.y))
}, cc.pLerp = function(e, t, n) {
    return cc.pAdd(cc.pMult(e, 1 - n), cc.pMult(t, n))
}, cc.pFuzzyEqual = function(e, t, n) {
    return e.x - n <= t.x && t.x <= e.x + n && e.y - n <= t.y && t.y <= e.y + n ? !0 : !1
}, cc.pCompMult = function(e, t) {
    return cc.p(e.x * t.x, e.y * t.y)
}, cc.pAngleSigned = function(e, t) {
    var n = cc.pNormalize(e),
        r = cc.pNormalize(t),
        i = Math.atan2(n.x * r.y - n.y * r.x, cc.pDot(n, r));
    return Math.abs(i) < cc.POINT_EPSILON ? 0 : i
}, cc.pAngle = function(e, t) {
    var n = Math.acos(cc.pDot(cc.pNormalize(e), cc.pNormalize(t)));
    return Math.abs(n) < cc.POINT_EPSILON ? 0 : n
}, cc.pRotateByAngle = function(e, t, n) {
    var r = cc.pSub(e, t),
        i = Math.cos(n),
        s = Math.sin(n),
        o = r.x;
    return r.x = o * i - r.y * s + t.x, r.y = o * s + r.y * i + t.y, r
}, cc.pLineIntersect = function(e, t, n, r, i) {
    if (e.x == t.x && e.y == t.y || n.x == r.x && n.y == r.y)
        return !1;
    var s = t.x - e.x,
        o = t.y - e.y,
        u = r.x - n.x,
        a = r.y - n.y,
        f = e.x - n.x,
        l = e.y - n.y,
        c = a * s - u * o;
    return i.x = u * l - a * f, i.y = s * l - o * f, c == 0 ? i.x == 0 || i.y == 0 ? !0 : !1 : (i.x = i.x / c, i.y = i.y / c, !0)
}, cc.pSegmentIntersect = function(e, t, n, r) {
    var i = cc.p(0, 0);
    return cc.pLineIntersect(e, t, n, r, i) && i.x >= 0 && i.x <= 1 && i.y >= 0 && i.y <= 1 ? !0 : !1
}, cc.pIntersectPoint = function(e, t, n, r) {
    var i = cc.p(0, 0);
    if (cc.pLineIntersect(e, t, n, r, i)) {
        var s = cc.p(0, 0);
        return s.x = e.x + i.x * (t.x - e.x), s.y = e.y + i.x * (t.y - e.y), s
    }
    return cc.p(0, 0)
}, cc.pSameAs = function(e, t) {
    return e != null && t != null ? e.x == t.x && e.y == t.y : !1
}, cc.pZeroIn = function(e) {
    e.x = 0, e.y = 0
}, cc.pIn = function(e, t) {
    e.x = t.x, e.y = t.y
}, cc.pMultIn = function(e, t) {
    e.x *= t, e.y *= t
}, cc.pSubIn = function(e, t) {
    e.x -= t.x, e.y -= t.y
}, cc.pAddIn = function(e, t) {
    e.x += t.x, e.y += t.y
}, cc.pNormalizeIn = function(e) {
    cc.pMultIn(e, 1 / Math.sqrt(e.x * e.x + e.y * e.y))
}, cc.Touch = cc.Class.extend({
    _point: null,
    _prevPoint: null,
    _id: 0,
    _startPointCaptured: !1,
    _startPoint: null,
    ctor: function(e, t, n) {
        this._point = cc.p(e || 0, t || 0), this._id = n || 0
    },
    getLocation: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getLocationX: function() {
        return this._point.x
    },
    getLocationY: function() {
        return this._point.y
    },
    getPreviousLocation: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocation: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getDelta: function() {
        return cc.pSub(this._point, this._prevPoint)
    },
    getLocationInView: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getPreviousLocationInView: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocationInView: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getID: function() {
        return this._id
    },
    getId: function() {
        return cc.log("getId is deprecated. Please use getID instead."), this._id
    },
    setTouchInfo: function(e, t, n) {
        this._prevPoint = this._point, this._point = cc.p(t || 0, n || 0), this._id = e, this._startPointCaptured || (this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
    },
    _setPoint: function(e, t) {
        t === undefined ? (this._point.x = e.x, this._point.y = e.y) : (this._point.x = e, this._point.y = t)
    },
    _setPrevPoint: function(e, t) {
        t === undefined ? this._prevPoint = cc.p(e.x, e.y) : this._prevPoint = cc.p(e || 0, t || 0)
    }
}), cc.Event = cc.Class.extend({
    _type: 0,
    _isStopped: !1,
    _currentTarget: null,
    _setCurrentTarget: function(e) {
        this._currentTarget = e
    },
    ctor: function(e) {
        this._type = e
    },
    getType: function() {
        return this._type
    },
    stopPropagation: function() {
        this._isStopped = !0
    },
    isStopped: function() {
        return this._isStopped
    },
    getCurrentTarget: function() {
        return this._currentTarget
    }
}), cc.Event.TOUCH = 0, cc.Event.KEYBOARD = 1, cc.Event.ACCELERATION = 2, cc.Event.MOUSE = 3, cc.Event.CUSTOM = 4, cc.EventCustom = cc.Event.extend({
    _eventName: null,
    _userData: null,
    ctor: function(e) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM), this._eventName = e
    },
    setUserData: function(e) {
        this._userData = e
    },
    getUserData: function() {
        return this._userData
    },
    getEventName: function() {
        return this._eventName
    }
}), cc.EventMouse = cc.Event.extend({
    _eventType: 0,
    _button: 0,
    _x: 0,
    _y: 0,
    _prevX: 0,
    _prevY: 0,
    _scrollX: 0,
    _scrollY: 0,
    ctor: function(e) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE), this._eventType = e
    },
    setScrollData: function(e, t) {
        this._scrollX = e, this._scrollY = t
    },
    getScrollX: function() {
        return this._scrollX
    },
    getScrollY: function() {
        return this._scrollY
    },
    setLocation: function(e, t) {
        this._x = e, this._y = t
    },
    getLocation: function() {
        return {
            x: this._x,
            y: this._y
        }
    },
    getLocationInView: function() {
        return {
            x: this._x,
            y: cc.view._designResolutionSize.height - this._y
        }
    },
    _setPrevCursor: function(e, t) {
        this._prevX = e, this._prevY = t
    },
    getDelta: function() {
        return {
            x: this._x -
                this._prevX,
            y: this._y - this._prevY
        }
    },
    getDeltaX: function() {
        return this._x - this._prevX
    },
    getDeltaY: function() {
        return this._y - this._prevY
    },
    setButton: function(e) {
        this._button = e
    },
    getButton: function() {
        return this._button
    },
    getLocationX: function() {
        return this._x
    },
    getLocationY: function() {
        return this._y
    }
}), cc.EventMouse.NONE = 0, cc.EventMouse.DOWN = 1, cc.EventMouse.UP = 2, cc.EventMouse.MOVE = 3, cc.EventMouse.SCROLL = 4, cc.EventMouse.BUTTON_LEFT = 0, cc.EventMouse.BUTTON_RIGHT = 2, cc.EventMouse.BUTTON_MIDDLE = 1, cc.EventMouse.BUTTON_4 = 3, cc.EventMouse.BUTTON_5 = 4, cc.EventMouse.BUTTON_6 = 5, cc.EventMouse.BUTTON_7 = 6, cc.EventMouse.BUTTON_8 = 7, cc.EventTouch = cc.Event.extend({
    _eventCode: 0,
    _touches: null,
    ctor: function(e) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH), this._touches = e || []
    },
    getEventCode: function() {
        return this._eventCode
    },
    getTouches: function() {
        return this._touches
    },
    _setEventCode: function(e) {
        this._eventCode = e
    },
    _setTouches: function(e) {
        this._touches = e
    }
}), cc.EventTouch.MAX_TOUCHES = 5, cc.EventTouch.EventCode = {
    BEGAN: 0,
    MOVED: 1,
    ENDED: 2,
    CANCELLED: 3
}, cc.EventListener = cc.Class.extend({
    _onEvent: null,
    _type: 0,
    _listenerID: null,
    _registered: !1,
    _fixedPriority: 0,
    _node: null,
    _paused: !1,
    _isEnabled: !0,
    ctor: function(e, t, n) {
        this._onEvent = n, this._type = e || 0, this._listenerID = t || ""
    },
    _setPaused: function(e) {
        this._paused = e
    },
    _isPaused: function() {
        return this._paused
    },
    _setRegistered: function(e) {
        this._registered = e
    },
    _isRegistered: function() {
        return this._registered
    },
    _getType: function() {
        return this._type
    },
    _getListenerID: function() {
        return this._listenerID
    },
    _setFixedPriority: function(e) {
        this._fixedPriority = e
    },
    _getFixedPriority: function() {
        return this._fixedPriority
    },
    _setSceneGraphPriority: function(e) {
        this._node = e
    },
    _getSceneGraphPriority: function() {
        return this._node
    },
    checkAvailable: function() {
        return this._onEvent != null
    },
    clone: function() {
        return null
    },
    setEnabled: function(e) {
        this._isEnabled = e
    },
    isEnabled: function() {
        return this._isEnabled
    },
    retain: function() {},
    release: function() {}
}), cc.EventListener.UNKNOWN = 0, cc.EventListener.TOUCH_ONE_BY_ONE = 1, cc.EventListener.TOUCH_ALL_AT_ONCE = 2, cc.EventListener.KEYBOARD = 3, cc.EventListener.MOUSE = 4, cc.EventListener.ACCELERATION = 5, cc.EventListener.CUSTOM = 6, cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: null,
    ctor: function(e, t) {
        this._onCustomEvent = t;
        var n = this,
            r = function(e) {
                n._onCustomEvent != null && n._onCustomEvent(e)
            };
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, e, r)
    },
    checkAvailable: function() {
        return cc.EventListener.prototype.checkAvailable.call(this) && this._onCustomEvent != null
    },
    clone: function() {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
    }
}), cc._EventListenerCustom.create = function(e, t) {
    return new cc._EventListenerCustom(e, t)
}, cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: null,
    onMouseUp: null,
    onMouseMove: null,
    onMouseScroll: null,
    ctor: function() {
        var e = this,
            t = function(t) {
                var n = cc.EventMouse;
                switch (t._eventType) {
                    case n.DOWN:
                        e.onMouseDown && e.onMouseDown(t);
                        break;
                    case n.UP:
                        e.onMouseUp && e.onMouseUp(t);
                        break;
                    case n.MOVE:
                        e.onMouseMove && e.onMouseMove(t);
                        break;
                    case n.SCROLL:
                        e.onMouseScroll && e.onMouseScroll(t);
                        break;
                    default:
                }
            };
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, t)
    },
    clone: function() {
        var e = new cc._EventListenerMouse;
        return e.onMouseDown = this.onMouseDown, e.onMouseUp = this.onMouseUp, e.onMouseMove = this.onMouseMove, e.onMouseScroll = this.onMouseScroll, e
    },
    checkAvailable: function() {
        return !0
    }
}), cc._EventListenerMouse.LISTENER_ID = "__cc_mouse", cc._EventListenerMouse.create = function() {
    return new cc._EventListenerMouse
}, cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: null,
    swallowTouches: !1,
    onTouchBegan: null,
    onTouchMoved: null,
    onTouchEnded: null,
    onTouchCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null), this._claimedTouches = []
    },
    setSwallowTouches: function(e) {
        this.swallowTouches = e
    },
    clone: function() {
        var e = new cc._EventListenerTouchOneByOne;
        return e.onTouchBegan = this.onTouchBegan, e.onTouchMoved = this.onTouchMoved, e.onTouchEnded = this.onTouchEnded, e.onTouchCancelled = this.onTouchCancelled, e.swallowTouches = this.swallowTouches, e
    },
    checkAvailable: function() {
        return this.onTouchBegan ? !0 : (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1)
    }
}), cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one", cc._EventListenerTouchOneByOne.create = function() {
    return new cc._EventListenerTouchOneByOne
}, cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: null,
    onTouchesMoved: null,
    onTouchesEnded: null,
    onTouchesCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
    },
    clone: function() {
        var e = new cc._EventListenerTouchAllAtOnce;
        return e.onTouchesBegan = this.onTouchesBegan, e.onTouchesMoved = this.onTouchesMoved, e.onTouchesEnded = this.onTouchesEnded, e.onTouchesCancelled = this.onTouchesCancelled, e
    },
    checkAvailable: function() {
        return this.onTouchesBegan == null && this.onTouchesMoved == null && this.onTouchesEnded == null && this.onTouchesCancelled == null ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0
    }
}), cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once", cc._EventListenerTouchAllAtOnce.create = function() {
    return new cc._EventListenerTouchAllAtOnce
}, cc.EventListener.create = function(e) {
    cc.assert(e && e.event, cc._LogInfos.EventListener_create);
    var t = e.event;
    delete e.event;
    var n = null;
    t === cc.EventListener.TOUCH_ONE_BY_ONE ? n = new cc._EventListenerTouchOneByOne : t === cc.EventListener.TOUCH_ALL_AT_ONCE ? n = new cc._EventListenerTouchAllAtOnce : t === cc.EventListener.MOUSE ? n = new cc._EventListenerMouse : t === cc.EventListener.CUSTOM ? (n = new cc._EventListenerCustom(e.eventName, e.callback), delete e.eventName, delete e.callback) : t === cc.EventListener.KEYBOARD ? n = new cc._EventListenerKeyboard : t === cc.EventListener.ACCELERATION && (n = new cc._EventListenerAcceleration(e.callback), delete e.callback);
    for (var r in e)
        n[r] = e[r];
    return n
}, cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null,
    _sceneGraphListeners: null,
    gt0Index: 0,
    ctor: function() {
        this._fixedListeners = [], this._sceneGraphListeners = []
    },
    size: function() {
        return this._fixedListeners.length + this._sceneGraphListeners.length
    },
    empty: function() {
        return this._fixedListeners.length === 0 && this._sceneGraphListeners.length === 0
    },
    push: function(e) {
        e._getFixedPriority() == 0 ? this._sceneGraphListeners.push(e) : this._fixedListeners.push(e)
    },
    clearSceneGraphListeners: function() {
        this._sceneGraphListeners.length = 0
    },
    clearFixedListeners: function() {
        this._fixedListeners.length = 0
    },
    clear: function() {
        this._sceneGraphListeners.length = 0, this._fixedListeners.length = 0
    },
    getFixedPriorityListeners: function() {
        return this._fixedListeners
    },
    getSceneGraphPriorityListeners: function() {
        return this._sceneGraphListeners
    }
}), cc.__getListenerID = function(e) {
    var t = cc.Event,
        n = e.getType();
    return n === t.ACCELERATION ? cc._EventListenerAcceleration.LISTENER_ID : n === t.CUSTOM ? e.getEventName() : n === t.KEYBOARD ? cc._EventListenerKeyboard.LISTENER_ID : n === t.MOUSE ? cc._EventListenerMouse.LISTENER_ID : (n === t.TOUCH && cc.log(cc._LogInfos.__getListenerID), "")
}, cc.eventManager = {
    DIRTY_NONE: 0,
    DIRTY_FIXED_PRIORITY: 1,
    DIRTY_SCENE_GRAPH_PRIORITY: 2,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: !1,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function(e) {
        this._nodeListenersMap[e.__instanceId] != null && this._dirtyNodes.push(e);
        var t = e.getChildren();
        for (var n = 0, r = t.length; n < r; n++)
            this._setDirtyForNode(t[n])
    },
    pauseTarget: function(e, t) {
        var n = this._nodeListenersMap[e.__instanceId],
            r, i;
        if (n)
            for (r = 0, i = n.length; r < i; r++)
                n[r]._setPaused(!0);
        if (t === !0) {
            var s = e.getChildren();
            for (r = 0, i = s.length; r < i; r++)
                this.pauseTarget(s[r], !0)
        }
    },
    resumeTarget: function(e, t) {
        var n = this._nodeListenersMap[e.__instanceId],
            r, i;
        if (n)
            for (r = 0, i = n.length; r < i; r++)
                n[r]._setPaused(!1);
        this._setDirtyForNode(e);
        if (t === !0) {
            var s = e.getChildren();
            for (r = 0, i = s.length; r < i; r++)
                this.resumeTarget(s[r], !0)
        }
    },
    _addListener: function(e) {
        this._inDispatch === 0 ? this._forceAddEventListener(e) : this._toAddedListeners.push(e)
    },
    _forceAddEventListener: function(e) {
        var t = e._getListenerID(),
            n = this._listenersMap[t];
        n || (n = new cc._EventListenerVector, this._listenersMap[t] = n), n.push(e);
        if (e._getFixedPriority() == 0) {
            this._setDirty(t, this.DIRTY_SCENE_GRAPH_PRIORITY);
            var r = e._getSceneGraphPriority();
            r == null && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(r, e), r.isRunning() && this.resumeTarget(r)
        } else
            this._setDirty(t, this.DIRTY_FIXED_PRIORITY)
    },
    _getListeners: function(e) {
        return this._listenersMap[e]
    },
    _updateDirtyFlagForSceneGraph: function() {
        if (this._dirtyNodes.length == 0)
            return;
        var e = this._dirtyNodes,
            t, n, r = this._nodeListenersMap;
        for (var i = 0, s = e.length; i < s; i++) {
            t = r[e[i].__instanceId];
            if (t)
                for (var o = 0, u = t.length; o < u; o++)
                    n = t[o], n && this._setDirty(n._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY)
        }
        this._dirtyNodes.length = 0
    },
    _removeAllListenersInVector: function(e) {
        if (!e)
            return;
        var t;
        for (var n = 0; n < e.length;)
            t = e[n], t._setRegistered(!1), t._getSceneGraphPriority() != null && (this._dissociateNodeAndEventListener(t._getSceneGraphPriority(), t), t._setSceneGraphPriority(null)), this._inDispatch === 0 ? cc.arrayRemoveObject(e, t) : ++n
    },
    _removeListenersForListenerID: function(e) {
        var t = this._listenersMap[e],
            n;
        if (t) {
            var r = t.getFixedPriorityListeners(),
                i = t.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(i), this._removeAllListenersInVector(r), delete this._priorityDirtyFlagMap[e], this._inDispatch || (t.clear(), delete this._listenersMap[e])
        }
        var s = this._toAddedListeners,
            o;
        for (n = 0; n < s.length;)
            o = s[n], o && o._getListenerID() == e ? cc.arrayRemoveObject(s, o) : ++n
    },
    _sortEventListeners: function(e) {
        var t = this.DIRTY_NONE,
            n = this._priorityDirtyFlagMap;
        n[e] && (t = n[e]);
        if (t != this.DIRTY_NONE) {
            n[e] = this.DIRTY_NONE, t & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(e);
            if (t & this.DIRTY_SCENE_GRAPH_PRIORITY) {
                var r = cc.director.getRunningScene();
                r ? this._sortListenersOfSceneGraphPriority(e, r) : n[e] = this.DIRTY_SCENE_GRAPH_PRIORITY
            }
        }
    },
    _sortListenersOfSceneGraphPriority: function(e, t) {
        var n = this._getListeners(e);
        if (!n)
            return;
        var r = n.getSceneGraphPriorityListeners();
        if (!r || r.length === 0)
            return;
        this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(t, !0), n.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes)
    },
    _sortEventListenersOfSceneGraphPriorityDes: function(e, t) {
        var n = cc.eventManager._nodePriorityMap;
        return !e || !t || !e._getSceneGraphPriority() || !t._getSceneGraphPriority() ? -1 : n[t._getSceneGraphPriority().__instanceId] - n[e._getSceneGraphPriority().__instanceId]
    },
    _sortListenersOfFixedPriority: function(e) {
        var t = this._listenersMap[e];
        if (!t)
            return;
        var n = t.getFixedPriorityListeners();
        if (!n || n.length === 0)
            return;
        n.sort(this._sortListenersOfFixedPriorityAsc);
        var r = 0;
        for (var i = n.length; r < i;) {
            if (n[r]._getFixedPriority() >= 0)
                break;
            ++r
        }
        t.gt0Index = r
    },
    _sortListenersOfFixedPriorityAsc: function(e, t) {
        return e._getFixedPriority() - t._getFixedPriority()
    },
    _onUpdateListeners: function(e) {
        var t = this._listenersMap[e];
        if (!t)
            return;
        var n = t.getFixedPriorityListeners(),
            r = t.getSceneGraphPriorityListeners(),
            i, s;
        if (r)
            for (i = 0; i < r.length;)
                s = r[i], s._isRegistered() ? ++i : cc.arrayRemoveObject(r, s);
        if (n)
            for (i = 0; i < n.length;)
                s = n[i], s._isRegistered() ? ++i : cc.arrayRemoveObject(n, s);
        r && r.length === 0 && t.clearSceneGraphListeners(), n && n.length === 0 && t.clearFixedListeners()
    },
    _updateListeners: function(e) {
        var t = this._inDispatch;
        cc.assert(t > 0, cc._LogInfos.EventManager__updateListeners), e.getType() == cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(e));
        if (t > 1)
            return;
        cc.assert(t == 1, cc._LogInfos.EventManager__updateListeners_2);
        var n = this._listenersMap,
            r = this._priorityDirtyFlagMap;
        for (var i in n)
            n[i].empty() && (delete r[i], delete n[i]);
        var s = this._toAddedListeners;
        if (s.length !== 0) {
            for (var o = 0, u = s.length; o < u; o++)
                this._forceAddEventListener(s[o]);
            this._toAddedListeners.length = 0
        }
    },
    _onTouchEventCallback: function(e, t) {
        if (!e._isRegistered)
            return !1;
        var n = t.event,
            r = t.selTouch;
        n._setCurrentTarget(e._node);
        var i = !1,
            s, o = n.getEventCode(),
            u = cc.EventTouch.EventCode;
        return o == u.BEGAN ? e.onTouchBegan && (i = e.onTouchBegan(r, n), i && e._registered && e._claimedTouches.push(r)) : e._claimedTouches.length > 0 && (s = e._claimedTouches.indexOf(r)) != -1 && (i = !0, o === u.MOVED && e.onTouchMoved ? e.onTouchMoved(r, n) : o === u.ENDED ? (e.onTouchEnded && e.onTouchEnded(r, n), e._registered && e._claimedTouches.splice(s, 1)) : o === u.CANCELLED && (e.onTouchCancelled && e.onTouchCancelled(r, n), e._registered && e._claimedTouches.splice(s, 1))), n.isStopped() ? (cc.eventManager._updateListeners(n), !0) : i && e._registered && e.swallowTouches ? (t.needsMutableSet && t.touches.splice(r, 1), !0) : !1
    },
    _dispatchTouchEvent: function(e) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var t = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
            n = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (null == t && null == n)
            return;
        var r = e.getTouches(),
            i = cc.copyArray(r),
            s = {
                event: e,
                needsMutableSet: t && n,
                touches: i,
                selTouch: null
            };
        if (t)
            for (var o = 0; o < r.length; o++) {
                s.selTouch = r[o], this._dispatchEventToListeners(t, this._onTouchEventCallback, s);
                if (e.isStopped())
                    return
            }
        if (n && i.length > 0) {
            this._dispatchEventToListeners(n, this._onTouchesEventCallback, {
                event: e,
                touches: i
            });
            if (e.isStopped())
                return
        }
        this._updateListeners(e)
    },
    _onTouchesEventCallback: function(e, t) {
        if (!e._registered)
            return !1;
        var n = cc.EventTouch.EventCode,
            r = t.event,
            i = t.touches,
            s = r.getEventCode();
        return r._setCurrentTarget(e._node), s == n.BEGAN && e.onTouchesBegan ? e.onTouchesBegan(i, r) : s == n.MOVED && e.onTouchesMoved ? e.onTouchesMoved(i, r) : s == n.ENDED && e.onTouchesEnded ? e.onTouchesEnded(i, r) : s == n.CANCELLED && e.onTouchesCancelled && e.onTouchesCancelled(i, r), r.isStopped() ? (cc.eventManager._updateListeners(r), !0) : !1
    },
    _associateNodeAndEventListener: function(e, t) {
        var n = this._nodeListenersMap[e.__instanceId];
        n || (n = [], this._nodeListenersMap[e.__instanceId] = n), n.push(t)
    },
    _dissociateNodeAndEventListener: function(e, t) {
        var n = this._nodeListenersMap[e.__instanceId];
        n && (cc.arrayRemoveObject(n, t), n.length === 0 && delete this._nodeListenersMap[e.__instanceId])
    },
    _dispatchEventToListeners: function(e, t, n) {
        var r = !1,
            i = e.getFixedPriorityListeners(),
            s = e.getSceneGraphPriorityListeners(),
            o = 0,
            u, a;
        if (i && i.length !== 0)
            for (; o < e.gt0Index; ++o) {
                a = i[o];
                if (a.isEnabled() && !a._isPaused() && a._isRegistered() && t(a, n)) {
                    r = !0;
                    break
                }
            }
        if (s && !r)
            for (u = 0; u < s.length; u++) {
                a = s[u];
                if (a.isEnabled() && !a._isPaused() && a._isRegistered() && t(a, n)) {
                    r = !0;
                    break
                }
            }
        if (i && !r)
            for (; o < i.length; ++o) {
                a = i[o];
                if (a.isEnabled() && !a._isPaused() && a._isRegistered() && t(a, n)) {
                    r = !0;
                    break
                }
            }
    },
    _setDirty: function(e, t) {
        var n = this._priorityDirtyFlagMap;
        n[e] == null ? n[e] = t : n[e] = t | n[e]
    },
    _visitTarget: function(e, t) {
        var n = e.getChildren(),
            r = 0,
            i = n.length,
            s = this._globalZOrderNodeMap,
            o = this._nodeListenersMap;
        if (i > 0) {
            var u;
            for (; r < i; r++) {
                u = n[r];
                if (!(u && u.getLocalZOrder() < 0))
                    break;
                this._visitTarget(u, !1)
            }
            o[e.__instanceId] != null && (s[e.getGlobalZOrder()] || (s[e.getGlobalZOrder()] = []), s[e.getGlobalZOrder()].push(e.__instanceId));
            for (; r < i; r++)
                u = n[r], u && this._visitTarget(u, !1)
        } else
            o[e.__instanceId] != null && (s[e.getGlobalZOrder()] || (s[e.getGlobalZOrder()] = []), s[e.getGlobalZOrder()].push(e.__instanceId));
        if (t) {
            var a = [];
            for (var f in s)
                a.push(f);
            a.sort(this._sortNumberAsc);
            var l = a.length,
                c, h, p = this._nodePriorityMap;
            for (r = 0; r < l; r++) {
                c = s[a[r]];
                for (h = 0; h < c.length; h++)
                    p[c[h]] = ++this._nodePriorityIndex
            }
            this._globalZOrderNodeMap = {}
        }
    },
    _sortNumberAsc: function(e, t) {
        return e - t
    },
    addListener: function(e, t) {
        cc.assert(e && t, cc._LogInfos.eventManager_addListener_2);
        if (e instanceof cc.EventListener) {
            if (e._isRegistered()) {
                cc.log(cc._LogInfos.eventManager_addListener_4);
                return
            }
        } else
            cc.assert(!cc.isNumber(t), cc._LogInfos.eventManager_addListener_3), e = cc.EventListener.create(e);
        if (!e.checkAvailable())
            return;
        if (cc.isNumber(t)) {
            if (t == 0) {
                cc.log(cc._LogInfos.eventManager_addListener);
                return
            }
            e._setSceneGraphPriority(null), e._setFixedPriority(t), e._setRegistered(!0), e._setPaused(!1), this._addListener(e)
        } else
            e._setSceneGraphPriority(t), e._setFixedPriority(0), e._setRegistered(!0), this._addListener(e)
    },
    addCustomListener: function(e, t) {
        var n = cc._EventListenerCustom.create(e, t);
        return this.addListener(n, 1), n
    },
    removeListener: function(e) {
        if (e == null)
            return;
        var t, n = this._listenersMap;
        for (var r in n) {
            var i = n[r],
                s = i.getFixedPriorityListeners(),
                o = i.getSceneGraphPriorityListeners();
            t = this._removeListenerInVector(o, e), t ? this._setDirty(e._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY) : (t = this._removeListenerInVector(s, e), t && this._setDirty(e._getListenerID(), this.DIRTY_FIXED_PRIORITY)), i.empty() && (delete this._priorityDirtyFlagMap[e._getListenerID()], delete n[r]);
            if (t)
                break
        }
        if (!t) {
            var u = this._toAddedListeners;
            for (var a = 0, f = u.length; a < f; a++) {
                var l = u[a];
                if (l == e) {
                    cc.arrayRemoveObject(u, l);
                    break
                }
            }
        }
    },
    _removeListenerInVector: function(e, t) {
        if (e == null)
            return !1;
        for (var n = 0, r = e.length; n < r; n++) {
            var i = e[n];
            if (i == t)
                return i._setRegistered(!1), i._getSceneGraphPriority() != null && (this._dissociateNodeAndEventListener(i._getSceneGraphPriority(), i), i._setSceneGraphPriority(null)), this._inDispatch == 0 && cc.arrayRemoveObject(e, i), !0
        }
        return !1
    },
    removeListeners: function(e, t) {
        var n = this;
        if (e instanceof cc.Node) {
            delete n._nodePriorityMap[e.__instanceId], cc.arrayRemoveObject(n._dirtyNodes, e);
            var r = n._nodeListenersMap[e.__instanceId],
                i;
            if (r) {
                var s = cc.copyArray(r);
                for (i = 0; i < s.length; i++)
                    n.removeListener(s[i]);
                s.length = 0
            }
            var o = n._toAddedListeners;
            for (i = 0; i < o.length;) {
                var u = o[i];
                u._getSceneGraphPriority() == e ? (u._setSceneGraphPriority(null), u._setRegistered(!1), o.splice(i, 1)) : ++i
            }
            if (t === !0) {
                var a = e.getChildren(),
                    f;
                for (i = 0, f = a.length; i < f; i++)
                    n.removeListeners(a[i], !0)
            }
        } else
            e == cc.EventListener.TOUCH_ONE_BY_ONE ? n._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : e == cc.EventListener.TOUCH_ALL_AT_ONCE ? n._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : e == cc.EventListener.MOUSE ? n._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : e == cc.EventListener.ACCELERATION ? n._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : e == cc.EventListener.KEYBOARD ? n._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
    },
    removeCustomListeners: function(e) {
        this._removeListenersForListenerID(e)
    },
    removeAllListeners: function() {
        var e = this._listenersMap,
            t = this._internalCustomListenerIDs;
        for (var n in e)
            t.indexOf(n) === -1 && this._removeListenersForListenerID(n)
    },
    setPriority: function(e, t) {
        if (e == null)
            return;
        var n = this._listenersMap;
        for (var r in n) {
            var i = n[r],
                s = i.getFixedPriorityListeners();
            if (s) {
                var o = s.indexOf(e);
                if (o != -1) {
                    e._getSceneGraphPriority() != null && cc.log(cc._LogInfos.eventManager_setPriority), e._getFixedPriority() !== t && (e._setFixedPriority(t), this._setDirty(e._getListenerID(), this.DIRTY_FIXED_PRIORITY));
                    return
                }
            }
        }
    },
    setEnabled: function(e) {
        this._isEnabled = e
    },
    isEnabled: function() {
        return this._isEnabled
    },
    dispatchEvent: function(e) {
        if (!this._isEnabled)
            return;
        this._updateDirtyFlagForSceneGraph(), this._inDispatch++;
        if (!e || !e.getType)
            throw "event is undefined";
        if (e.getType() == cc.Event.TOUCH) {
            this._dispatchTouchEvent(e), this._inDispatch--;
            return
        }
        var t = cc.__getListenerID(e);
        this._sortEventListeners(t);
        var n = this._listenersMap[t];
        n != null && this._dispatchEventToListeners(n, this._onListenerCallback, e), this._updateListeners(e), this._inDispatch--
    },
    _onListenerCallback: function(e, t) {
        return t._setCurrentTarget(e._getSceneGraphPriority()), e._onEvent(t), t.isStopped()
    },
    dispatchCustomEvent: function(e, t) {
        var n = new cc.EventCustom(e);
        n.setUserData(t), this.dispatchEvent(n)
    }
}, cc._tmp.PrototypeCCNode = function() {
    var e = cc.Node.prototype;
    cc.defineGetterSetter(e, "x", e.getPositionX, e.setPositionX), cc.defineGetterSetter(e, "y", e.getPositionY, e.setPositionY), e.width, cc.defineGetterSetter(e, "width", e._getWidth, e._setWidth), e.height, cc.defineGetterSetter(e, "height", e._getHeight, e._setHeight), e.anchorX, cc.defineGetterSetter(e, "anchorX", e._getAnchorX, e._setAnchorX), e.anchorY, cc.defineGetterSetter(e, "anchorY", e._getAnchorY, e._setAnchorY), e.skewX, cc.defineGetterSetter(e, "skewX", e.getSkewX, e.setSkewX), e.skewY, cc.defineGetterSetter(e, "skewY", e.getSkewY, e.setSkewY), e.zIndex, cc.defineGetterSetter(e, "zIndex", e.getLocalZOrder, e.setLocalZOrder), e.vertexZ, cc.defineGetterSetter(e, "vertexZ", e.getVertexZ, e.setVertexZ), e.rotation, cc.defineGetterSetter(e, "rotation", e.getRotation, e.setRotation), e.rotationX, cc.defineGetterSetter(e, "rotationX", e.getRotationX, e.setRotationX), e.rotationY, cc.defineGetterSetter(e, "rotationY", e.getRotationY, e.setRotationY), e.scale, cc.defineGetterSetter(e, "scale", e.getScale, e.setScale), e.scaleX, cc.defineGetterSetter(e, "scaleX", e.getScaleX, e.setScaleX), e.scaleY, cc.defineGetterSetter(e, "scaleY", e.getScaleY, e.setScaleY), e.children, cc.defineGetterSetter(e, "children", e.getChildren), e.childrenCount, cc.defineGetterSetter(e, "childrenCount", e.getChildrenCount), e.parent, cc.defineGetterSetter(e, "parent", e.getParent, e.setParent), e.visible, cc.defineGetterSetter(e, "visible", e.isVisible, e.setVisible), e.running, cc.defineGetterSetter(e, "running", e.isRunning), e.ignoreAnchor, cc.defineGetterSetter(e, "ignoreAnchor", e.isIgnoreAnchorPointForPosition, e.ignoreAnchorPointForPosition), e.tag, e.userData, e.userObject, e.arrivalOrder, e.actionManager, cc.defineGetterSetter(e, "actionManager", e.getActionManager, e.setActionManager), e.scheduler, cc.defineGetterSetter(e, "scheduler", e.getScheduler, e.setScheduler), e.shaderProgram, cc.defineGetterSetter(e, "shaderProgram", e.getShaderProgram, e.setShaderProgram), e.opacity, cc.defineGetterSetter(e, "opacity", e.getOpacity, e.setOpacity), e.opacityModifyRGB, cc.defineGetterSetter(e, "opacityModifyRGB", e.isOpacityModifyRGB), e.cascadeOpacity, cc.defineGetterSetter(e, "cascadeOpacity", e.isCascadeOpacityEnabled, e.setCascadeOpacityEnabled), e.color, cc.defineGetterSetter(e, "color", e.getColor, e.setColor), e.cascadeColor, cc.defineGetterSetter(e, "cascadeColor", e.isCascadeColorEnabled, e.setCascadeColorEnabled)
}, cc.NODE_TAG_INVALID = -1, cc.s_globalOrderOfArrival = 1, cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0,
    _rotationX: 0,
    _rotationY: 0,
    _scaleX: 1,
    _scaleY: 1,
    _position: null,
    _skewX: 0,
    _skewY: 0,
    _children: null,
    _visible: !0,
    _anchorPoint: null,
    _anchorPointInPoints: null,
    _contentSize: null,
    _running: !1,
    _parent: null,
    _ignoreAnchorPointForPosition: !1,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _transformDirty: !0,
    _inverseDirty: !0,
    _cacheDirty: !0,
    _cachedParent: null,
    _transformGLDirty: null,
    _transform: null,
    _inverse: null,
    _reorderChildDirty: !1,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _initializedNode: !1,
    _additionalTransformDirty: !1,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: !1,
    _rotationRadiansX: 0,
    _rotationRadiansY: 0,
    _className: "Node",
    _showNode: !1,
    _name: "",
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: !1,
    _cascadeOpacityEnabled: !1,
    _usingNormalizedPosition: !1,
    _hashOfName: 0,
    _initNode: function() {
        var e = this;
        e._anchorPoint = cc.p(0, 0), e._anchorPointInPoints = cc.p(0, 0), e._contentSize = cc.size(0, 0), e._position = cc.p(0, 0), e._children = [], e._transform = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            tx: 0,
            ty: 0
        };
        var t = cc.director;
        e._actionManager = t.getActionManager(), e._scheduler = t.getScheduler(), e._initializedNode = !0, e._additionalTransform = cc.affineTransformMakeIdentity(), cc.ComponentContainer && (e._componentContainer = new cc.ComponentContainer(e)), this._displayedOpacity = 255, this._realOpacity = 255, this._displayedColor = cc.color(255, 255, 255, 255), this._realColor = cc.color(255, 255, 255, 255), this._cascadeColorEnabled = !1, this._cascadeOpacityEnabled = !1
    },
    init: function() {
        return this._initializedNode === !1 && this._initNode(), !0
    },
    _arrayMakeObjectsPerformSelector: function(e, t) {
        if (!e || e.length === 0)
            return;
        var n, r = e.length,
            i, s = cc.Node._StateCallbackType;
        switch (t) {
            case s.onEnter:
                for (n = 0; n < r; n++)
                    i = e[n], i && i.onEnter();
                break;
            case s.onExit:
                for (n = 0; n < r; n++)
                    i = e[n], i && i.onExit();
                break;
            case s.onEnterTransitionDidFinish:
                for (n = 0; n < r; n++)
                    i = e[n], i && i.onEnterTransitionDidFinish();
                break;
            case s.cleanup:
                for (n = 0; n < r; n++)
                    i = e[n], i && i.cleanup();
                break;
            case s.updateTransform:
                for (n = 0; n < r; n++)
                    i = e[n], i && i.updateTransform();
                break;
            case s.onExitTransitionDidStart:
                for (n = 0; n < r; n++)
                    i = e[n], i && i.onExitTransitionDidStart();
                break;
            case s.sortAllChildren:
                for (n = 0; n < r; n++)
                    i = e[n], i && i.sortAllChildren();
                break;
            default:
                cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
        }
    },
    setNodeDirty: null,
    attr: function(e) {
        for (var t in e)
            this[t] = e[t]
    },
    getSkewX: function() {
        return this._skewX
    },
    setSkewX: function(e) {
        this._skewX = e, this.setNodeDirty()
    },
    getSkewY: function() {
        return this._skewY
    },
    setSkewY: function(e) {
        this._skewY = e, this.setNodeDirty()
    },
    setLocalZOrder: function(e) {
        this._localZOrder = e, this._parent && this._parent.reorderChild(this, e), cc.eventManager._setDirtyForNode(this)
    },
    _setLocalZOrder: function(e) {
        this._localZOrder = e
    },
    getLocalZOrder: function() {
        return this._localZOrder
    },
    getZOrder: function() {
        return cc.log(cc._LogInfos.Node_getZOrder), this.getLocalZOrder()
    },
    setZOrder: function(e) {
        cc.log(cc._LogInfos.Node_setZOrder), this.setLocalZOrder(e)
    },
    setGlobalZOrder: function(e) {
        this._globalZOrder != e && (this._globalZOrder = e, cc.eventManager._setDirtyForNode(this))
    },
    getGlobalZOrder: function() {
        return this._globalZOrder
    },
    getVertexZ: function() {
        return this._vertexZ
    },
    setVertexZ: function(e) {
        this._vertexZ = e
    },
    getRotation: function() {
        return this._rotationX !== this._rotationY && cc.log(cc._LogInfos.Node_getRotation), this._rotationX
    },
    setRotation: function(e) {
        this._rotationX = this._rotationY = e, this._rotationRadiansX = this._rotationX * .017453292519943295, this._rotationRadiansY = this._rotationY * .017453292519943295, this.setNodeDirty()
    },
    getRotationX: function() {
        return this._rotationX
    },
    setRotationX: function(e) {
        this._rotationX = e, this._rotationRadiansX = this._rotationX * .017453292519943295, this.setNodeDirty()
    },
    getRotationY: function() {
        return this._rotationY
    },
    setRotationY: function(e) {
        this._rotationY = e, this._rotationRadiansY = this._rotationY * .017453292519943295, this.setNodeDirty()
    },
    getScale: function() {
        return this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale), this._scaleX
    },
    setScale: function(e, t) {
        this._scaleX = e, this._scaleY = t || t === 0 ? t : e, this.setNodeDirty()
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleX: function(e) {
        this._scaleX = e, this.setNodeDirty()
    },
    getScaleY: function() {
        return this._scaleY
    },
    setScaleY: function(e) {
        this._scaleY = e, this.setNodeDirty()
    },
    setPosition: function(e, t) {
        var n = this._position;
        t === undefined ? (n.x = e.x, n.y = e.y) : (n.x = e, n.y = t), this.setNodeDirty()
    },
    getPosition: function() {
        return cc.p(this._position)
    },
    getPositionX: function() {
        return this._position.x
    },
    setPositionX: function(e) {
        this._position.x = e, this.setNodeDirty()
    },
    getPositionY: function() {
        return this._position.y
    },
    setPositionY: function(e) {
        this._position.y = e, this.setNodeDirty()
    },
    getChildrenCount: function() {
        return this._children.length
    },
    getChildren: function() {
        return this._children
    },
    isVisible: function() {
        return this._visible
    },
    setVisible: function(e) {
        this._visible != e && (this._visible = e, e && this.setNodeDirty())
    },
    getAnchorPoint: function() {
        return cc.p(this._anchorPoint)
    },
    setAnchorPoint: function(e, t) {
        var n = this._anchorPoint;
        if (t === undefined) {
            if (e.x === n.x && e.y === n.y)
                return;
            n.x = e.x, n.y = e.y
        } else {
            if (e === n.x && t === n.y)
                return;
            n.x = e, n.y = t
        }
        var r = this._anchorPointInPoints,
            i = this._contentSize;
        r.x = i.width * n.x, r.y = i.height * n.y, this.setNodeDirty()
    },
    _getAnchor: function() {
        return this._anchorPoint
    },
    _setAnchor: function(e) {
        var t = e.x,
            n = e.y;
        this._anchorPoint.x !== t && (this._anchorPoint.x = t, this._anchorPointInPoints.x = this._contentSize.width * t), this._anchorPoint.y !== n && (this._anchorPoint.y = n, this._anchorPointInPoints.y = this._contentSize.height * n), this.setNodeDirty()
    },
    _getAnchorX: function() {
        return this._anchorPoint.x
    },
    _setAnchorX: function(e) {
        if (this._anchorPoint.x === e)
            return;
        this._anchorPoint.x = e, this._anchorPointInPoints.x = this._contentSize.width * e, this.setNodeDirty()
    },
    _getAnchorY: function() {
        return this._anchorPoint.y
    },
    _setAnchorY: function(e) {
        if (this._anchorPoint.y === e)
            return;
        this._anchorPoint.y = e, this._anchorPointInPoints.y = this._contentSize.height * e, this.setNodeDirty()
    },
    getAnchorPointInPoints: function() {
        return cc.p(this._anchorPointInPoints)
    },
    _getWidth: function() {
        return this._contentSize.width
    },
    _setWidth: function(e) {
        this._contentSize.width = e, this._anchorPointInPoints.x = e * this._anchorPoint.x, this.setNodeDirty()
    },
    _getHeight: function() {
        return this._contentSize.height
    },
    _setHeight: function(e) {
        this._contentSize.height = e, this._anchorPointInPoints.y = e * this._anchorPoint.y, this.setNodeDirty()
    },
    getContentSize: function() {
        return cc.size(this._contentSize)
    },
    setContentSize: function(e, t) {
        var n = this._contentSize;
        if (t === undefined) {
            if (e.width === n.width && e.height === n.height)
                return;
            n.width = e.width, n.height = e.height
        } else {
            if (e === n.width && t === n.height)
                return;
            n.width = e, n.height = t
        }
        var r = this._anchorPointInPoints,
            i = this._anchorPoint;
        r.x = n.width * i.x, r.y = n.height * i.y, this.setNodeDirty()
    },
    isRunning: function() {
        return this._running
    },
    getParent: function() {
        return this._parent
    },
    setParent: function(e) {
        this._parent = e
    },
    isIgnoreAnchorPointForPosition: function() {
        return this._ignoreAnchorPointForPosition
    },
    ignoreAnchorPointForPosition: function(e) {
        e != this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = e, this.setNodeDirty())
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(e) {
        this.tag = e
    },
    setName: function(e) {
        this._name = e
    },
    getName: function() {
        return this._name
    },
    getUserData: function() {
        return this.userData
    },
    setUserData: function(e) {
        this.userData = e
    },
    getUserObject: function() {
        return this.userObject
    },
    setUserObject: function(e) {
        this.userObject != e && (this.userObject = e)
    },
    getOrderOfArrival: function() {
        return this.arrivalOrder
    },
    setOrderOfArrival: function(e) {
        this.arrivalOrder = e
    },
    getActionManager: function() {
        return this._actionManager || (this._actionManager = cc.director.getActionManager()), this._actionManager
    },
    setActionManager: function(e) {
        this._actionManager != e && (this.stopAllActions(), this._actionManager = e)
    },
    getScheduler: function() {
        return this._scheduler || (this._scheduler = cc.director.getScheduler()), this._scheduler
    },
    setScheduler: function(e) {
        this._scheduler != e && (this.unscheduleAllCallbacks(), this._scheduler = e)
    },
    boundingBox: function() {
        return cc.log(cc._LogInfos.Node_boundingBox), this.getBoundingBox()
    },
    getBoundingBox: function() {
        var e = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(e, this.getNodeToParentTransform())
    },
    cleanup: function() {
        this.stopAllActions(), this.unscheduleAllCallbacks(), cc.eventManager.removeListeners(this), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.cleanup)
    },
    getChildByTag: function(e) {
        var t = this._children;
        if (t != null)
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                if (r && r.tag == e)
                    return r
            }
        return null
    },
    getChildByName: function(e) {
        if (!e)
            return cc.log("Invalid name"), null;
        var t = this._children;
        for (var n = 0, r = t.length; n < r; n++)
            if (t[n]._name == e)
                return t[n];
        return null
    },
    addChild: function(e, t, n) {
        var e = e,
            t = t === undefined ? e._localZOrder : t,
            n, r, i = !1;
        cc.isUndefined(n) ? (n = undefined, r = e._name) : cc.isString(n) ? (r = n, n = undefined) : cc.isNumber(n) && (i = !0, r = ""), cc.assert(e, cc._LogInfos.Node_addChild_3), cc.assert(e._parent === null, "child already added. It can't be added again"), this._addChildHelper(e, t, n, r, i)
    },
    _addChildHelper: function(e, t, n, r, i) {
        this._children || (this._children = []), this._insertChild(e, t), i ? e.setTag(n) : e.setName(r), e.setParent(this), e.setOrderOfArrival(cc.s_globalOrderOfArrival++), this._running && (e.onEnter(), this._isTransitionFinished && e.onEnterTransitionDidFinish()), this._cascadeColorEnabled && this._enableCascadeColor(), this._cascadeOpacityEnabled && this._enableCascadeOpacity()
    },
    removeFromParent: function(e) {
        this._parent && (e == null && (e = !0), this._parent.removeChild(this, e))
    },
    removeFromParentAndCleanup: function(e) {
        cc.log(cc._LogInfos.Node_removeFromParentAndCleanup), this.removeFromParent(e)
    },
    removeChild: function(e, t) {
        if (this._children.length === 0)
            return;
        t == null && (t = !0), this._children.indexOf(e) > -1 && this._detachChild(e, t), this.setNodeDirty()
    },
    removeChildByTag: function(e, t) {
        e === cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
        var n = this.getChildByTag(e);
        n == null ? cc.log(cc._LogInfos.Node_removeChildByTag_2, e) : this.removeChild(n, t)
    },
    removeAllChildrenWithCleanup: function(e) {
        this.removeAllChildren(e)
    },
    removeAllChildren: function(e) {
        var t = this._children;
        if (t != null) {
            e == null && (e = !0);
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r && (this._running && (r.onExitTransitionDidStart(), r.onExit()), e && r.cleanup(), r.parent = null)
            }
            this._children.length = 0
        }
    },
    _detachChild: function(e, t) {
        this._running && (e.onExitTransitionDidStart(), e.onExit()), t && e.cleanup(), e.parent = null, cc.arrayRemoveObject(this._children, e)
    },
    _insertChild: function(e, t) {
        this._reorderChildDirty = !0, this._children.push(e), e._setLocalZOrder(t)
    },
    reorderChild: function(e, t) {
        cc.assert(e, cc._LogInfos.Node_reorderChild), this._reorderChildDirty = !0, e.arrivalOrder = cc.s_globalOrderOfArrival, cc.s_globalOrderOfArrival++, e._setLocalZOrder(t), this.setNodeDirty()
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var e = this._children,
                t = e.length,
                n, r, i;
            for (n = 1; n < t; n++) {
                i = e[n], r = n - 1;
                while (r >= 0) {
                    if (i._localZOrder < e[r]._localZOrder)
                        e[r + 1] = e[r];
                    else {
                        if (!(i._localZOrder === e[r]._localZOrder && i.arrivalOrder < e[r].arrivalOrder))
                            break;
                        e[r + 1] = e[r]
                    }
                    r--
                }
                e[r + 1] = i
            }
            this._reorderChildDirty = !1
        }
    },
    draw: function(e) {},
    transformAncestors: function() {
        this._parent != null && (this._parent.transformAncestors(), this._parent.transform())
    },
    onEnter: function() {
        this._isTransitionFinished = !1, this._running = !0, this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onEnter), this.resume()
    },
    onEnterTransitionDidFinish: function() {
        this._isTransitionFinished = !0, this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onEnterTransitionDidFinish)
    },
    onExitTransitionDidStart: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onExitTransitionDidStart)
    },
    onExit: function() {
        this._running = !1, this.pause(), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.onExit), this.removeAllComponents()
    },
    runAction: function(e) {
        return cc.assert(e, cc._LogInfos.Node_runAction), this.actionManager.addAction(e, this, !this._running), e
    },
    stopAllActions: function() {
        this.actionManager && this.actionManager.removeAllActionsFromTarget(this)
    },
    stopAction: function(e) {
        this.actionManager.removeAction(e)
    },
    stopActionByTag: function(e) {
        if (e === cc.ACTION_TAG_INVALID) {
            cc.log(cc._LogInfos.Node_stopActionByTag);
            return
        }
        this.actionManager.removeActionByTag(e, this)
    },
    getActionByTag: function(e) {
        return e === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(e, this)
    },
    getNumberOfRunningActions: function() {
        return this.actionManager.numberOfRunningActionsInTarget(this)
    },
    scheduleUpdate: function() {
        this.scheduleUpdateWithPriority(0)
    },
    scheduleUpdateWithPriority: function(e) {
        this.scheduler.scheduleUpdateForTarget(this, e, !this._running)
    },
    unscheduleUpdate: function() {
        this.scheduler.unscheduleUpdateForTarget(this)
    },
    schedule: function(e, t, n, r) {
        t = t || 0, cc.assert(e, cc._LogInfos.Node_schedule), cc.assert(t >= 0, cc._LogInfos.Node_schedule_2), n = n == null ? cc.REPEAT_FOREVER : n, r = r || 0, this.scheduler.scheduleCallbackForTarget(this, e, t, n, r, !this._running)
    },
    scheduleOnce: function(e, t) {
        this.schedule(e, 0, 0, t)
    },
    unschedule: function(e) {
        if (!e)
            return;
        this.scheduler.unscheduleCallbackForTarget(this, e)
    },
    unscheduleAllCallbacks: function() {
        this.scheduler.unscheduleAllCallbacksForTarget(this)
    },
    resumeSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_resumeSchedulerAndActions), this.resume()
    },
    resume: function() {
        this.scheduler.resumeTarget(this), this.actionManager && this.actionManager.resumeTarget(this), cc.eventManager.resumeTarget(this)
    },
    pauseSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_pauseSchedulerAndActions), this.pause()
    },
    pause: function() {
        this.scheduler.pauseTarget(this), this.actionManager && this.actionManager.pauseTarget(this), cc.eventManager.pauseTarget(this)
    },
    setAdditionalTransform: function(e) {
        this._additionalTransform = e, this._transformDirty = !0, this._additionalTransformDirty = !0
    },
    getParentToNodeTransform: function() {
        return this._inverseDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform()), this._inverseDirty = !1), this._inverse
    },
    parentToNodeTransform: function() {
        return this.getParentToNodeTransform()
    },
    getNodeToWorldTransform: function() {
        var e = this.getNodeToParentTransform();
        for (var t = this._parent; t != null; t = t.parent)
            e = cc.affineTransformConcat(e, t.getNodeToParentTransform());
        return e
    },
    nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform()
    },
    getWorldToNodeTransform: function() {
        return cc.affineTransformInvert(this.getNodeToWorldTransform())
    },
    worldToNodeTransform: function() {
        return this.getWorldToNodeTransform()
    },
    convertToNodeSpace: function(e) {
        return cc.pointApplyAffineTransform(e, this.getWorldToNodeTransform())
    },
    convertToWorldSpace: function(e) {
        return e = e || cc.p(0, 0), cc.pointApplyAffineTransform(e, this.getNodeToWorldTransform())
    },
    convertToNodeSpaceAR: function(e) {
        return cc.pSub(this.convertToNodeSpace(e), this._anchorPointInPoints)
    },
    convertToWorldSpaceAR: function(e) {
        e = e || cc.p(0, 0);
        var t = cc.pAdd(e, this._anchorPointInPoints);
        return this.convertToWorldSpace(t)
    },
    _convertToWindowSpace: function(e) {
        var t = this.convertToWorldSpace(e);
        return cc.director.convertToUI(t)
    },
    convertTouchToNodeSpace: function(e) {
        var t = e.getLocation();
        return this.convertToNodeSpace(t)
    },
    convertTouchToNodeSpaceAR: function(e) {
        var t = e.getLocation();
        return t = cc.director.convertToGL(t), this.convertToNodeSpaceAR(t)
    },
    update: function(e) {
        this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(e)
    },
    updateTransform: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._StateCallbackType.updateTransform)
    },
    retain: function() {},
    release: function() {},
    getComponent: function(e) {
        return this._componentContainer ? this._componentContainer.getComponent(e) : null
    },
    addComponent: function(e) {
        this._componentContainer && this._componentContainer.add(e)
    },
    removeComponent: function(e) {
        return this._componentContainer ? this._componentContainer.remove(e) : !1
    },
    removeAllComponents: function() {
        this._componentContainer && this._componentContainer.removeAll()
    },
    grid: null,
    ctor: null,
    visit: null,
    transform: null,
    nodeToParentTransform: function() {
        return this.getNodeToParentTransform()
    },
    getNodeToParentTransform: null,
    _setNodeDirtyForCache: function() {
        if (this._cacheDirty === !1) {
            this._cacheDirty = !0;
            var e = this._cachedParent;
            e && e != this && e._setNodeDirtyForCache()
        }
    },
    _setCachedParent: function(e) {
        if (this._cachedParent == e)
            return;
        this._cachedParent = e;
        var t = this._children;
        for (var n = 0, r = t.length; n < r; n++)
            t[n]._setCachedParent(e)
    },
    getCamera: function() {
        return this._camera || (this._camera = new cc.Camera), this._camera
    },
    getGrid: function() {
        return this.grid
    },
    setGrid: function(e) {
        this.grid = e
    },
    getShaderProgram: function() {
        return this._shaderProgram
    },
    setShaderProgram: function(e) {
        this._shaderProgram = e
    },
    getGLServerState: function() {
        return this._glServerState
    },
    setGLServerState: function(e) {
        this._glServerState = e
    },
    getBoundingBoxToWorld: function() {
        var e = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
            t = this.getNodeToWorldTransform();
        e = cc.rectApplyAffineTransform(e, this.getNodeToWorldTransform());
        if (!this._children)
            return e;
        var n = this._children;
        for (var r = 0; r < n.length; r++) {
            var i = n[r];
            if (i && i._visible) {
                var s = i._getBoundingBoxToCurrentNode(t);
                s && (e = cc.rectUnion(e, s))
            }
        }
        return e
    },
    _getBoundingBoxToCurrentNode: function(e) {
        var t = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
            n = e == null ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), e);
        t = cc.rectApplyAffineTransform(t, n);
        if (!this._children)
            return t;
        var r = this._children;
        for (var i = 0; i < r.length; i++) {
            var s = r[i];
            if (s && s._visible) {
                var o = s._getBoundingBoxToCurrentNode(n);
                o && (t = cc.rectUnion(t, o))
            }
        }
        return t
    },
    _getNodeToParentTransformForWebGL: function() {
        var e = this;
        if (e._transformDirty) {
            var t = e._position.x,
                n = e._position.y,
                r = e._anchorPointInPoints.x,
                i = -r,
                s = e._anchorPointInPoints.y,
                o = -s,
                u = e._scaleX,
                a = e._scaleY;
            e._ignoreAnchorPointForPosition && (t += r, n += s);
            var f = 1,
                l = 0,
                c = 1,
                h = 0;
            if (e._rotationX !== 0 || e._rotationY !== 0)
                f = Math.cos(-e._rotationRadiansX), l = Math.sin(-e._rotationRadiansX), c = Math.cos(-e._rotationRadiansY), h = Math.sin(-e._rotationRadiansY);
            var p = e._skewX || e._skewY;
            !p && (r !== 0 || s !== 0) && (t += c * i * u + -l * o * a, n += h * i * u + f * o * a);
            var d = e._transform;
            d.a = c * u, d.b = h * u, d.c = -l * a, d.d = f * a, d.tx = t, d.ty = n;
            if (p) {
                d = cc.affineTransformConcat({
                    a: 1,
                    b: Math.tan(cc.degreesToRadians(e._skewY)),
                    c: Math.tan(cc.degreesToRadians(e._skewX)),
                    d: 1,
                    tx: 0,
                    ty: 0
                }, d);
                if (r !== 0 || s !== 0)
                    d = cc.affineTransformTranslate(d, i, o)
            }
            e._additionalTransformDirty && (d = cc.affineTransformConcat(d, e._additionalTransform), e._additionalTransformDirty = !1), e._transform = d, e._transformDirty = !1
        }
        return e._transform
    },
    _updateColor: function() {},
    getOpacity: function() {
        return this._realOpacity
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity
    },
    setOpacity: function(e) {
        this._displayedOpacity = this._realOpacity = e;
        var t = 255,
            n = this._parent;
        n && n.cascadeOpacity && (t = n.getDisplayedOpacity()), this.updateDisplayedOpacity(t), this._displayedColor.a = this._realColor.a = e
    },
    updateDisplayedOpacity: function(e) {
        this._displayedOpacity = this._realOpacity * e / 255;
        if (this._cascadeOpacityEnabled) {
            var t = this._children;
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r && r.updateDisplayedOpacity(this._displayedOpacity)
            }
        }
    },
    isCascadeOpacityEnabled: function() {
        return this._cascadeOpacityEnabled
    },
    setCascadeOpacityEnabled: function(e) {
        if (this._cascadeOpacityEnabled === e)
            return;
        this._cascadeOpacityEnabled = e, e ? this._enableCascadeOpacity() : this._disableCascadeOpacity()
    },
    _enableCascadeOpacity: function() {
        var e = 255,
            t = this._parent;
        t && t.cascadeOpacity && (e = t.getDisplayedOpacity()), this.updateDisplayedOpacity(e)
    },
    _disableCascadeOpacity: function() {
        this._displayedOpacity = this._realOpacity;
        var e = this._children;
        for (var t = 0; t < e.length; t++) {
            var n = e[t];
            n && n.updateDisplayedOpacity(255)
        }
    },
    getColor: function() {
        var e = this._realColor;
        return cc.color(e.r, e.g, e.b, e.a)
    },
    getDisplayedColor: function() {
        var e = this._displayedColor;
        return cc.color(e.r, e.g, e.b, e.a)
    },
    setColor: function(e) {
        var t = this._displayedColor,
            n = this._realColor;
        t.r = n.r = e.r, t.g = n.g = e.g, t.b = n.b = e.b;
        var r, i = this._parent;
        i && i.cascadeColor ? r = i.getDisplayedColor() : r = cc.color.WHITE, this.updateDisplayedColor(r)
    },
    updateDisplayedColor: function(e) {
        var t = this._displayedColor,
            n = this._realColor;
        t.r = 0 | n.r * e.r / 255, t.g = 0 | n.g * e.g / 255, t.b = 0 | n.b * e.b / 255;
        if (this._cascadeColorEnabled) {
            var r = this._children;
            for (var i = 0; i < r.length; i++) {
                var s = r[i];
                s && s.updateDisplayedColor(t)
            }
        }
    },
    isCascadeColorEnabled: function() {
        return this._cascadeColorEnabled
    },
    setCascadeColorEnabled: function(e) {
        if (this._cascadeColorEnabled === e)
            return;
        this._cascadeColorEnabled = e, this._cascadeColorEnabled ? this._enableCascadeColor() : this._disableCascadeColor()
    },
    _enableCascadeColor: function() {
        var e, t = this._parent;
        t && t.cascadeColor ? e = t.getDisplayedColor() : e = cc.color.WHITE, this.updateDisplayedColor(e)
    },
    _disableCascadeColor: function() {
        var e = this._displayedColor,
            t = this._realColor;
        e.r = t.r, e.g = t.g, e.b = t.b;
        var n = this._children,
            r = cc.color.WHITE;
        for (var i = 0; i < n.length; i++) {
            var s = n[i];
            s && s.updateDisplayedColor(r)
        }
    },
    setOpacityModifyRGB: function(e) {},
    isOpacityModifyRGB: function() {
        return !1
    }
}), cc.Node.create = function() {
    return new cc.Node
}, cc.Node._StateCallbackType = {
    onEnter: 1,
    onExit: 2,
    cleanup: 3,
    onEnterTransitionDidFinish: 4,
    updateTransform: 5,
    onExitTransitionDidStart: 6,
    sortAllChildren: 7
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.Node.prototype;
    _p.ctor = function() {
        this._initNode()
    }, _p.setNodeDirty = function() {
        var e = this;
        e._setNodeDirtyForCache(), e._transformDirty === !1 && (e._transformDirty = e._inverseDirty = !0)
    }, _p.visit = function(e) {
        var t = this;
        if (!t._visible)
            return;
        var n = e || cc._renderContext,
            r, i = t._children,
            s;
        n.save(), t.transform(n);
        var o = i.length;
        if (o > 0) {
            t.sortAllChildren();
            for (r = 0; r < o; r++) {
                s = i[r];
                if (!(s._localZOrder < 0))
                    break;
                s.visit(n)
            }
            t.draw(n);
            for (; r < o; r++)
                i[r].visit(n)
        } else
            t.draw(n);
        this._cacheDirty = !1, t.arrivalOrder = 0, n.restore()
    }, _p.transform = function(e) {
        var t = e || cc._renderContext,
            n = cc.view,
            r = this.getNodeToParentTransform();
        t.transform(r.a, r.c, r.b, r.d, r.tx * n.getScaleX(), -r.ty * n.getScaleY())
    }, _p.getNodeToParentTransform = function() {
        var e = this;
        if (e._transformDirty) {
            var t = e._transform;
            t.tx = e._position.x, t.ty = e._position.y;
            var n = 1,
                r = 0;
            e._rotationX && (n = Math.cos(e._rotationRadiansX), r = Math.sin(e._rotationRadiansX)), t.a = t.d = n, t.b = -r, t.c = r;
            var i = e._scaleX,
                s = e._scaleY,
                o = e._anchorPointInPoints.x,
                u = e._anchorPointInPoints.y,
                a = i < 1e-6 && i > -0.000001 ? 1e-6 : i,
                f = s < 1e-6 && s > -0.000001 ? 1e-6 : s;
            if (e._skewX || e._skewY) {
                var l = Math.tan(-e._skewX * Math.PI / 180),
                    c = Math.tan(-e._skewY * Math.PI / 180);
                l === Infinity && (l = 99999999), c === Infinity && (c = 99999999);
                var h = u * l * a,
                    p = o * c * f;
                t.a = n + -r * c, t.b = n * l + -r, t.c = r + n * c, t.d = r * l + n, t.tx += n * h + -r * p, t.ty += r * h + n * p
            }
            if (i !== 1 || s !== 1)
                t.a *= a, t.c *= a, t.b *= f, t.d *= f;
            t.tx += n * -o * a + -r * u * f, t.ty -= r * -o * a + n * u * f, e._ignoreAnchorPointForPosition && (t.tx += o, t.ty += u), e._additionalTransformDirty && (e._transform = cc.affineTransformConcat(t, e._additionalTransform), e._additionalTransformDirty = !1), e._transformDirty = !1
        }
        return e._transform
    }, _p = null
} else
    cc.assert(cc.isFunction(cc._tmp.WebGLCCNode), cc._LogInfos.MissingFile, "BaseNodesWebGL.js"), cc._tmp.WebGLCCNode(), delete cc._tmp.WebGLCCNode;
cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js"), cc._tmp.PrototypeCCNode(), delete cc._tmp.PrototypeCCNode, cc._tmp.PrototypeTexture2D = function() {
    var e = cc.Texture2D;
    e.PVRImagesHavePremultipliedAlpha = function(e) {
        cc.PVRHaveAlphaPremultiplied_ = e
    }, e.PIXEL_FORMAT_RGBA8888 = 2, e.PIXEL_FORMAT_RGB888 = 3, e.PIXEL_FORMAT_RGB565 = 4, e.PIXEL_FORMAT_A8 = 5, e.PIXEL_FORMAT_I8 = 6, e.PIXEL_FORMAT_AI88 = 7, e.PIXEL_FORMAT_RGBA4444 = 8, e.PIXEL_FORMAT_RGB5A1 = 7, e.PIXEL_FORMAT_PVRTC4 = 9, e.PIXEL_FORMAT_PVRTC2 = 10, e.PIXEL_FORMAT_DEFAULT = e.PIXEL_FORMAT_RGBA8888;
    var t = cc.Texture2D._M = {};
    t[e.PIXEL_FORMAT_RGBA8888] = "RGBA8888", t[e.PIXEL_FORMAT_RGB888] = "RGB888", t[e.PIXEL_FORMAT_RGB565] = "RGB565", t[e.PIXEL_FORMAT_A8] = "A8", t[e.PIXEL_FORMAT_I8] = "I8", t[e.PIXEL_FORMAT_AI88] = "AI88", t[e.PIXEL_FORMAT_RGBA4444] = "RGBA4444", t[e.PIXEL_FORMAT_RGB5A1] = "RGB5A1", t[e.PIXEL_FORMAT_PVRTC4] = "PVRTC4", t[e.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
    var n = cc.Texture2D._B = {};
    n[e.PIXEL_FORMAT_RGBA8888] = 32, n[e.PIXEL_FORMAT_RGB888] = 24, n[e.PIXEL_FORMAT_RGB565] = 16, n[e.PIXEL_FORMAT_A8] = 8, n[e.PIXEL_FORMAT_I8] = 8, n[e.PIXEL_FORMAT_AI88] = 16, n[e.PIXEL_FORMAT_RGBA4444] = 16, n[e.PIXEL_FORMAT_RGB5A1] = 16, n[e.PIXEL_FORMAT_PVRTC4] = 4, n[e.PIXEL_FORMAT_PVRTC2] = 3;
    var r = cc.Texture2D.prototype;
    r.name, cc.defineGetterSetter(r, "name", r.getName), r.pixelFormat, cc.defineGetterSetter(r, "pixelFormat", r.getPixelFormat), r.pixelsWidth, cc.defineGetterSetter(r, "pixelsWidth", r.getPixelsWide), r.pixelsHeight, cc.defineGetterSetter(r, "pixelsHeight", r.getPixelsHigh), r.width, cc.defineGetterSetter(r, "width", r._getWidth), r.height, cc.defineGetterSetter(r, "height", r._getHeight), e.defaultPixelFormat = e.PIXEL_FORMAT_DEFAULT
}, cc._tmp.PrototypeTextureAtlas = function() {
    var e = cc.TextureAtlas.prototype;
    e.totalQuads, cc.defineGetterSetter(e, "totalQuads", e.getTotalQuads), e.capacity, cc.defineGetterSetter(e, "capacity", e.getCapacity), e.quads, cc.defineGetterSetter(e, "quads", e.getQuads, e.setQuads)
}, cc.ALIGN_CENTER = 51, cc.ALIGN_TOP = 19, cc.ALIGN_TOP_RIGHT = 18, cc.ALIGN_RIGHT = 50, cc.ALIGN_BOTTOM_RIGHT = 34, cc.ALIGN_BOTTOM = 35, cc.ALIGN_BOTTOM_LEFT = 33, cc.ALIGN_LEFT = 49, cc.ALIGN_TOP_LEFT = 17, cc.PVRHaveAlphaPremultiplied_ = !1, cc._renderType === cc._RENDER_TYPE_CANVAS ? cc.Texture2D = cc.Class.extend({
    _contentSize: null,
    _isLoaded: !1,
    _htmlElementObj: null,
    _loadedEventListeners: null,
    url: null,
    ctor: function() {
        this._contentSize = cc.size(0, 0), this._isLoaded = !1, this._htmlElementObj = null
    },
    getPixelsWide: function() {
        return this._contentSize.width
    },
    getPixelsHigh: function() {
        return this._contentSize.height
    },
    getContentSize: function() {
        var e = cc.contentScaleFactor();
        return cc.size(this._contentSize.width / e, this._contentSize.height / e)
    },
    _getWidth: function() {
        return this._contentSize.width / cc.contentScaleFactor()
    },
    _getHeight: function() {
        return this._contentSize.height / cc.contentScaleFactor()
    },
    getContentSizeInPixels: function() {
        return this._contentSize
    },
    initWithElement: function(e) {
        if (!e)
            return;
        this._htmlElementObj = e
    },
    getHtmlElementObj: function() {
        return this._htmlElementObj
    },
    isLoaded: function() {
        return this._isLoaded
    },
    handleLoadedTexture: function() {
        var e = this;
        if (e._isLoaded)
            return;
        if (!e._htmlElementObj) {
            var t = cc.loader.getRes(e.url);
            if (!t)
                return;
            e.initWithElement(t)
        }
        e._isLoaded = !0;
        var n = e._htmlElementObj;
        e._contentSize.width = n.width, e._contentSize.height = n.height, e._callLoadedEventCallbacks()
    },
    description: function() {
        return "<cc.Texture2D | width = " + this._contentSize.width + " height " + this._contentSize.height + ">"
    },
    initWithData: function(e, t, n, r, i) {
        return !1
    },
    initWithImage: function(e) {
        return !1
    },
    initWithString: function(e, t, n, r, i, s) {
        return !1
    },
    releaseTexture: function() {},
    getName: function() {
        return null
    },
    getMaxS: function() {
        return 1
    },
    setMaxS: function(e) {},
    getMaxT: function() {
        return 1
    },
    setMaxT: function(e) {},
    getPixelFormat: function() {
        return null
    },
    getShaderProgram: function() {
        return null
    },
    setShaderProgram: function(e) {},
    hasPremultipliedAlpha: function() {
        return !1
    },
    hasMipmaps: function() {
        return !1
    },
    releaseData: function(e) {
        e = null
    },
    keepData: function(e, t) {
        return e
    },
    drawAtPoint: function(e) {},
    drawInRect: function(e) {},
    initWithETCFile: function(e) {
        return cc.log(cc._LogInfos.Texture2D_initWithETCFile), !1
    },
    initWithPVRFile: function(e) {
        return cc.log(cc._LogInfos.Texture2D_initWithPVRFile), !1
    },
    initWithPVRTCData: function(e, t, n, r, i, s) {
        return cc.log(cc._LogInfos.Texture2D_initWithPVRTCData), !1
    },
    setTexParameters: function(e) {},
    setAntiAliasTexParameters: function() {},
    setAliasTexParameters: function() {},
    generateMipmap: function() {},
    stringForFormat: function() {
        return ""
    },
    bitsPerPixelForFormat: function(e) {
        return -1
    },
    addLoadedEventListener: function(e, t) {
        this._loadedEventListeners || (this._loadedEventListeners = []), this._loadedEventListeners.push({
            eventCallback: e,
            eventTarget: t
        })
    },
    removeLoadedEventListener: function(e) {
        if (!this._loadedEventListeners)
            return;
        var t = this._loadedEventListeners;
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.eventTarget == e && t.splice(n, 1)
        }
    },
    _callLoadedEventCallbacks: function() {
        if (!this._loadedEventListeners)
            return;
        var e = this._loadedEventListeners;
        for (var t = 0, n = e.length; t < n; t++) {
            var r = e[t];
            r.eventCallback.call(r.eventTarget, this)
        }
        e.length = 0
    }
}) : (cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D), cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js"), cc._tmp.PrototypeTexture2D(), delete cc._tmp.PrototypeTexture2D, cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: 0 | Math.random() * 1e3,
    _loadedTexturesBefore: {},
    _initializingRenderer: function() {
        var e, t = this._loadedTexturesBefore,
            n = this._textures;
        for (e in t) {
            var r = t[e];
            r.handleLoadedTexture(), n[e] = r
        }
        this._loadedTexturesBefore = {}
    },
    addPVRTCImage: function(e) {
        cc.log(cc._LogInfos.textureCache_addPVRTCImage)
    },
    addETCImage: function(e) {
        cc.log(cc._LogInfos.textureCache_addETCImage)
    },
    description: function() {
        return "<TextureCache | Number of textures = " + this._textures.length + ">"
    },
    textureForKey: function(e) {
        return cc.log(cc._LogInfos.textureCache_textureForKey), this.getTextureForKey(e)
    },
    getTextureForKey: function(e) {
        return this._textures[e] || this._textures[cc.loader._aliases[e]]
    },
    getKeyByTexture: function(e) {
        for (var t in this._textures)
            if (this._textures[t] == e)
                return t;
        return null
    },
    _generalTextureKey: function() {
        return this._textureKeySeq++, "_textureKey_" + this._textureKeySeq
    },
    getTextureColors: function(e) {
        var t = this.getKeyByTexture(e);
        return t || (e instanceof HTMLImageElement ? t = e.src : t = this._generalTextureKey()), this._textureColorsCache[t] || (this._textureColorsCache[t] = cc.generateTextureCacheForColor(e)), this._textureColorsCache[t]
    },
    addPVRImage: function(e) {
        cc.log(cc._LogInfos.textureCache_addPVRImage)
    },
    removeAllTextures: function() {
        var e = this._textures;
        for (var t in e)
            e[t] && e[t].releaseTexture();
        this._textures = {}
    },
    removeTexture: function(e) {
        if (!e)
            return;
        var t = this._textures;
        for (var n in t)
            t[n] == e && (t[n].releaseTexture(), delete t[n])
    },
    removeTextureForKey: function(e) {
        if (e == null)
            return;
        this._textures[e] && delete this._textures[e]
    },
    cacheImage: function(e, t) {
        if (t instanceof cc.Texture2D) {
            this._textures[e] = t;
            return
        }
        var n = new cc.Texture2D;
        n.initWithElement(t), n.handleLoadedTexture(), this._textures[e] = n
    },
    addUIImage: function(e, t) {
        cc.assert(e, cc._LogInfos.textureCache_addUIImage_2);
        if (t && this._textures[t])
            return this._textures[t];
        var n = new cc.Texture2D;
        return n.initWithImage(e), t != null && n != null ? this._textures[t] = n : cc.log(cc._LogInfos.textureCache_addUIImage), n
    },
    dumpCachedTextureInfo: function() {
        var e = 0,
            t = 0,
            n = this._textures;
        for (var r in n) {
            var i = n[r];
            e++, i.getHtmlElementObj() instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, r, i.getHtmlElementObj().src, i.pixelsWidth, i.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, r, i.pixelsWidth, i.pixelsHeight), t += i.pixelsWidth * i.pixelsHeight * 4
        }
        var s = this._textureColorsCache;
        for (r in s) {
            var o = s[r];
            for (var u in o) {
                var a = o[u];
                e++, cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, r, a.width, a.height), t += a.width * a.height * 4
            }
        }
        cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, e, t / 1024, (t / 1048576).toFixed(2))
    },
    _clear: function() {
        this._textures = {}, this._textureColorsCache = {}, this._textureKeySeq = 0 | Math.random() * 1e3, this._loadedTexturesBefore = {}
    }
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.textureCache;
    _p.handleLoadedTexture = function(e) {
        var t = this._textures,
            n = t[e];
        n || (n = t[e] = new cc.Texture2D, n.url = e), n.handleLoadedTexture()
    }, _p.addImage = function(e, t, n) {
        cc.assert(e, cc._LogInfos.Texture2D_addImage);
        var r = this._textures,
            i = r[e] || r[cc.loader._aliases[e]];
        return i ? (t && t.call(n, i), i) : (i = r[e] = new cc.Texture2D, i.url = e, cc.loader.getRes(e) ? i.handleLoadedTexture() : cc.loader._checkIsImageURL(e) ? cc.loader.load(e, function(e) {
            t && t.call(n)
        }) : cc.loader.loadImg(e, function(r, s) {
            if (r)
                return t ? t(r) : r;
            cc.loader.cache[e] = s, cc.textureCache.handleLoadedTexture(e), t && t.call(n, i)
        }), i)
    }, _p = null
} else
    cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache;
cc.Scene = cc.Node.extend({
    _className: "Scene",
    ctor: function() {
        cc.Node.prototype.ctor.call(this), this._ignoreAnchorPointForPosition = !0, this.setAnchorPoint(.5, .5), this.setContentSize(cc.director.getWinSize())
    }
}), cc.Scene.create = function() {
    return new cc.Scene
}, cc.LoaderScene = cc.Scene.extend({
    _interval: null,
    _label: null,
    _className: "LoaderScene",
    init: function() {
        var e = this,
            t = 160,
            n = 200,
            r = e._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
        r.setPosition(cc.visibleRect.bottomLeft), e.addChild(r, 0);
        var i = 24,
            s = -n / 2 + 100;
        cc._loaderImage && (cc.loader.loadImg(cc._loaderImage, {
            isCrossOrigin: !1
        }, function(r, i) {
            t = i.width, n = i.height, e._initStage(i, cc.visibleRect.center)
        }), i = 14, s = -n / 2 - 10);
        var o = e._label = cc.LabelTTF.create("Loading... 0%", "Arial", i);
        return o.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, s))), o.setColor(cc.color(180, 180, 180)), r.addChild(this._label, 10), !0
    },
    _initStage: function(e, t) {
        var n = this,
            r = n._texture2d = new cc.Texture2D;
        r.initWithElement(e), r.handleLoadedTexture();
        var i = n._logo = cc.Sprite.create(r);
        i.setScale(cc.contentScaleFactor()), i.x = t.x, i.y = t.y, n._bgLayer.addChild(i, 10)
    },
    onEnter: function() {
        var e = this;
        cc.Node.prototype.onEnter.call(e), e.schedule(e._startLoading, .3)
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        var e = "Loading... 0%";
        this._label.setString(e)
    },
    initWithResources: function(e, t) {
        cc.isString(e) && (e = [e]), this.resources = e || [], this.cb = t
    },
    _startLoading: function() {
        var e = this;
        e.unschedule(e._startLoading);
        var t = e.resources;
        cc.loader.load(t, function(t, n, r) {
            var i = r / n * 100 | 0;
            i = Math.min(i, 100), e._label.setString("Loading... " + i + "%")
        }, function() {
            e.cb && e.cb()
        })
    }
}), cc.LoaderScene.preload = function(e, t) {
    var n = cc;
    return n.loaderScene || (n.loaderScene = new cc.LoaderScene, n.loaderScene.init()), n.loaderScene.initWithResources(e, t), cc.director.runScene(n.loaderScene), n.loaderScene
}, cc._tmp.PrototypeLayerColor = function() {
    var e = cc.LayerColor.prototype;
    cc.defineGetterSetter(e, "width", e._getWidth, e._setWidth), cc.defineGetterSetter(e, "height", e._getHeight, e._setHeight)
}, cc._tmp.PrototypeLayerGradient = function() {
    var e = cc.LayerGradient.prototype;
    e.startColor, cc.defineGetterSetter(e, "startColor", e.getStartColor, e.setStartColor), e.endColor, cc.defineGetterSetter(e, "endColor", e.getEndColor, e.setEndColor), e.startOpacity, cc.defineGetterSetter(e, "startOpacity", e.getStartOpacity, e.setStartOpacity), e.endOpacity, cc.defineGetterSetter(e, "endOpacity", e.getEndOpacity, e.setEndOpacity), e.vector, cc.defineGetterSetter(e, "vector", e.getVector, e.setVector)
}, cc.Layer = cc.Node.extend({
    _isBaked: !1,
    _bakeSprite: null,
    _className: "Layer",
    ctor: function() {
        var e = cc.Node.prototype;
        e.ctor.call(this), this._ignoreAnchorPointForPosition = !0, e.setAnchorPoint.call(this, .5, .5), e.setContentSize.call(this, cc.winSize)
    },
    init: function() {
        var e = this;
        return e._ignoreAnchorPointForPosition = !0, e.setAnchorPoint(.5, .5), e.setContentSize(cc.winSize), e.cascadeOpacity = !1, e.cascadeColor = !1, !0
    },
    bake: null,
    unbake: null,
    isBaked: function() {
        return this._isBaked
    },
    visit: null
}), cc.Layer.create = function() {
    return new cc.Layer
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var p = cc.Layer.prototype;
    p.bake = function() {
        if (!this._isBaked) {
            this._isBaked = this._cacheDirty = !0, this._cachedParent = this;
            var e = this._children;
            for (var t = 0, n = e.length; t < n; t++)
                e[t]._setCachedParent(this);
            this._bakeSprite || (this._bakeSprite = new cc.BakeSprite)
        }
    }, p.unbake = function() {
        if (this._isBaked) {
            this._isBaked = !1, this._cacheDirty = !0, this._cachedParent = null;
            var e = this._children;
            for (var t = 0, n = e.length; t < n; t++)
                e[t]._setCachedParent(null)
        }
    }, p.addChild = function(e, t, n) {
        cc.Node.prototype.addChild.call(this, e, t, n), e._parent == this && this._isBaked && e._setCachedParent(this)
    }, p.visit = function(e) {
        if (!this._isBaked) {
            cc.Node.prototype.visit.call(this, e);
            return
        }
        var t = e || cc._renderContext,
            n, r = this,
            i = r._children,
            s = i.length;
        if (!r._visible || s === 0)
            return;
        var o = this._bakeSprite;
        t.save(), r.transform(t);
        if (this._cacheDirty) {
            var u = this._getBoundingBoxForBake();
            u.width = 0 | u.width, u.height = 0 | u.height;
            var a = o.getCacheContext();
            o.resetCanvasSize(u.width, u.height), a.translate(0 - u.x, u.height + u.y);
            var f = o.getAnchorPointInPoints();
            o.setPosition(f.x + u.x, f.y + u.y), r.sortAllChildren(), cc.view._setScaleXYForRenderTexture();
            for (n = 0; n < s; n++)
                i[n].visit(a);
            cc.view._resetScale(), this._cacheDirty = !1
        }
        o.visit(t), r.arrivalOrder = 0, t.restore()
    }, p._getBoundingBoxForBake = function() {
        var e = null;
        if (!this._children || this._children.length === 0)
            return cc.rect(0, 0, 10, 10);
        var t = this._children;
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            if (r && r._visible)
                if (e) {
                    var i = r._getBoundingBoxToCurrentNode();
                    i && (e = cc.rectUnion(e, i))
                } else
                    e = r._getBoundingBoxToCurrentNode()
        }
        return e
    }, p = null
} else
    cc.assert(cc.isFunction(cc._tmp.LayerDefineForWebGL), cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.LayerDefineForWebGL(), delete cc._tmp.LayerDefineForWebGL;
cc.LayerColor = cc.Layer.extend({
    _blendFunc: null,
    _className: "LayerColor",
    getBlendFunc: function() {
        return this._blendFunc
    },
    changeWidthAndHeight: function(e, t) {
        this.width = e, this.height = t
    },
    changeWidth: function(e) {
        this.width = e
    },
    changeHeight: function(e) {
        this.height = e
    },
    setOpacityModifyRGB: function(e) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    setColor: function(e) {
        cc.Layer.prototype.setColor.call(this, e), this._updateColor()
    },
    setOpacity: function(e) {
        cc.Layer.prototype.setOpacity.call(this, e), this._updateColor()
    },
    _blendFuncStr: "source",
    ctor: null,
    init: function(e, t, n) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
        var r = cc.director.getWinSize();
        e = e || cc.color(0, 0, 0, 255), t = t === undefined ? r.width : t, n = n === undefined ? r.height : n;
        var i = this._displayedColor;
        i.r = e.r, i.g = e.g, i.b = e.b;
        var s = this._realColor;
        s.r = e.r, s.g = e.g, s.b = e.b, this._displayedOpacity = e.a, this._realOpacity = e.a;
        var o = cc.LayerColor.prototype;
        return o.setContentSize.call(this, t, n), o._updateColor.call(this), !0
    },
    setBlendFunc: function(e, t) {
        var n = this,
            r = this._blendFunc;
        t === undefined ? (r.src = e.src, r.dst = e.dst) : (r.src = e, r.dst = t), cc._renderType === cc._RENDER_TYPE_CANVAS && (n._blendFuncStr = cc._getCompositeOperationByBlendFunc(r))
    },
    _setWidth: null,
    _setHeight: null,
    _updateColor: null,
    updateDisplayedColor: function(e) {
        cc.Layer.prototype.updateDisplayedColor.call(this, e), this._updateColor()
    },
    updateDisplayedOpacity: function(e) {
        cc.Layer.prototype.updateDisplayedOpacity.call(this, e), this._updateColor()
    },
    draw: null
}), cc.LayerColor.create = function(e, t, n) {
    return new cc.LayerColor(e, t, n)
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.LayerColor.prototype;
    _p.ctor = function(e, t, n) {
        cc.Layer.prototype.ctor.call(this), this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), cc.LayerColor.prototype.init.call(this, e, t, n)
    }, _p._setWidth = cc.Layer.prototype._setWidth, _p._setHeight = cc.Layer.prototype._setHeight, _p._updateColor = function() {}, _p.draw = function(e) {
        var t = e || cc._renderContext,
            n = this,
            r = cc.view,
            i = n._displayedColor;
        t.fillStyle = "rgba(" + (0 | i.r) + "," + (0 | i.g) + "," + (0 | i.b) + "," + n._displayedOpacity / 255 + ")", t.fillRect(0, 0, n.width * r.getScaleX(), -n.height * r.getScaleY()), cc.g_NumberOfDraws++
    }, _p.visit = function(e) {
        if (!this._isBaked) {
            cc.Node.prototype.visit.call(this, e);
            return
        }
        var t = e || cc._renderContext,
            n, r = this,
            i = r._children,
            s = i.length;
        if (!r._visible)
            return;
        var o = this._bakeSprite;
        t.save(), r.transform(t);
        if (this._cacheDirty) {
            var u = this._getBoundingBoxForBake();
            u.width = 0 | u.width, u.height = 0 | u.height;
            var a = o.getCacheContext();
            o.resetCanvasSize(u.width, u.height);
            var f = o.getAnchorPointInPoints(),
                l = this._position;
            if (this._ignoreAnchorPointForPosition)
                a.translate(0 - u.x + l.x, u.height + u.y - l.y), o.setPosition(f.x + u.x - l.x, f.y + u.y - l.y);
            else {
                var c = this.getAnchorPointInPoints(),
                    h = {
                        x: l.x - c.x,
                        y: l.y - c.y
                    };
                a.translate(0 - u.x + h.x, u.height + u.y - h.y), o.setPosition(f.x + u.x - h.x, f.y + u.y - h.y)
            }
            var p;
            cc.view._setScaleXYForRenderTexture();
            if (s > 0) {
                r.sortAllChildren();
                for (n = 0; n < s; n++) {
                    p = i[n];
                    if (!(p._localZOrder < 0))
                        break;
                    p.visit(a)
                }
                r.draw(a);
                for (; n < s; n++)
                    i[n].visit(a)
            } else
                r.draw(a);
            cc.view._resetScale(), this._cacheDirty = !1
        }
        o.visit(t), r.arrivalOrder = 0, t.restore()
    }, _p._getBoundingBoxForBake = function() {
        var e = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
            t = this.nodeToWorldTransform();
        e = cc.rectApplyAffineTransform(e, this.nodeToWorldTransform());
        if (!this._children || this._children.length === 0)
            return e;
        var n = this._children;
        for (var r = 0; r < n.length; r++) {
            var i = n[r];
            if (i && i._visible) {
                var s = i._getBoundingBoxToCurrentNode(t);
                e = cc.rectUnion(e, s)
            }
        }
        return e
    }, _p = null
} else
    cc.assert(cc.isFunction(cc._tmp.WebGLLayerColor), cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.WebGLLayerColor(), delete cc._tmp.WebGLLayerColor;
cc.assert(cc.isFunction(cc._tmp.PrototypeLayerColor), cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js"), cc._tmp.PrototypeLayerColor(), delete cc._tmp.PrototypeLayerColor, cc.LayerGradient = cc.LayerColor.extend({
    _startColor: null,
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: !1,
    _gradientStartPoint: null,
    _gradientEndPoint: null,
    _className: "LayerGradient",
    ctor: function(e, t, n) {
        var r = this;
        cc.LayerColor.prototype.ctor.call(r), r._startColor = cc.color(0, 0, 0, 255), r._endColor = cc.color(0, 0, 0, 255), r._alongVector = cc.p(0, -1), r._startOpacity = 255, r._endOpacity = 255, r._gradientStartPoint = cc.p(0, 0), r._gradientEndPoint = cc.p(0, 0), cc.LayerGradient.prototype.init.call(r, e, t, n)
    },
    init: function(e, t, n) {
        e = e || cc.color(0, 0, 0, 255), t = t || cc.color(0, 0, 0, 255), n = n || cc.p(0, -1);
        var r = this,
            i = r._startColor,
            s = r._endColor;
        return i.r = e.r, i.g = e.g, i.b = e.b, r._startOpacity = e.a, s.r = t.r, s.g = t.g, s.b = t.b, r._endOpacity = t.a, r._alongVector = n, r._compressedInterpolation = !0, r._gradientStartPoint = cc.p(0, 0), r._gradientEndPoint = cc.p(0, 0), cc.LayerColor.prototype.init.call(r, cc.color(e.r, e.g, e.b, 255)), cc.LayerGradient.prototype._updateColor.call(r), !0
    },
    setContentSize: function(e, t) {
        cc.LayerColor.prototype.setContentSize.call(this, e, t), this._updateColor()
    },
    _setWidth: function(e) {
        cc.LayerColor.prototype._setWidth.call(this, e), this._updateColor()
    },
    _setHeight: function(e) {
        cc.LayerColor.prototype._setHeight.call(this, e), this._updateColor()
    },
    getStartColor: function() {
        return this._realColor
    },
    setStartColor: function(e) {
        this.color = e
    },
    setEndColor: function(e) {
        this._endColor = e, this._updateColor()
    },
    getEndColor: function() {
        return this._endColor
    },
    setStartOpacity: function(e) {
        this._startOpacity = e, this._updateColor()
    },
    getStartOpacity: function() {
        return this._startOpacity
    },
    setEndOpacity: function(e) {
        this._endOpacity = e, this._updateColor()
    },
    getEndOpacity: function() {
        return this._endOpacity
    },
    setVector: function(e) {
        this._alongVector.x = e.x, this._alongVector.y = e.y, this._updateColor()
    },
    getVector: function() {
        return cc.p(this._alongVector.x, this._alongVector.y)
    },
    isCompressedInterpolation: function() {
        return this._compressedInterpolation
    },
    setCompressedInterpolation: function(e) {
        this._compressedInterpolation = e, this._updateColor()
    },
    _draw: null,
    _updateColor: null
}), cc.LayerGradient.create = function(e, t, n) {
    return new cc.LayerGradient(e, t, n)
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.LayerGradient.prototype;
    _p.draw = function(e) {
        var t = e || cc._renderContext,
            n = this;
        n._blendFuncStr != "source" && (t.globalCompositeOperation = n._blendFuncStr), t.save();
        var r = n._displayedOpacity / 255,
            i = cc.view.getScaleX(),
            s = cc.view.getScaleY(),
            o = n.width * i,
            u = n.height * s,
            a = t.createLinearGradient(n._gradientStartPoint.x * i, n._gradientStartPoint
                .y * s, n._gradientEndPoint.x * i, n._gradientEndPoint.y * s),
            f = n._displayedColor,
            l = n._endColor;
        a.addColorStop(0, "rgba(" + Math.round(f.r) + "," + Math.round(f.g) + "," + Math.round(f.b) + "," + (r * (n._startOpacity / 255)).toFixed(4) + ")"), a.addColorStop(1, "rgba(" + Math.round(l.r) + "," + Math.round(l.g) + "," + Math.round(l.b) + "," + (r * (n._endOpacity / 255)).toFixed(4) + ")"), t.fillStyle = a, t.fillRect(0, 0, o, -u), n._rotation != 0 && t.rotate(n._rotationRadians), t.restore(), cc.g_NumberOfDraws++
    }, _p._updateColor = function() {
        var e = this,
            t = e._alongVector,
            n = e.width * .5,
            r = e.height * .5;
        e._gradientStartPoint.x = n * -t.x + n, e._gradientStartPoint.y = r * t.y - r, e._gradientEndPoint.x = n * t.x + n, e._gradientEndPoint.y = r * -t.y - r
    }, _p = null
} else
    cc.assert(cc.isFunction(cc._tmp.WebGLLayerGradient), cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.WebGLLayerGradient(), delete cc._tmp.WebGLLayerGradient;
cc.assert(cc.isFunction(cc._tmp.PrototypeLayerGradient), cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js"), cc._tmp.PrototypeLayerGradient(), delete cc._tmp.PrototypeLayerGradient, cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: 0,
    _layers: null,
    _className: "LayerMultiplex",
    ctor: function(e) {
        cc.Layer.prototype.ctor.call(this), e instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, e) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments))
    },
    initWithLayers: function(e) {
        return e.length > 0 && e[e.length - 1] == null && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers), this._layers = e, this._enabledLayer = 0, this.addChild(this._layers[this._enabledLayer]), !0
    },
    switchTo: function(e) {
        if (e >= this._layers.length) {
            cc.log(cc._LogInfos.LayerMultiplex_switchTo);
            return
        }
        this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = e, this.addChild(this._layers[e])
    },
    switchToAndReleaseMe: function(e) {
        if (e >= this._layers.length) {
            cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe);
            return
        }
        this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = e, this.addChild(this._layers[e])
    },
    addLayer: function(e) {
        if (!e) {
            cc.log(cc._LogInfos.LayerMultiplex_addLayer);
            return
        }
        this._layers.push(e)
    }
}), cc.LayerMultiplex.create = function() {
    return new cc.LayerMultiplex(Array.prototype.slice.call(arguments))
}, cc._tmp.PrototypeSprite = function() {
    var e = cc.Sprite.prototype;
    cc.defineGetterSetter(e, "opacityModifyRGB", e.isOpacityModifyRGB, e.setOpacityModifyRGB), cc.defineGetterSetter(e, "opacity", e.getOpacity, e.setOpacity), cc.defineGetterSetter(e, "color", e.getColor, e.setColor), e.dirty, e.flippedX, cc.defineGetterSetter(e, "flippedX", e.isFlippedX, e.setFlippedX), e.flippedY, cc.defineGetterSetter(e, "flippedY", e.isFlippedY, e.setFlippedY), e.offsetX, cc.defineGetterSetter(e, "offsetX", e._getOffsetX), e.offsetY, cc.defineGetterSetter(e, "offsetY", e._getOffsetY), e.atlasIndex, e.texture, cc.defineGetterSetter(e, "texture", e.getTexture, e.setTexture), e.textureRectRotated, cc.defineGetterSetter(e, "textureRectRotated", e.isTextureRectRotated), e.textureAtlas, e.batchNode, cc.defineGetterSetter(e, "batchNode", e.getBatchNode, e.setBatchNode), e.quad, cc.defineGetterSetter(e, "quad", e.getQuad)
}, cc.generateTintImageWithMultiply = function(e, t, n, r) {
    r = r || cc.newElement("canvas"), n = n || cc.rect(0, 0, e.width, e.height);
    var i = r.getContext("2d");
    return r.width != n.width || r.height != n.height ? (r.width = n.width, r.height = n.height) : i.globalCompositeOperation = "source-over", i.fillStyle = "rgb(" + (0 | t.r) + "," + (0 | t.g) + "," + (0 | t.b) + ")", i.fillRect(0, 0, n.width, n.height), i.globalCompositeOperation = "multiply", i.drawImage(e, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), i.globalCompositeOperation = "destination-atop", i.drawImage(e, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), r
}, cc.generateTintImage = function(e, t, n, r, i) {
    r || (r = cc.rect(0, 0, e.width, e.height));
    var s = n.r / 255,
        o = n.g / 255,
        u = n.b / 255,
        a = Math.min(r.width, t[0].width),
        f = Math.min(r.height, t[0].height),
        l = i,
        c;
    l ? (c = l.getContext("2d"), c.clearRect(0, 0, a, f)) : (l = cc.newElement("canvas"), l.width = a, l.height = f, c = l.getContext("2d")), c.save(), c.globalCompositeOperation = "lighter";
    var h = c.globalAlpha;
    return s > 0 && (c.globalAlpha = s * h, c.drawImage(t[0], r.x, r.y, a, f, 0, 0, a, f)), o > 0 && (c.globalAlpha = o * h, c.drawImage(t[1], r.x, r.y, a, f, 0, 0, a, f)), u > 0 && (c.globalAlpha = u * h, c.drawImage(t[2], r.x, r.y, a, f, 0, 0, a, f)), s + o + u < 1 && (c.globalAlpha = h, c.drawImage(t[3], r.x, r.y, a, f, 0, 0, a, f)), c.restore(), l
}, cc.generateTextureCacheForColor = function(e) {
    function n() {
        var n = cc.generateTextureCacheForColor,
            r = e.width,
            i = e.height;
        t[0].width = r, t[0].height = i, t[1].width = r, t[1].height = i, t[2].width = r, t[2].height = i, t[3].width = r, t[3].height = i, n.canvas.width = r, n.canvas.height = i;
        var s = n.canvas.getContext("2d");
        s.drawImage(e, 0, 0), n.tempCanvas.width = r, n.tempCanvas.height = i;
        var o = s.getImageData(0, 0, r, i).data;
        for (var u = 0; u < 4; u++) {
            var a = t[u].getContext("2d");
            a.getImageData(0, 0, r, i).data, n.tempCtx.drawImage(e, 0, 0);
            var f = n.tempCtx.getImageData(0, 0, r, i),
                l = f.data;
            for (var c = 0; c < o.length; c += 4)
                l[c] = u === 0 ? o[c] : 0, l[c + 1] = u === 1 ? o[c + 1] : 0, l[c + 2] = u === 2 ? o[c + 2] : 0, l[c + 3] = o[c + 3];
            a.putImageData(f, 0, 0)
        }
        e.onload = null
    }
    if (e.channelCache)
        return e.channelCache;
    var t = [cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas")];
    try {
        n()
    } catch (r) {
        e.onload = n
    }
    return e.channelCache = t, t
}, cc.generateTextureCacheForColor.canvas = cc.newElement("canvas"), cc.generateTextureCacheForColor.tempCanvas = cc.newElement("canvas"), cc.generateTextureCacheForColor.tempCtx = cc.generateTextureCacheForColor.tempCanvas.getContext("2d"), cc.cutRotateImageToCanvas = function(e, t) {
    if (!e)
        return null;
    if (!t)
        return e;
    var n = cc.newElement("canvas");
    n.width = t.width, n.height = t.height;
    var r = n.getContext("2d");
    return r.translate(n.width / 2, n.height / 2), r.rotate(-1.5707963267948966), r.drawImage(e, t.x, t.y, t.height, t.width, -t.height / 2, -t.width / 2, t.height, t.width), n
}, cc._getCompositeOperationByBlendFunc = function(e) {
    return e ? e.src == cc.SRC_ALPHA && e.dst == cc.ONE || e.src == cc.ONE && e.dst == cc.ONE ? "lighter" : e.src == cc.ZERO && e.dst == cc.SRC_ALPHA ? "destination-in" : e.src == cc.ZERO && e.dst == cc.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source" : "source"
}, cc.Sprite = cc.Node.extend({
    dirty: !1,
    atlasIndex: 0,
    textureAtlas: null,
    _batchNode: null,
    _recursiveDirty: null,
    _hasChildren: null,
    _shouldBeHidden: !1,
    _transformToBatch: null,
    _blendFunc: null,
    _texture: null,
    _rect: null,
    _rectRotated: !1,
    _offsetPosition: null,
    _unflippedOffsetPositionFromCenter: null,
    _opacityModifyRGB: !1,
    _flippedX: !1,
    _flippedY: !1,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _newTextureWhenChangeColor: null,
    _className: "Sprite",
    _oldDisplayColor: cc.color.WHITE,
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(e, t) {
        this._loadedEventListeners || (this._loadedEventListeners = []), this._loadedEventListeners.push({
            eventCallback: e,
            eventTarget: t
        })
    },
    _callLoadedEventCallbacks: function() {
        if (!this._loadedEventListeners)
            return;
        var e = this._loadedEventListeners;
        for (var t = 0, n = e.length; t < n; t++) {
            var r = e[t];
            r.eventCallback.call(r.eventTarget, this)
        }
        e.length = 0
    },
    isDirty: function() {
        return this.dirty
    },
    setDirty: function(e) {
        this.dirty = e
    },
    isTextureRectRotated: function() {
        return this._rectRotated
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(e) {
        this.atlasIndex = e
    },
    getTextureRect: function() {
        return cc.rect(this._rect.x, this._rect.y, this._rect.width, this._rect.height)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(e) {
        this.textureAtlas = e
    },
    getOffsetPosition: function() {
        return cc.p(this._offsetPosition)
    },
    _getOffsetX: function() {
        return this._offsetPosition.x
    },
    _getOffsetY: function() {
        return this._offsetPosition.y
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    initWithSpriteFrame: function(e) {
        cc.assert(e, cc._LogInfos.Sprite_initWithSpriteFrame), e.textureLoaded() || (this._textureLoaded = !1, e.addLoadedEventListener(this._spriteFrameLoadedCallback, this));
        var t = cc._renderType === cc._RENDER_TYPE_CANVAS ? !1 : e._rotated,
            n = this.initWithTexture(e.getTexture(), e.getRect(), t);
        return this.setSpriteFrame(e), n
    },
    _spriteFrameLoadedCallback: null,
    initWithSpriteFrameName: function(e) {
        cc.assert(e, cc._LogInfos.Sprite_initWithSpriteFrameName);
        var t = cc.spriteFrameCache.getSpriteFrame(e);
        return cc.assert(t, e + cc._LogInfos.Sprite_initWithSpriteFrameName1), this.initWithSpriteFrame(t)
    },
    useBatchNode: function(e) {
        this.textureAtlas = e.textureAtlas, this._batchNode = e
    },
    setVertexRect: function(e) {
        this._rect.x = e.x, this._rect.y = e.y, this._rect.width = e.width, this._rect.height = e.height
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var e = this._children,
                t = e.length,
                n, r, i;
            for (n = 1; n < t; n++) {
                i = e[n], r = n - 1;
                while (r >= 0) {
                    if (i._localZOrder < e[r]._localZOrder)
                        e[r + 1] = e[r];
                    else {
                        if (!(i._localZOrder === e[r]._localZOrder && i.arrivalOrder < e[r].arrivalOrder))
                            break;
                        e[r + 1] = e[r]
                    }
                    r--
                }
                e[r + 1] = i
            }
            this._batchNode && this._arrayMakeObjectsPerformSelector(e, cc.Node._StateCallbackType.sortAllChildren), this._reorderChildDirty = !1
        }
    },
    reorderChild: function(e, t) {
        cc.assert(e, cc._LogInfos.Sprite_reorderChild_2);
        if (this._children.indexOf(e) === -1) {
            cc.log(cc._LogInfos.Sprite_reorderChild);
            return
        }
        if (t === e.zIndex)
            return;
        this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, e, t)
    },
    removeChild: function(e, t) {
        this._batchNode && this._batchNode.removeSpriteFromAtlas(e), cc.Node.prototype.removeChild.call(this, e, t)
    },
    setVisible: function(e) {
        cc.Node.prototype.setVisible.call(this, e), this.setDirtyRecursively(!0)
    },
    removeAllChildren: function(e) {
        var t = this._children,
            n = this._batchNode;
        if (n && t != null)
            for (var r = 0, i = t.length; r < i; r++)
                n.removeSpriteFromAtlas(t[r]);
        cc.Node.prototype.removeAllChildren.call(this, e), this._hasChildren = !1
    },
    setDirtyRecursively: function(e) {
        this._recursiveDirty = e, this.dirty = e;
        var t = this._children,
            n, r = t ? t.length : 0;
        for (var i = 0; i < r; i++)
            n = t[i], n instanceof cc.Sprite && n.setDirtyRecursively(!0)
    },
    setNodeDirty: function(e) {
        cc.Node.prototype.setNodeDirty.call(this), !e && this._batchNode && !this._recursiveDirty && (this._hasChildren ? this.setDirtyRecursively(!0) : (this._recursiveDirty = !0, this.dirty = !0))
    },
    ignoreAnchorPointForPosition: function(e) {
        if (this._batchNode) {
            cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition);
            return
        }
        cc.Node.prototype.ignoreAnchorPointForPosition.call(this, e)
    },
    setFlippedX: function(e) {
        this._flippedX != e && (this._flippedX = e, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    setFlippedY: function(e) {
        this._flippedY != e && (this._flippedY = e, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    isFlippedX: function() {
        return this._flippedX
    },
    isFlippedY: function() {
        return this._flippedY
    },
    setOpacityModifyRGB: null,
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    updateDisplayedOpacity: null,
    setDisplayFrameWithAnimationName: function(e, t) {
        cc.assert(e, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
        var n = cc.animationCache.getAnimation(e);
        if (!n) {
            cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName);
            return
        }
        var r = n.getFrames()[t];
        if (!r) {
            cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2);
            return
        }
        this.setSpriteFrame(r.getSpriteFrame())
    },
    getBatchNode: function() {
        return this._batchNode
    },
    _setReorderChildDirtyRecursively: function() {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = !0;
            var e = this._parent;
            while (e && e != this._batchNode)
                e._setReorderChildDirtyRecursively(), e = e.parent
        }
    },
    getTexture: function() {
        return this._texture
    },
    _quad: null,
    _quadWebBuffer: null,
    _quadDirty: !1,
    _colorized: !1,
    _blendFuncStr: "source",
    _originalTexture: null,
    _textureRect_Canvas: null,
    _drawSize_Canvas: null,
    ctor: null,
    _softInit: function(e, t, n) {
        if (e === undefined)
            cc.Sprite.prototype.init.call(this);
        else if (cc.isString(e))
            if (e[0] === "#") {
                var r = e.substr(1, e.length - 1),
                    i = cc.spriteFrameCache.getSpriteFrame(r);
                this.initWithSpriteFrame(i)
            } else
                cc.Sprite.prototype.init.call(this, e, t);
        else if (cc.isObject(e))
            if (e instanceof cc.Texture2D)
                this.initWithTexture(e, t, n);
            else if (e instanceof cc.SpriteFrame)
            this.initWithSpriteFrame(e);
        else if (e instanceof HTMLImageElement || e instanceof HTMLCanvasElement) {
            var s = new cc.Texture2D;
            s.initWithElement(e), s.handleLoadedTexture(), this.initWithTexture(s)
        }
    },
    getQuad: function() {
        return this._quad
    },
    setBlendFunc: null,
    init: null,
    initWithFile: function(e, t) {
        cc.assert(e, cc._LogInfos.Sprite_initWithFile);
        var n = cc.textureCache.getTextureForKey(e);
        if (!n)
            return n = cc.textureCache.addImage(e), this.initWithTexture(n, t || cc.rect(0, 0, n._contentSize.width, n._contentSize.height));
        if (!t) {
            var r = n.getContentSize();
            t = cc.rect(0, 0, r.width, r.height)
        }
        return this.initWithTexture(n, t)
    },
    initWithTexture: null,
    _textureLoadedCallback: null,
    setTextureRect: null,
    updateTransform: null,
    addChild: null,
    updateColor: function() {
        var e = this._displayedColor,
            t = this._displayedOpacity,
            n = {
                r: e.r,
                g: e.g,
                b: e.b,
                a: t
            };
        this._opacityModifyRGB && (n.r *= t / 255, n.g *= t / 255, n.b *= t / 255);
        var r = this._quad;
        r.bl.colors = n, r.br.colors = n, r.tl.colors = n, r.tr.colors = n, this._batchNode && (this.atlasIndex != cc.Sprite.INDEX_NOT_INITIALIZED ? this.textureAtlas.updateQuad(r, this.atlasIndex) : this.dirty = !0), this._quadDirty = !0
    },
    setOpacity: null,
    setColor: null,
    updateDisplayedColor: null,
    setSpriteFrame: null,
    setDisplayFrame: function(e) {
        cc.log(cc._LogInfos.Sprite_setDisplayFrame), this.setSpriteFrame(e)
    },
    isFrameDisplayed: null,
    displayFrame: function() {
        return cc.SpriteFrame.create(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter), cc.sizePointsToPixels(this._contentSize))
    },
    setBatchNode: null,
    setTexture: null,
    _updateBlendFunc: function() {
        if (this._batchNode) {
            cc.log(cc._LogInfos.Sprite__updateBlendFunc);
            return
        }!this._texture || !this._texture.hasPremultipliedAlpha() ? (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, this.opacityModifyRGB = !1) : (this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this.opacityModifyRGB = !0)
    },
    _changeTextureColor: function() {
        var e, t = this._texture,
            n = this._textureRect_Canvas;
        if (t && n.validRect && this._originalTexture) {
            e = t.getHtmlElementObj();
            if (!e)
                return;
            this._colorized = !0, e instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor && this._originalTexture._htmlElementObj != e ? cc.generateTintImageWithMultiply(this._originalTexture._htmlElementObj, this._displayedColor, n, e) : (e = cc.generateTintImageWithMultiply(this._originalTexture._htmlElementObj, this._displayedColor, n), t = new cc.Texture2D, t.initWithElement(e), t.handleLoadedTexture(), this.texture = t)
        }
    },
    _setTextureCoords: function(e) {
        e = cc.rectPointsToPixels(e);
        var t = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (!t)
            return;
        var n = t.pixelsWidth,
            r = t.pixelsHeight,
            i, s, o, u, a, f = this._quad;
        this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (i = (2 * e.x + 1) / (2 * n), s = i + (e.height * 2 - 2) / (2 * n), o = (2 * e.y + 1) / (2 * r), u = o + (e.width * 2 - 2) / (2 * r)) : (i = e.x / n, s = (e.x + e.height) / n, o = e.y / r, u = (e.y + e.width) / r), this._flippedX && (a = o, o = u, u = a), this._flippedY && (a = i, i = s, s = a), f.bl.texCoords.u = i, f.bl.texCoords.v = o, f.br.texCoords.u = i, f.br.texCoords.v = u, f.tl.texCoords.u = s, f.tl.texCoords.v = o, f.tr.texCoords.u = s, f.tr.texCoords.v = u) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (i = (2 * e.x + 1) / (2 * n), s = i + (e.width * 2 - 2) / (2 * n), o = (2 * e.y + 1) / (2 * r), u = o + (e.height * 2 - 2) / (2 * r)) : (i = e.x / n, s = (e.x + e.width) / n, o = e.y / r, u = (e.y + e.height) / r), this._flippedX && (a = i, i = s, s = a), this._flippedY && (a = o, o = u, u = a), f.bl.texCoords.u = i, f.bl.texCoords.v = u, f.br.texCoords.u = s, f.br.texCoords.v = u, f.tl.texCoords.u = i, f.tl.texCoords.v = o, f.tr.texCoords.u = s, f.tr.texCoords.v = o), this._quadDirty = !0
    },
    draw: null
}), cc.Sprite.create = function(e, t, n) {
    return new cc.Sprite(e, t, n)
}, cc.Sprite.createWithTexture = cc.Sprite.create, cc.Sprite.createWithSpriteFrameName = cc.Sprite.create, cc.Sprite.createWithSpriteFrame = cc.Sprite.create, cc.Sprite.INDEX_NOT_INITIALIZED = -1;
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.Sprite.prototype;
    _p._spriteFrameLoadedCallback = function(e) {
        var t = this;
        t.setNodeDirty(!0), t.setTextureRect(e.getRect(), e.isRotated(), e.getOriginalSize());
        var n = t.color;
        (n.r !== 255 || n.g !== 255 || n.b !== 255) && t._changeTextureColor(), t._callLoadedEventCallbacks()
    }, _p.setOpacityModifyRGB = function(e) {
        this._opacityModifyRGB !== e && (this._opacityModifyRGB = e, this.setNodeDirty(!0))
    }, _p.updateDisplayedOpacity = function(e) {
        cc.Node.prototype.updateDisplayedOpacity.call(this, e), this._setNodeDirtyForCache()
    }, _p.ctor = function(e, t, n) {
        var r = this;
        cc.Node.prototype.ctor.call(r), r._shouldBeHidden = !1, r._offsetPosition = cc.p(0, 0), r._unflippedOffsetPositionFromCenter = cc.p(0, 0), r._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        }, r._rect = cc.rect(0, 0, 0, 0), r._newTextureWhenChangeColor = !1, r._textureLoaded = !0, r._textureRect_Canvas = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            validRect: !1
        }, r._drawSize_Canvas = cc.size(0, 0), r._softInit(e, t, n)
    }, _p.setBlendFunc = function(e, t) {
        var n = this,
            r = this._blendFunc;
        t === undefined ? (r.src = e.src, r.dst = e.dst) : (r.src = e, r.dst = t), cc._renderType === cc._RENDER_TYPE_CANVAS && (n._blendFuncStr = cc._getCompositeOperationByBlendFunc(r))
    }, _p.init = function() {
        var e = this;
        return arguments.length > 0 ? e.initWithFile(arguments[0], arguments[1]) : (cc.Node.prototype.init.call(e), e.dirty = e._recursiveDirty = !1, e._opacityModifyRGB = !0, e._blendFunc.src = cc.BLEND_SRC, e._blendFunc.dst = cc.BLEND_DST, e.texture = null, e._textureLoaded = !0, e._flippedX = e._flippedY = !1, e.anchorX = .5, e.anchorY = .5, e._offsetPosition.x = 0, e._offsetPosition.y = 0, e._hasChildren = !1, e.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0)), !0)
    }, _p.initWithTexture = function(e, t, n) {
        var r = this;
        cc.assert(arguments.length != 0, cc._LogInfos.CCSpriteBatchNode_initWithTexture), n = n || !1;
        if (n && e.isLoaded()) {
            var i = e.getHtmlElementObj();
            i = cc.cutRotateImageToCanvas(i, t);
            var s = new cc.Texture2D;
            s.initWithElement(i), s.handleLoadedTexture(), e = s, r._rect = cc.rect(0, 0, t.width, t.height)
        }
        if (!cc.Node.prototype.init.call(r))
            return !1;
        r._batchNode = null, r._recursiveDirty = !1, r.dirty = !1, r._opacityModifyRGB = !0, r._blendFunc.src = cc.BLEND_SRC, r._blendFunc.dst = cc.BLEND_DST, r._flippedX = r._flippedY = !1, r.anchorX = .5, r.anchorY = .5, r._offsetPosition.x = 0, r._offsetPosition.y = 0, r._hasChildren = !1;
        var o = e.isLoaded();
        r._textureLoaded = o;
        if (!o)
            return r._rectRotated = n, t && (r._rect.x = t.x, r._rect.y = t.y, r._rect.width = t.width, r._rect.height = t.height), r.texture && r.texture.removeLoadedEventListener(r), e.addLoadedEventListener(r._textureLoadedCallback, r), r.texture = e, !0;
        t || (t = cc.rect(0, 0, e.width, e.height));
        if (e && e.url) {
            var u = t.x + t.width,
                a = t.y + t.height;
            u > e.width && cc.error(cc._LogInfos.RectWidth, e.url), a > e.height && cc.error(cc._LogInfos.RectHeight, e.url)
        }
        return r._originalTexture = e, r.texture = e, r.setTextureRect(t, n), r.batchNode = null, !0
    }, _p._textureLoadedCallback = function(e) {
        var t = this;
        if (t._textureLoaded)
            return;
        t._textureLoaded = !0;
        var n = t._rect;
        n ? cc._rectEqualToZero(n) && (n.width = e.width, n.height = e.height) : n = cc.rect(0, 0, e.width, e.height), t._originalTexture = e, t.texture = e, t.setTextureRect(n, t._rectRotated);
        var r = this._displayedColor;
        (r.r != 255 || r.g != 255 || r.b != 255) && t._changeTextureColor(), t.batchNode = t._batchNode, t._callLoadedEventCallbacks()
    }, _p.setTextureRect = function(e, t, n) {
        var r = this;
        r._rectRotated = t || !1, r.setContentSize(n || e), r.setVertexRect(e);
        var i = r._textureRect_Canvas,
            s = cc.contentScaleFactor();
        i.x = 0 | e.x * s, i.y = 0 | e.y * s, i.width = 0 | e.width * s, i.height = 0 | e.height * s, i.validRect = !(i.width === 0 || i.height === 0 || i.x < 0 || i.y < 0);
        var o = r._unflippedOffsetPositionFromCenter;
        r._flippedX && (o.x = -o.x), r._flippedY && (o.y = -o.y), r._offsetPosition.x = o.x + (r._contentSize.width - r._rect.width) / 2, r._offsetPosition.y = o.y + (r._contentSize.height - r._rect.height) / 2, r._batchNode && (r.dirty = !0)
    }, _p.updateTransform = function() {
        var e = this;
        if (e.dirty) {
            var t = e._parent;
            !e._visible || t && t != e._batchNode && t._shouldBeHidden ? e._shouldBeHidden = !0 : (e._shouldBeHidden = !1, !t || t == e._batchNode ? e._transformToBatch = e.nodeToParentTransform() : e._transformToBatch = cc.affineTransformConcat(e.nodeToParentTransform(), t._transformToBatch)), e._recursiveDirty = !1, e.dirty = !1
        }
        e._hasChildren && e._arrayMakeObjectsPerformSelector(e._children, cc.Node._StateCallbackType.updateTransform)
    }, _p.addChild = function(e, t, n) {
        cc.assert(e, cc._LogInfos.CCSpriteBatchNode_addChild_2), t == null && (t = e._localZOrder), n == null && (n = e.tag), cc.Node.prototype.addChild.call(this, e, t, n), this._hasChildren = !0
    }, _p.setOpacity = function(e) {
        cc.Node.prototype.setOpacity.call(this, e), this._setNodeDirtyForCache()
    }, _p.setColor = function(e) {
        var t = this,
            n = t.color;
        this._oldDisplayColor = n;
        if (n.r === e.r && n.g === e.g && n.b === e.b)
            return;
        cc.Node.prototype.setColor.call(t, e)
    }, _p.updateDisplayedColor = function(e) {
        var t = this;
        cc.Node.prototype.updateDisplayedColor.call(t, e);
        var n = t._oldDisplayColor,
            r = t._displayedColor;
        if (n.r === r.r && n.g === r.g && n.b === r.b)
            return;
        t._changeTextureColor(), t._setNodeDirtyForCache()
    }, _p.setSpriteFrame = function(e) {
        var t = this;
        cc.isString(e) && (e = cc.spriteFrameCache.getSpriteFrame(e), cc.assert(e, cc._LogInfos.CCSpriteBatchNode_setSpriteFrame)), t.setNodeDirty(!0);
        var n = e.getOffset();
        t._unflippedOffsetPositionFromCenter.x = n.x, t._unflippedOffsetPositionFromCenter.y = n.y, t._rectRotated = e.isRotated();
        var r = e.getTexture(),
            i = e.textureLoaded();
        i || (t._textureLoaded = !1, e.addLoadedEventListener(function(e) {
            t._textureLoaded = !0;
            var n = e.getTexture();
            n != t._texture && (t.texture = n), t.setTextureRect(e.getRect(), e.isRotated(), e.getOriginalSize()), t._callLoadedEventCallbacks()
        }, t)), r != t._texture && (t.texture = r), t._rectRotated && (t._originalTexture = r), t.setTextureRect(e.getRect(), t._rectRotated, e.getOriginalSize()), t._colorized = !1;
        if (i) {
            var s = t.color;
            (s.r !== 255 || s.g !== 255 || s.b !== 255) && t._changeTextureColor()
        }
    }, _p.isFrameDisplayed = function(e) {
        return e.getTexture() != this._texture ? !1 : cc.rectEqualToRect(e.getRect(), this._rect)
    }, _p.setBatchNode = function(e) {
        var t = this;
        t._batchNode = e, t._batchNode ? (t._transformToBatch = cc.affineTransformIdentity(), t.textureAtlas = t._batchNode.textureAtlas) : (t.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, t.textureAtlas = null, t._recursiveDirty = !1, t.dirty = !1)
    }, _p.setTexture = function(e) {
        var t = this;
        if (e && cc.isString(e)) {
            e = cc.textureCache.addImage(e), t.setTexture(e);
            var n = e.getContentSize();
            t.setTextureRect(cc.rect(0, 0, n.width, n.height));
            return
        }
        cc.assert(!e || e instanceof cc.Texture2D, cc._LogInfos.CCSpriteBatchNode_setTexture), t._texture != e && (e && e.getHtmlElementObj() instanceof HTMLImageElement && (t._originalTexture = e), t._texture = e)
    }, _p.draw = function(e) {
        var t = this;
        if (!t._textureLoaded)
            return;
        var n = e || cc._renderContext;
        t._blendFuncStr != "source" && (n.globalCompositeOperation = t._blendFuncStr);
        var r = cc.view.getScaleX(),
            i = cc.view.getScaleY();
        n.globalAlpha = t._displayedOpacity / 255;
        var s = t._rect,
            o = t._contentSize,
            u = t._offsetPosition,
            a = t._drawSize_Canvas,
            f = 0 | u.x,
            l = -u.y - s.height,
            c = t._textureRect_Canvas;
        a.width = s.width * r, a.height = s.height * i;
        if (t._flippedX || t._flippedY)
            n.save(), t._flippedX && (f = -u.x - s.width, n.scale(-1, 1)), t._flippedY && (l = u.y, n.scale(1, -1));
        f *= r, l *= i;
        if (t._texture && c.validRect) {
            var h = t._texture.getHtmlElementObj();
            t._colorized ? n.drawImage(h, 0, 0, c.width, c.height, f, l, a.width, a.height) : n.drawImage(h, c.x, c.y, c.width, c.height, f, l, a.width, a.height)
        } else if (!t._texture && c.validRect) {
            var p = t.color;
            n.fillStyle = "rgba(" + p.r + "," + p.g + "," + p.b + ",1)", n.fillRect(f, l, o.width * r, o.height * i)
        }
        if (cc.SPRITE_DEBUG_DRAW === 1 || t._showNode) {
            n.strokeStyle = "rgba(0,255,0,1)", f /= r, l /= i, l = -l;
            var d = [cc.p(f, l), cc.p(f + s.width, l), cc.p(f + s.width, l - s.height), cc.p(f, l - s.height)];
            cc._drawingUtil.drawPoly(d, 4, !0)
        } else if (cc.SPRITE_DEBUG_DRAW === 2) {
            n.strokeStyle = "rgba(0,255,0,1)";
            var v = t._rect;
            l = -l;
            var m = [cc.p(f, l), cc.p(f + v.width, l), cc.p(f + v.width, l - v.height), cc.p(f, l - v.height)];
            cc._drawingUtil.drawPoly(m, 4, !0)
        }
        (t._flippedX || t._flippedY) && n.restore(), cc.g_NumberOfDraws++
    }, cc.sys._supportCanvasNewBlendModes || (_p._changeTextureColor = function() {
        var e, t = this._texture,
            n = this._textureRect_Canvas;
        if (t && n.validRect && this._originalTexture) {
            e = t.getHtmlElementObj();
            if (!e)
                return;
            var r = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj());
            r && (this._colorized = !0, e instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.generateTintImage(e, r, this._displayedColor, n, e) : (e = cc.generateTintImage(e, r, this._displayedColor, n), t = new cc.Texture2D, t.initWithElement(e), t.handleLoadedTexture(), this.texture = t))
        }
    }), delete _p
} else
    cc.assert(cc.isFunction(cc._tmp.WebGLSprite), cc._LogInfos.MissingFile, "SpritesWebGL.js"), cc._tmp.WebGLSprite(), delete cc._tmp.WebGLSprite;
cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js"), cc._tmp.PrototypeSprite(), delete cc._tmp.PrototypeSprite, cc.BakeSprite = cc.Sprite.extend({
    _cacheCanvas: null,
    _cacheContext: null,
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this);
        var e = document.createElement("canvas");
        e.width = e.height = 10, this._cacheCanvas = e, this._cacheContext = e.getContext("2d");
        var t = new cc.Texture2D;
        t.initWithElement(e), t.handleLoadedTexture(), this.setTexture(t)
    },
    getCacheContext: function() {
        return this._cacheContext
    },
    getCacheCanvas: function() {
        return this._cacheCanvas
    },
    resetCanvasSize: function(e, t) {
        t === undefined && (t = e.height, e = e.width);
        var n = this._cacheCanvas;
        n.width = e, n.height = t, this.getTexture().handleLoadedTexture(), this.setTextureRect(cc.rect(0, 0, e, t), !1)
    }
}), cc.AnimationFrame = cc.Class.extend({
    _spriteFrame: null,
    _delayPerUnit: 0,
    _userInfo: null,
    ctor: function(e, t, n) {
        this._spriteFrame = e || null, this._delayPerUnit = t || 0, this._userInfo = n || null
    },
    clone: function() {
        var e = new cc.AnimationFrame;
        return e.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo), e
    },
    copyWithZone: function(e) {
        return cc.clone(this)
    },
    copy: function(e) {
        var t = new cc.AnimationFrame;
        return t.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo), t
    },
    initWithSpriteFrame: function(e, t, n) {
        return this._spriteFrame = e, this._delayPerUnit = t, this._userInfo = n, !0
    },
    getSpriteFrame: function() {
        return this._spriteFrame
    },
    setSpriteFrame: function(e) {
        this._spriteFrame = e
    },
    getDelayUnits: function() {
        return this._delayPerUnit
    },
    setDelayUnits: function(e) {
        this._delayPerUnit = e
    },
    getUserInfo: function() {
        return this._userInfo
    },
    setUserInfo: function(e) {
        this._userInfo = e
    }
}), cc.AnimationFrame.create = function(e, t, n) {
    return new cc.AnimationFrame(e, t, n)
}, cc.Animation = cc.Class.extend({
    _frames: null,
    _loops: 0,
    _restoreOriginalFrame: !1,
    _duration: 0,
    _delayPerUnit: 0,
    _totalDelayUnits: 0,
    ctor: function(e, t, n) {
        this._frames = [];
        if (e === undefined)
            this.initWithSpriteFrames(null, 0);
        else {
            var r = e[0];
            r && (r instanceof cc.SpriteFrame ? this.initWithSpriteFrames(e, t, n) : r instanceof cc.AnimationFrame && this.initWithAnimationFrames(e, t, n))
        }
    },
    getFrames: function() {
        return this._frames
    },
    setFrames: function(e) {
        this._frames = e
    },
    addSpriteFrame: function(e) {
        var t = new cc.AnimationFrame;
        t.initWithSpriteFrame(e, 1, null), this._frames.push(t), this._totalDelayUnits++
    },
    addSpriteFrameWithFile: function(e) {
        var t = cc.textureCache.addImage(e),
            n = cc.rect(0, 0, 0, 0);
        n.width = t.width, n.height = t.height;
        var r = cc.SpriteFrame.create(t, n);
        this.addSpriteFrame(r)
    },
    addSpriteFrameWithTexture: function(e, t) {
        var n = cc.SpriteFrame.create(e, t);
        this.addSpriteFrame(n)
    },
    initWithAnimationFrames: function(e, t, n) {
        cc.arrayVerifyType(e, cc.AnimationFrame), this._delayPerUnit = t, this._loops = n === undefined ? 1 : n, this._totalDelayUnits = 0;
        var r = this._frames;
        r.length = 0;
        for (var i = 0; i < e.length; i++) {
            var s = e[i];
            r.push(s), this._totalDelayUnits += s.getDelayUnits()
        }
        return !0
    },
    clone: function() {
        var e = new cc.Animation;
        return e.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops), e.setRestoreOriginalFrame(this._restoreOriginalFrame), e
    },
    copyWithZone: function(e) {
        var t = new cc.Animation;
        return t.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops), t.setRestoreOriginalFrame(this._restoreOriginalFrame), t
    },
    _copyFrames: function() {
        var e = [];
        for (var t = 0; t < this._frames.length; t++)
            e.push(this._frames[t].clone());
        return e
    },
    copy: function(e) {
        return this.copyWithZone(null)
    },
    getLoops: function() {
        return this._loops
    },
    setLoops: function(e) {
        this._loops = e
    },
    setRestoreOriginalFrame: function(e) {
        this._restoreOriginalFrame = e
    },
    getRestoreOriginalFrame: function() {
        return this._restoreOriginalFrame
    },
    getDuration: function() {
        return this._totalDelayUnits * this._delayPerUnit
    },
    getDelayPerUnit: function() {
        return this._delayPerUnit
    },
    setDelayPerUnit: function(e) {
        this._delayPerUnit = e
    },
    getTotalDelayUnits: function() {
        return this._totalDelayUnits
    },
    initWithSpriteFrames: function(e, t, n) {
        cc.arrayVerifyType(e, cc.SpriteFrame), this._loops = n === undefined ? 1 : n, this._delayPerUnit = t || 0, this._totalDelayUnits = 0;
        var r = this._frames;
        r.length = 0;
        if (e) {
            for (var i = 0; i < e.length; i++) {
                var s = e[i],
                    o = new cc.AnimationFrame;
                o.initWithSpriteFrame(s, 1, null), r.push(o)
            }
            this._totalDelayUnits += e.length
        }
        return !0
    },
    retain: function() {},
    release: function() {}
}), cc.Animation.create = function(e, t, n) {
    return new cc.Animation(e, t, n)
}, cc.Animation.createWithAnimationFrames = cc.Animation.create, cc.animationCache = {
    _animations: {},
    addAnimation: function(e, t) {
        this._animations[t] = e
    },
    removeAnimation: function(e) {
        if (!e)
            return;
        this._animations[e] && delete this._animations[e]
    },
    getAnimation: function(e) {
        return this._animations[e] ? this._animations[e] : null
    },
    _addAnimationsWithDictionary: function(e, t) {
        var n = e.animations;
        if (!n) {
            cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary);
            return
        }
        var r = 1,
            i = e.properties;
        if (i) {
            r = i["format"] != null ? parseInt(i.format) : r;
            var s = i.spritesheets,
                o = cc.spriteFrameCache,
                u = cc.path;
            for (var a = 0; a < s.length; a++)
                o.addSpriteFrames(u.changeBasename(t, s[a]))
        }
        switch (r) {
            case 1:
                this._parseVersion1(n);
                break;
            case 2:
                this._parseVersion2(n);
                break;
            default:
                cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
        }
    },
    addAnimations: function(e) {
        cc.assert(e, cc._LogInfos.animationCache_addAnimations_2);
        var t = cc.loader.getRes(e);
        if (!t) {
            cc.log(cc._LogInfos.animationCache_addAnimations);
            return
        }
        this._addAnimationsWithDictionary(t, e)
    },
    _parseVersion1: function(e) {
        var t = cc.spriteFrameCache;
        for (var n in e) {
            var r = e[n],
                i = r.frames,
                s = parseFloat(r.delay) || 0,
                o = null;
            if (!i) {
                cc.log(cc._LogInfos.animationCache__parseVersion1, n);
                continue
            }
            var u = [];
            for (var a = 0; a < i.length; a++) {
                var f = t.getSpriteFrame(i[a]);
                if (!f) {
                    cc.log(cc._LogInfos.animationCache__parseVersion1_2, n, i[a]);
                    continue
                }
                var l = new cc.AnimationFrame;
                l.initWithSpriteFrame(f, 1, null), u.push(l)
            }
            if (u.length === 0) {
                cc.log(cc._LogInfos.animationCache__parseVersion1_3, n);
                continue
            }
            u.length != i.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, n), o = cc.Animation.create(u, s, 1), cc.animationCache.addAnimation(o, n)
        }
    },
    _parseVersion2: function(e) {
        var t = cc.spriteFrameCache;
        for (var n in e) {
            var r = e[n],
                i = r.loop,
                s = parseInt(r.loops),
                o = i ? cc.REPEAT_FOREVER : isNaN(s) ? 1 : s,
                u = r.restoreOriginalFrame && r["restoreOriginalFrame"] == 1 ? !0 : !1,
                a = r.frames;
            if (!a) {
                cc.log(cc._LogInfos.animationCache__parseVersion2, n);
                continue
            }
            var f = [];
            for (var l = 0; l < a.length; l++) {
                var c = a[l],
                    h = c.spriteframe,
                    p = t.getSpriteFrame(h);
                if (!p) {
                    cc.log(cc._LogInfos.animationCache__parseVersion2_2, n, h);
                    continue
                }
                var d = parseFloat(c.delayUnits) || 0,
                    v = c.notification,
                    m = new cc.AnimationFrame;
                m.initWithSpriteFrame(p, d, v), f.push(m)
            }
            var g = parseFloat(r.delayPerUnit) || 0,
                y = new cc.Animation;
            y.initWithAnimationFrames(f, g, o), y.setRestoreOriginalFrame(u), cc.animationCache.addAnimation(y, n)
        }
    },
    _clear: function() {
        this._animations = {}
    }
}, cc.SpriteFrame = cc.Class.extend({
    _offset: null,
    _originalSize: null,
    _rectInPixels: null,
    _rotated: !1,
    _rect: null,
    _offsetInPixels: null,
    _originalSizeInPixels: null,
    _texture: null,
    _textureFilename: "",
    _textureLoaded: !1,
    _eventListeners: null,
    ctor: function(e, t, n, r, i) {
        this._offset = cc.p(0, 0), this._offsetInPixels = cc.p(0, 0), this._originalSize = cc.size(0, 0), this._rotated = !1, this._originalSizeInPixels = cc.size(0, 0), this._textureFilename = "", this._texture = null, this._textureLoaded = !1, e !== undefined && t !== undefined && (n === undefined || r === undefined || i === undefined ? this.initWithTexture(e, t) : this.initWithTexture(e, t, n, r, i))
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(e, t) {
        this._eventListeners == null && (this._eventListeners = []), this._eventListeners.push({
            eventCallback: e,
            eventTarget: t
        })
    },
    _callLoadedEventCallbacks: function() {
        var e = this._eventListeners;
        if (!e)
            return;
        for (var t = 0, n = e.length; t < n; t++) {
            var r = e[t];
            r.eventCallback.call(r.eventTarget, this)
        }
        e.length = 0
    },
    getRectInPixels: function() {
        var e = this._rectInPixels;
        return cc.rect(e.x, e.y, e.width, e.height)
    },
    setRectInPixels: function(e) {
        this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0)), this._rectInPixels.x = e.x, this._rectInPixels.y = e.y, this._rectInPixels.width = e.width, this._rectInPixels.height = e.height, this._rect = cc.rectPixelsToPoints(e)
    },
    isRotated: function() {
        return this._rotated
    },
    setRotated: function(e) {
        this._rotated = e
    },
    getRect: function() {
        var e = this._rect;
        return cc.rect(e.x, e.y, e.width, e.height)
    },
    setRect: function(e) {
        this._rect || (this._rect = cc.rect(0, 0, 0, 0)), this._rect.x = e.x, this._rect.y = e.y, this._rect.width = e.width, this._rect.height = e.height, this._rectInPixels = cc.rectPointsToPixels(this._rect)
    },
    getOffsetInPixels: function() {
        return cc.p(this._offsetInPixels)
    },
    setOffsetInPixels: function(e) {
        this._offsetInPixels.x = e.x, this._offsetInPixels.y = e.y, cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
    },
    getOriginalSizeInPixels: function() {
        return cc.size(this._originalSizeInPixels)
    },
    setOriginalSizeInPixels: function(e) {
        this._originalSizeInPixels.width = e.width, this._originalSizeInPixels.height =
            e.height
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    setOriginalSize: function(e) {
        this._originalSize.width = e.width, this._originalSize.height = e.height
    },
    getTexture: function() {
        if (this._texture)
            return this._texture;
        if (this._textureFilename !== "") {
            var e = cc.textureCache.addImage(this._textureFilename);
            return e && (this._textureLoaded = e.isLoaded()), e
        }
        return null
    },
    setTexture: function(e) {
        if (this._texture != e) {
            var t = e.isLoaded();
            this._textureLoaded = t, this._texture = e, t || e.addLoadedEventListener(function(e) {
                this._textureLoaded = !0;
                if (this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS) {
                    var t = e.getHtmlElementObj();
                    t = cc.cutRotateImageToCanvas(t, this.getRect());
                    var n = new cc.Texture2D;
                    n.initWithElement(t), n.handleLoadedTexture(), this.setTexture(n);
                    var r = this.getRect();
                    this.setRect(cc.rect(0, 0, r.width, r.height))
                }
                var i = this._rect;
                if (i.width === 0 && i.height === 0) {
                    var s = e.width,
                        o = e.height;
                    this._rect.width = s, this._rect.height = o, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = s, this._originalSize.height = o
                }
                this._callLoadedEventCallbacks()
            }, this)
        }
    },
    getOffset: function() {
        return cc.p(this._offset)
    },
    setOffset: function(e) {
        this._offset.x = e.x, this._offset.y = e.y
    },
    clone: function() {
        var e = new cc.SpriteFrame;
        return e.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels), e.setTexture(this._texture), e
    },
    copyWithZone: function() {
        var e = new cc.SpriteFrame;
        return e.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels), e.setTexture(this._texture), e
    },
    copy: function() {
        return this.copyWithZone()
    },
    initWithTexture: function(e, t, n, r, i) {
        arguments.length === 2 && (t = cc.rectPointsToPixels(t)), r = r || cc.p(0, 0), i = i || t, n = n || !1, cc.isString(e) ? (this._texture = null, this._textureFilename = e) : e instanceof cc.Texture2D && this.setTexture(e), e = this.getTexture(), this._rectInPixels = t, t = this._rect = cc.rectPixelsToPoints(t);
        if (e && e.url && e.isLoaded()) {
            var s, o;
            n ? (s = t.x + t.height, o = t.y + t.width) : (s = t.x + t.width, o = t.y + t.height), s > e.getPixelsWide() && cc.error(cc._LogInfos.RectWidth, e.url), o > e.getPixelsHigh() && cc.error(cc._LogInfos.RectHeight, e.url)
        }
        return this._offsetInPixels.x = r.x, this._offsetInPixels.y = r.y, cc._pointPixelsToPointsOut(r, this._offset), this._originalSizeInPixels.width = i.width, this._originalSizeInPixels.height = i.height, cc._sizePixelsToPointsOut(i, this._originalSize), this._rotated = n, !0
    }
}), cc.SpriteFrame.create = function(e, t, n, r, i) {
    return new cc.SpriteFrame(e, t, n, r, i)
}, cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create, cc.SpriteFrame._frameWithTextureForCanvas = function(e, t, n, r, i) {
    var s = new cc.SpriteFrame;
    return s._texture = e, s._rectInPixels = t, s._rect = cc.rectPixelsToPoints(t), s._offsetInPixels.x = r.x, s._offsetInPixels.y = r.y, cc._pointPixelsToPointsOut(s._offsetInPixels, s._offset), s._originalSizeInPixels.width = i.width, s._originalSizeInPixels.height = i.height, cc._sizePixelsToPointsOut(s._originalSizeInPixels, s._originalSize), s._rotated = n, s
}, cc.spriteFrameCache = {
    _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache: {},
    _rectFromString: function(e) {
        var t = this._CCNS_REG2.exec(e);
        return t ? cc.rect(parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3]), parseFloat(t[4])) : cc.rect(0, 0, 0, 0)
    },
    _pointFromString: function(e) {
        var t = this._CCNS_REG1.exec(e);
        return t ? cc.p(parseFloat(t[1]), parseFloat(t[2])) : cc.p(0, 0)
    },
    _sizeFromString: function(e) {
        var t = this._CCNS_REG1.exec(e);
        return t ? cc.size(parseFloat(t[1]), parseFloat(t[2])) : cc.size(0, 0)
    },
    _getFrameConfig: function(e) {
        var t = cc.loader.getRes(e);
        cc.assert(t, cc._LogInfos.spriteFrameCache__getFrameConfig_2, e), cc.loader.release(e);
        if (t._inited)
            return this._frameConfigCache[e] = t, t;
        var n = t.frames,
            r = t.metadata || t.meta,
            i = {},
            s = {},
            o = 0;
        if (r) {
            var u = r.format;
            o = u.length <= 1 ? parseInt(u) : u, s.image = r.textureFileName || r.textureFileName || r.image
        }
        for (var a in n) {
            var f = n[a];
            if (!f)
                continue;
            var l = {};
            if (o == 0) {
                l.rect = cc.rect(f.x, f.y, f.width, f.height), l.rotated = !1, l.offset = cc.p(f.offsetX, f.offsetY);
                var c = f.originalWidth,
                    h = f.originalHeight;
                (!c || !h) && cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig), c = Math.abs(c), h = Math.abs(h), l.size = cc.size(c, h)
            } else if (o == 1 || o == 2)
                l.rect = this._rectFromString(f.frame), l.rotated = f.rotated || !1, l.offset = this._pointFromString(f.offset), l.size = this._sizeFromString(f.sourceSize);
            else if (o == 3) {
                var p = this._sizeFromString(f.spriteSize),
                    d = this._rectFromString(f.textureRect);
                p && (d = cc.rect(d.x, d.y, p.width, p.height)), l.rect = d, l.rotated = f.textureRotated || !1, l.offset = this._pointFromString(f.spriteOffset), l.size = this._sizeFromString(f.spriteSourceSize), l.aliases = f.aliases
            } else {
                var v = f.frame,
                    m = f.sourceSize;
                a = f.filename || a, l.rect = cc.rect(v.x, v.y, v.w, v.h), l.rotated = f.rotated || !1, l.offset = cc.p(0, 0), l.size = cc.size(m.w, m.h)
            }
            i[a] = l
        }
        var g = this._frameConfigCache[e] = {
            _inited: !0,
            frames: i,
            meta: s
        };
        return g
    },
    addSpriteFrames: function(e, t) {
        cc.assert(e, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        var n = this._frameConfigCache[e] || cc.loader.getRes(e);
        if (!n || !n.frames)
            return;
        var r = this,
            i = r._frameConfigCache[e] || r._getFrameConfig(e),
            s = i.frames,
            o = i.meta;
        if (!t) {
            var u = cc.path.changeBasename(e, o.image || ".png");
            t = cc.textureCache.addImage(u)
        } else
            t instanceof cc.Texture2D || (cc.isString(t) ? t = cc.textureCache.addImage(t) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3));
        var a = r._spriteFramesAliases,
            f = r._spriteFrames;
        for (var l in s) {
            var c = s[l],
                h = f[l];
            if (!h) {
                h = cc.SpriteFrame.create(t, c.rect, c.rotated, c.offset, c.size);
                var p = c.aliases;
                if (p)
                    for (var d = 0, v = p.length; d < v; d++) {
                        var m = p[d];
                        a[m] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, m), a[m] = l
                    }
                if (cc._renderType === cc._RENDER_TYPE_CANVAS && h.isRotated()) {
                    var g = h.getTexture();
                    if (g.isLoaded()) {
                        var y = h.getTexture().getHtmlElementObj();
                        y = cc.cutRotateImageToCanvas(y, h.getRectInPixels());
                        var b = new cc.Texture2D;
                        b.initWithElement(y), b.handleLoadedTexture(), h.setTexture(b);
                        var w = h._rect;
                        h.setRect(cc.rect(0, 0, w.width, w.height))
                    }
                }
                f[l] = h
            }
        }
    },
    _checkConflict: function(e) {
        var t = e.frames;
        for (var n in t)
            this._spriteFrames[n] && cc.log(cc._LogInfos.spriteFrameCache__checkConflict, n)
    },
    addSpriteFrame: function(e, t) {
        this._spriteFrames[t] = e
    },
    removeSpriteFrames: function() {
        this._spriteFrames = {}, this._spriteFramesAliases = {}
    },
    removeSpriteFrameByName: function(e) {
        if (!e)
            return;
        this._spriteFramesAliases[e] && delete this._spriteFramesAliases[e], this._spriteFrames[e] && delete this._spriteFrames[e]
    },
    removeSpriteFramesFromFile: function(e) {
        var t = this,
            n = t._spriteFrames,
            r = t._spriteFramesAliases,
            i = t._frameConfigCache[e];
        if (!i)
            return;
        var s = i.frames;
        for (var o in s)
            if (n[o]) {
                delete n[o];
                for (var u in r)
                    r[u] == o && delete r[u]
            }
    },
    removeSpriteFramesFromTexture: function(e) {
        var t = this,
            n = t._spriteFrames,
            r = t._spriteFramesAliases;
        for (var i in n) {
            var s = n[i];
            if (s && s.getTexture() == e) {
                delete n[i];
                for (var o in r)
                    r[o] == i && delete r[o]
            }
        }
    },
    getSpriteFrame: function(e) {
        var t = this,
            n = t._spriteFrames[e];
        if (!n) {
            var r = t._spriteFramesAliases[e];
            r && (n = t._spriteFrames[r.toString()], n || delete t._spriteFramesAliases[e])
        }
        return n || cc.log(cc._LogInfos.spriteFrameCache_getSpriteFrame, e), n
    },
    _clear: function() {
        this._spriteFrames = {}, this._spriteFramesAliases = {}, this._frameConfigCache = {}
    }
}, cc.g_NumberOfDraws = 0, cc.GLToClipTransform = function(e) {
    var t = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, t);
    var n = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, n), cc.kmMat4Multiply(e, t, n)
}, cc.Director = cc.Class.extend({
    _landscape: !1,
    _nextDeltaTimeZero: !1,
    _paused: !1,
    _purgeDirectorInNextLoop: !1,
    _sendCleanupToScene: !1,
    _animationInterval: 0,
    _oldAnimationInterval: 0,
    _projection: 0,
    _accumDt: 0,
    _contentScaleFactor: 1,
    _displayStats: !1,
    _deltaTime: 0,
    _frameRate: 0,
    _FPSLabel: null,
    _SPFLabel: null,
    _drawsLabel: null,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _frames: 0,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterDraw: null,
    _eventAfterVisit: null,
    _eventAfterUpdate: null,
    ctor: function() {
        var e = this;
        e._lastUpdate = Date.now(), cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
            e._lastUpdate = Date.now()
        })
    },
    init: function() {
        return this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS, this._scenesStack = [], this._projection = cc.Director.PROJECTION_DEFAULT, this._projectionDelegate = null, this._accumDt = 0, this._frameRate = 0, this._displayStats = !1, this._totalFrames = this._frames = 0, this._lastUpdate = Date.now(), this._paused = !1, this._purgeDirectorInNextLoop = !1, this._winSizeInPoints = cc.size(0, 0), this._openGLView = null, this._contentScaleFactor = 1, this._scheduler = new cc.Scheduler, this._actionManager = cc.ActionManager ? new cc.ActionManager : null, this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1), this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW), this._eventAfterDraw.setUserData(this), this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT), this._eventAfterVisit.setUserData(this), this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE), this._eventAfterUpdate.setUserData(this), this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED), this._eventProjectionChanged.setUserData(this), !0
    },
    calculateDeltaTime: function() {
        var e = Date.now();
        this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime = (e - this._lastUpdate) / 1e3, cc.game.config[cc.game.CONFIG_KEY.debugMode] > 0 && this._deltaTime > .2 && (this._deltaTime = 1 / 60), this._lastUpdate = e
    },
    convertToGL: null,
    convertToUI: null,
    drawScene: function() {
        this.calculateDeltaTime(), this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate)), this._clear(), this._nextScene && this.setNextScene(), this._beforeVisitScene && this._beforeVisitScene(), this._runningScene && (this._runningScene.visit(), cc.eventManager.dispatchEvent(this._eventAfterVisit)), this._notificationNode && this._notificationNode.visit(), this._displayStats && this._showStats(), this._afterVisitScene && this._afterVisitScene(), cc.eventManager.dispatchEvent(this._eventAfterDraw), this._totalFrames++, this._displayStats && this._calculateMPF()
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    end: function() {
        this._purgeDirectorInNextLoop = !0
    },
    getContentScaleFactor: function() {
        return this._contentScaleFactor
    },
    getNotificationNode: function() {
        return this._notificationNode
    },
    getWinSize: function() {
        return cc.size(this._winSizeInPoints)
    },
    getWinSizeInPixels: function() {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
    },
    getVisibleSize: null,
    getVisibleOrigin: null,
    getZEye: null,
    pause: function() {
        if (this._paused)
            return;
        this._oldAnimationInterval = this._animationInterval, this.setAnimationInterval(.25), this._paused = !0
    },
    popScene: function() {
        cc.assert(this._runningScene, cc._LogInfos.Director_popScene), this._scenesStack.pop();
        var e = this._scenesStack.length;
        e == 0 ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[e - 1])
    },
    purgeCachedData: function() {
        cc.animationCache._clear(), cc.spriteFrameCache._clear(), cc.textureCache._clear()
    },
    purgeDirector: function() {
        this.getScheduler().unscheduleAllCallbacks(), cc.eventManager && cc.eventManager.setEnabled(!1), this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup()), this._runningScene = null, this._nextScene = null, this._scenesStack.length = 0, this.stopAnimation(), this.purgeCachedData(), cc.checkGLErrorDebug()
    },
    pushScene: function(e) {
        cc.assert(e, cc._LogInfos.Director_pushScene), this._sendCleanupToScene = !1, this._scenesStack.push(e), this._nextScene = e
    },
    runScene: function(e) {
        cc.assert(e, cc._LogInfos.Director_pushScene);
        if (!this._runningScene)
            this.pushScene(e), this.startAnimation();
        else {
            var t = this._scenesStack.length;
            t === 0 ? (this._sendCleanupToScene = !0, this._scenesStack[t] = e, this._nextScene = e) : (this._sendCleanupToScene = !0, this._scenesStack[t - 1] = e, this._nextScene = e)
        }
    },
    resume: function() {
        if (!this._paused)
            return;
        this.setAnimationInterval(this._oldAnimationInterval), this._lastUpdate = Date.now(), this._lastUpdate || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0
    },
    setContentScaleFactor: function(e) {
        e != this._contentScaleFactor && (this._contentScaleFactor = e, this._createStatsLabel())
    },
    setDepthTest: null,
    setDefaultValues: function() {},
    setNextDeltaTimeZero: function(e) {
        this._nextDeltaTimeZero = e
    },
    setNextScene: function() {
        var e = !1,
            t = !1;
        cc.TransitionScene && (e = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, t = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1);
        if (!t) {
            var n = this._runningScene;
            n && (n.onExitTransitionDidStart(), n.onExit()), this._sendCleanupToScene && n && n.cleanup()
        }
        this._runningScene = this._nextScene, this._nextScene = null, !e && this._runningScene != null && (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish())
    },
    setNotificationNode: function(e) {
        this._notificationNode = e
    },
    getDelegate: function() {
        return this._projectionDelegate
    },
    setDelegate: function(e) {
        this._projectionDelegate = e
    },
    setOpenGLView: null,
    setProjection: null,
    setViewport: null,
    getOpenGLView: null,
    getProjection: null,
    setAlphaBlending: null,
    _showStats: function() {
        this._frames++, this._accumDt += this._deltaTime, this._FPSLabel && this._SPFLabel && this._drawsLabel ? (this._accumDt > cc.DIRECTOR_FPS_INTERVAL && (this._SPFLabel.string = this._secondsPerFrame.toFixed(3), this._frameRate = this._frames / this._accumDt, this._frames = 0, this._accumDt = 0, this._FPSLabel.string = this._frameRate.toFixed(1), this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString()), this._FPSLabel.visit(), this._SPFLabel.visit(), this._drawsLabel.visit()) : this._createStatsLabel(), cc.g_NumberOfDraws = 0
    },
    isSendCleanupToScene: function() {
        return this._sendCleanupToScene
    },
    getRunningScene: function() {
        return this._runningScene
    },
    getAnimationInterval: function() {
        return this._animationInterval
    },
    isDisplayStats: function() {
        return this._displayStats
    },
    setDisplayStats: function(e) {
        this._displayStats = e
    },
    getSecondsPerFrame: function() {
        return this._secondsPerFrame
    },
    isNextDeltaTimeZero: function() {
        return this._nextDeltaTimeZero
    },
    isPaused: function() {
        return this._paused
    },
    getTotalFrames: function() {
        return this._totalFrames
    },
    popToRootScene: function() {
        this.popToSceneStackLevel(1)
    },
    popToSceneStackLevel: function(e) {
        cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
        var t = this._scenesStack,
            n = t.length;
        if (n == 0) {
            this.end();
            return
        }
        if (e > n)
            return;
        while (n > e) {
            var r = t.pop();
            r.running && (r.onExitTransitionDidStart(), r.onExit()), r.cleanup(), n--
        }
        this._nextScene = t[t.length - 1], this._sendCleanupToScene = !1
    },
    getScheduler: function() {
        return this._scheduler
    },
    setScheduler: function(e) {
        this._scheduler != e && (this._scheduler = e)
    },
    getActionManager: function() {
        return this._actionManager
    },
    setActionManager: function(e) {
        this._actionManager != e && (this._actionManager = e)
    },
    getDeltaTime: function() {
        return this._deltaTime
    },
    _createStatsLabel: null,
    _calculateMPF: function() {
        var e = Date.now();
        this._secondsPerFrame = (e - this._lastUpdate) / 1e3
    }
}), cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed", cc.Director.EVENT_AFTER_DRAW = "director_after_draw", cc.Director.EVENT_AFTER_VISIT = "director_after_visit", cc.Director.EVENT_AFTER_UPDATE = "director_after_update", cc.DisplayLinkDirector = cc.Director.extend({
    invalid: !1,
    startAnimation: function() {
        this._nextDeltaTimeZero = !0, this.invalid = !1
    },
    mainLoop: function() {
        this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
    },
    stopAnimation: function() {
        this.invalid = !0
    },
    setAnimationInterval: function(e) {
        this._animationInterval = e, this.invalid || (this.stopAnimation(), this.startAnimation())
    }
}), cc.Director.sharedDirector = null, cc.Director.firstUseDirector = !0, cc.Director._getInstance = function() {
    return cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init()), cc.Director.sharedDirector
}, cc.defaultFPS = 60, cc.Director.PROJECTION_2D = 0, cc.Director.PROJECTION_3D = 1, cc.Director.PROJECTION_CUSTOM = 3, cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.Director.prototype;
    _p.setProjection = function(e) {
        this._projection = e, cc.eventManager.dispatchEvent(this._eventProjectionChanged)
    }, _p.setDepthTest = function() {}, _p.setOpenGLView = function(e) {
        this._winSizeInPoints.width = cc._canvas.width, this._winSizeInPoints.height = cc._canvas.height, this._openGLView = e || cc.view, cc.eventManager && cc.eventManager.setEnabled(!0)
    }, _p._clear = function() {
        var e = this._openGLView.getViewPortRect();
        cc._renderContext.clearRect(-e.x, e.y, e.width, -e.height)
    }, _p._createStatsLabel = function() {
        var e = this,
            t = 0;
        e._winSizeInPoints.width > e._winSizeInPoints.height ? t = 0 | e._winSizeInPoints.height / 320 * 24 : t = 0 | e._winSizeInPoints.width / 320 * 24, e._FPSLabel = cc.LabelTTF.create("000.0", "Arial", t), e._SPFLabel = cc.LabelTTF.create("0.000", "Arial", t), e._drawsLabel = cc.LabelTTF.create("0000", "Arial", t);
        var n = cc.DIRECTOR_STATS_POSITION;
        e._drawsLabel.setPosition(e._drawsLabel.width / 2 + n.x, e._drawsLabel.height * 5 / 2 + n.y), e._SPFLabel.setPosition(e._SPFLabel.width / 2 + n.x, e._SPFLabel.height * 3 / 2 + n.y), e._FPSLabel.setPosition(e._FPSLabel.width / 2 + n.x, e._FPSLabel.height / 2 + n.y)
    }, _p.getVisibleSize = function() {
        return this.getWinSize()
    }, _p.getVisibleOrigin = function() {
        return cc.p(0, 0)
    }
} else
    cc.Director._fpsImage = new Image, cc._addEventListener(cc.Director._fpsImage, "load", function() {
        cc.Director._fpsImageLoaded = !0
    }), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage), cc.assert(cc.isFunction(cc._tmp.DirectorWebGL), cc._LogInfos.MissingFile, "CCDirectorWebGL.js"), cc._tmp.DirectorWebGL(), delete cc._tmp.DirectorWebGL;
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1, cc.ListEntry = function(e, t, n, r, i, s) {
    this.prev = e, this.next = t, this.target = n, this.priority = r, this.paused = i, this.markedForDeletion = s
}, cc.HashUpdateEntry = function(e, t, n, r) {
    this.list = e, this.entry = t, this.target = n, this.hh = r
}, cc.HashTimerEntry = function(e, t, n, r, i, s, o) {
    var u = this;
    u.timers = e, u.target = t, u.timerIndex = n, u.currentTimer = r, u.currentTimerSalvaged = i, u.paused = s, u.hh = o
}, cc.Timer = cc.Class.extend({
    _interval: 0,
    _callback: null,
    _target: null,
    _elapsed: 0,
    _runForever: !1,
    _useDelay: !1,
    _timesExecuted: 0,
    _repeat: 0,
    _delay: 0,
    getInterval: function() {
        return this._interval
    },
    setInterval: function(e) {
        this._interval = e
    },
    getCallback: function() {
        return this._callback
    },
    ctor: function(e, t, n, r, i) {
        var s = this;
        s._target = e, s._callback = t, s._elapsed = -1, s._interval = n || 0, s._delay = i || 0, s._useDelay = s._delay > 0, s._repeat = r == null ? cc.REPEAT_FOREVER : r, s._runForever = s._repeat == cc.REPEAT_FOREVER
    },
    _doCallback: function() {
        var e = this;
        cc.isString(e._callback) ? e._target[e._callback](e._elapsed) : e._callback.call(e._target, e._elapsed)
    },
    update: function(e) {
        var t = this;
        if (t._elapsed == -1)
            t._elapsed = 0, t._timesExecuted = 0;
        else {
            var n = t._target,
                r = t._callback;
            t._elapsed += e, t._runForever && !t._useDelay ? t._elapsed >= t._interval && (n && r && t._doCallback(), t._elapsed = 0) : (t._useDelay ? t._elapsed >= t._delay && (n && r && t._doCallback(), t._elapsed = t._elapsed - t._delay, t._timesExecuted += 1, t._useDelay = !1) : t._elapsed >= t._interval && (n && r && t._doCallback(), t._elapsed = 0, t._timesExecuted += 1), t._timesExecuted > t._repeat && cc.director.getScheduler().unscheduleCallbackForTarget(n, r))
        }
    }
}), cc.Scheduler = cc.Class.extend({
    _timeScale: 1,
    _updates: null,
    _hashForUpdates: null,
    _arrayForUpdates: null,
    _hashForTimers: null,
    _arrayForTimes: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _updateHashLocked: !1,
    ctor: function() {
        var e = this;
        e._timeScale = 1, e._updates = [
            [],
            [],
            []
        ], e._hashForUpdates = {}, e._arrayForUpdates = [], e._hashForTimers = {}, e._arrayForTimers = [], e._currentTarget = null, e._currentTargetSalvaged = !1, e._updateHashLocked = !1
    },
    _removeHashElement: function(e) {
        delete this._hashForTimers[e.target.__instanceId], cc.arrayRemoveObject(this._arrayForTimers, e), e.Timer = null, e.target = null, e = null
    },
    _removeUpdateFromHash: function(e) {
        var t = this,
            n = t._hashForUpdates[e.target.__instanceId];
        n && (cc.arrayRemoveObject(n.list, n.entry), delete t._hashForUpdates[n.target.__instanceId], cc.arrayRemoveObject(t._arrayForUpdates, n), n.entry = null, n.target = null)
    },
    _priorityIn: function(e, t, n, r) {
        var i = this,
            s = new cc.ListEntry(null, null, t, n, r, !1);
        if (!e)
            e = [], e.push(s);
        else {
            var o = e.length - 1;
            for (var u = 0; u <= o; u++)
                if (n < e[u].priority) {
                    o = u;
                    break
                }
            e.splice(u, 0, s)
        }
        var a = new cc.HashUpdateEntry(e, s, t, null);
        return i._arrayForUpdates.push(a), i._hashForUpdates[t.__instanceId] = a, e
    },
    _appendIn: function(e, t, n) {
        var r = this,
            i = new cc.ListEntry(null, null, t, 0, n, !1);
        e.push(i);
        var s = new cc.HashUpdateEntry(e, i, t, null);
        r._arrayForUpdates.push(s), r._hashForUpdates[t.__instanceId] = s
    },
    setTimeScale: function(e) {
        this._timeScale = e
    },
    getTimeScale: function() {
        return this._timeScale
    },
    update: function(e) {
        var t = this,
            n = t._updates,
            r = t._arrayForTimers,
            i, s, o, u;
        t._updateHashLocked = !0, this._timeScale != 1 && (e *= this._timeScale);
        for (o = 0, u = n.length; o < u && o >= 0; o++) {
            var a = t._updates[o];
            for (var f = 0, l = a.length; f < l; f++)
                i = a[f], !i.paused && !i.markedForDeletion && i.target.update(e)
        }
        for (o = 0, u = r.length; o < u; o++) {
            s = r[o];
            if (!s)
                break;
            t._currentTarget = s, t._currentTargetSalvaged = !1;
            if (!s.paused)
                for (s.timerIndex = 0; s.timerIndex < s.timers.length; s.timerIndex++)
                    s.currentTimer = s.timers[s.timerIndex], s.currentTimerSalvaged = !1, s.currentTimer.update(e), s.currentTimer = null;
            t._currentTargetSalvaged && s.timers.length == 0 && (t._removeHashElement(s), o--)
        }
        for (o = 0, u = n.length; o < u; o++) {
            var a = t._updates[o];
            for (var f = 0, l = a.length; f < l;) {
                i = a[f];
                if (!i)
                    break;
                i.markedForDeletion ? t._removeUpdateFromHash(i) : f++
            }
        }
        t._updateHashLocked = !1, t._currentTarget = null
    },
    scheduleCallbackForTarget: function(e, t, n, r, i, s) {
        cc.assert(t, cc._LogInfos.Scheduler_scheduleCallbackForTarget_2), cc.assert(e, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3), n = n || 0, r = r == null ? cc.REPEAT_FOREVER : r, i = i || 0, s = s || !1;
        var o = this,
            u, a = o._hashForTimers[e.__instanceId];
        a || (a = new cc.HashTimerEntry(null, e, 0, null, null, s, null), o._arrayForTimers.push(a), o._hashForTimers[e.__instanceId] = a);
        if (a.timers == null)
            a.timers = [];
        else
            for (var f = 0; f < a.timers.length; f++) {
                u = a.timers[f];
                if (t == u._callback) {
                    cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, u.getInterval().toFixed(4), n.toFixed(4)), u._interval = n;
                    return
                }
            }
        u = new cc.Timer(e, t, n, r, i), a.timers.push(u)
    },
    scheduleUpdateForTarget: function(e, t, n) {
        if (e === null)
            return;
        var r = this,
            i = r._updates,
            s = r._hashForUpdates[e.__instanceId];
        if (s) {
            s.entry.markedForDeletion = !1;
            return
        }
        t == 0 ? r._appendIn(i[1], e, n) : t < 0 ? i[0] = r._priorityIn(i[0], e, t, n) : i[2] = r._priorityIn(i[2], e, t, n)
    },
    unscheduleCallbackForTarget: function(e, t) {
        if (e == null || t == null)
            return;
        var n = this,
            r = n._hashForTimers[e.__instanceId];
        if (r) {
            var i = r.timers;
            for (var s = 0, o = i.length; s < o; s++) {
                var u = i[s];
                if (t == u._callback) {
                    u == r.currentTimer && !r.currentTimerSalvaged && (r.currentTimerSalvaged = !0), i.splice(s, 1), r.timerIndex >= s && r.timerIndex--, i.length == 0 && (n._currentTarget == r ? n._currentTargetSalvaged = !0 : n._removeHashElement(r));
                    return
                }
            }
        }
    },
    unscheduleUpdateForTarget: function(e) {
        if (e == null)
            return;
        var t = this,
            n = t._hashForUpdates[e.__instanceId];
        n != null && (t._updateHashLocked ? n.entry.markedForDeletion = !0 : t._removeUpdateFromHash(n.entry))
    },
    unscheduleAllCallbacksForTarget: function(e) {
        if (e == null)
            return;
        var t = this,
            n = t._hashForTimers[e.__instanceId];
        if (n) {
            var r = n.timers;
            !n.currentTimerSalvaged && r.indexOf(n.currentTimer) >= 0 && (n.currentTimerSalvaged = !0), r.length = 0, t._currentTarget == n ? t._currentTargetSalvaged = !0 : t._removeHashElement(n)
        }
        t.unscheduleUpdateForTarget(e)
    },
    unscheduleAllCallbacks: function() {
        this.unscheduleAllCallbacksWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllCallbacksWithMinPriority: function(e) {
        var t = this,
            n = t._arrayForTimers,
            r = t._updates;
        for (var i = 0, s = n.length; i < s; i++)
            t.unscheduleAllCallbacksForTarget(n[i].target);
        for (var i = 2; i >= 0; i--) {
            if (i == 1 && e > 0 || i == 0 && e >= 0)
                continue;
            var o = r[i];
            for (var u = 0, a = o.length; u < a; u++)
                t.unscheduleUpdateForTarget(o[u].target)
        }
    },
    pauseAllTargets: function() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    pauseAllTargetsWithMinPriority: function(e) {
        var t = [],
            n = this,
            r, i = n._arrayForTimers,
            s = n._updates;
        for (var o = 0, u = i.length; o < u; o++)
            r = i[o], r && (r.paused = !0, t.push(r.target));
        for (var o = 0, u = s.length; o < u; o++) {
            var a = s[o];
            for (var f = 0, l = a.length; f < l; f++)
                r = a[f], r && (r.paused = !0, t.push(r.target))
        }
        return t
    },
    resumeTargets: function(e) {
        if (!e)
            return;
        for (var t = 0; t < e.length; t++)
            this.resumeTarget(e[t])
    },
    pauseTarget: function(e) {
        cc.assert(e, cc._LogInfos.Scheduler_pauseTarget);
        var t = this,
            n = t._hashForTimers[e.__instanceId];
        n && (n.paused = !0);
        var r = t._hashForUpdates[e.__instanceId];
        r && (r.entry.paused = !0)
    },
    resumeTarget: function(e) {
        cc.assert(e, cc._LogInfos.Scheduler_resumeTarget);
        var t = this,
            n = t._hashForTimers[e.__instanceId];
        n && (n.paused = !1);
        var r = t._hashForUpdates[e.__instanceId];
        r && (r.entry.paused = !1)
    },
    isTargetPaused: function(e) {
        cc.assert(e, cc._LogInfos.Scheduler_isTargetPaused);
        var t = this._hashForTimers[e.__instanceId];
        return t ? t.paused : !1
    }
}), cc.Scheduler.PRIORITY_SYSTEM = -2147483648, cc._tmp.PrototypeLabelTTF = function() {
    var e = cc.LabelTTF.prototype;
    cc.defineGetterSetter(e, "color", e.getColor, e.setColor), cc.defineGetterSetter(e, "opacity", e.getOpacity, e.setOpacity), e.string, cc.defineGetterSetter(e, "string", e.getString, e.setString), e.textAlign, cc.defineGetterSetter(e, "textAlign", e.getHorizontalAlignment, e.setHorizontalAlignment), e.verticalAlign, cc.defineGetterSetter(e, "verticalAlign", e.getVerticalAlignment, e.setVerticalAlignment), e.fontSize, cc.defineGetterSetter(e, "fontSize", e.getFontSize, e.setFontSize), e.fontName, cc.defineGetterSetter(e, "fontName", e.getFontName, e.setFontName), e.font, cc.defineGetterSetter(e, "font", e._getFont, e._setFont), e.boundingSize, e.boundingWidth, cc.defineGetterSetter(e, "boundingWidth", e._getBoundingWidth, e._setBoundingWidth), e.boundingHeight, cc.defineGetterSetter(e, "boundingHeight", e._getBoundingHeight, e._setBoundingHeight), e.fillStyle, cc.defineGetterSetter(e, "fillStyle", e._getFillStyle, e.setFontFillColor), e.strokeStyle, cc.defineGetterSetter(e, "strokeStyle", e._getStrokeStyle, e._setStrokeStyle), e.lineWidth, cc.defineGetterSetter(e, "lineWidth", e._getLineWidth, e._setLineWidth), e.shadowOffset, e.shadowOffsetX, cc.defineGetterSetter(e, "shadowOffsetX", e._getShadowOffsetX, e._setShadowOffsetX), e.shadowOffsetY, cc.defineGetterSetter(e, "shadowOffsetY", e._getShadowOffsetY, e._setShadowOffsetY), e.shadowOpacity, cc.defineGetterSetter(e, "shadowOpacity", e._getShadowOpacity, e._setShadowOpacity), e.shadowBlur, cc.defineGetterSetter(e, "shadowBlur", e._getShadowBlur, e._setShadowBlur)
}, cc.LabelTTF = cc.Sprite.extend({
    _dimensions: null,
    _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName: null,
    _fontSize: 0,
    _string: "",
    _originalText: null,
    _isMultiLine: !1,
    _fontStyleStr: null,
    _shadowEnabled: !1,
    _shadowOffset: null,
    _shadowOpacity: 0,
    _shadowBlur: 0,
    _shadowColorStr: null,
    _strokeEnabled: !1,
    _strokeColor: null,
    _strokeSize: 0,
    _strokeColorStr: null,
    _textFillColor: null,
    _fillColorStr: null,
    _strokeShadowOffsetX: 0,
    _strokeShadowOffsetY: 0,
    _needUpdateTexture: !1,
    _labelCanvas: null,
    _labelContext: null,
    _lineWidths: null,
    _className: "LabelTTF",
    initWithString: function(e, t, n, r, i, s) {
        var o;
        return e ? o = e + "" : o = "", n = n || 16, r = r || cc.size(0, 0), i = i || cc.TEXT_ALIGNMENT_LEFT, s = s || cc.VERTICAL_TEXT_ALIGNMENT_TOP, this._opacityModifyRGB = !1, this._dimensions = cc.size(r.width, r.height), this._fontName = t || "Arial", this._hAlignment = i, this._vAlignment = s, this._fontSize = n, this._fontStyleStr = this._fontSize + "px '" + t + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(t, this._fontSize), this.string = o, this._setColorsString(), this._updateTexture(), this._needUpdateTexture = !1, !0
    },
    ctor: function(e, t, n, r, i, s) {
        cc.Sprite.prototype.ctor.call(this), this._dimensions = cc.size(0, 0), this._hAlignment = cc.TEXT_ALIGNMENT_LEFT, this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP, this._opacityModifyRGB = !1, this._fontStyleStr = "", this._fontName = "Arial", this._isMultiLine = !1, this._shadowEnabled = !1, this._shadowOffset = cc.p(0, 0), this._shadowOpacity = 0, this._shadowBlur = 0, this._shadowColorStr = "rgba(128, 128, 128, 0.5)", this._strokeEnabled = !1, this._strokeColor = cc.color(255, 255, 255, 255), this._strokeSize = 0, this._strokeColorStr = "", this._textFillColor = cc.color(255, 255, 255, 255), this._fillColorStr = "rgba(255,255,255,1)", this._strokeShadowOffsetX = 0, this._strokeShadowOffsetY = 0, this._needUpdateTexture = !1, this._lineWidths = [], this._setColorsString(), t && t instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(e, t) : cc.LabelTTF.prototype.initWithString.call(this, e, t, n, r, i, s)
    },
    init: function() {
        return this.initWithString(" ", this._fontName, this._fontSize)
    },
    _measureConfig: function() {
        this._getLabelContext().font = this._fontStyleStr
    },
    _measure: function(e) {
        return this._getLabelContext().measureText(e).width
    },
    description: function() {
        return "<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">"
    },
    setColor: null,
    _setColorsString: null,
    updateDisplayedColor: null,
    setOpacity: null,
    updateDisplayedOpacity: null,
    updateDisplayedOpacityForCanvas: function(e) {
        cc.Node.prototype.updateDisplayedOpacity.call(this, e), this._setColorsString()
    },
    getString: function() {
        return this._string
    },
    getHorizontalAlignment: function() {
        return this._hAlignment
    },
    getVerticalAlignment: function() {
        return this._vAlignment
    },
    getDimensions: function() {
        return cc.size(this._dimensions)
    },
    getFontSize: function() {
        return this._fontSize
    },
    getFontName: function() {
        return this._fontName
    },
    initWithStringAndTextDefinition: null,
    setTextDefinition: function(e) {
        e && this._updateWithTextDefinition(e, !0)
    },
    getTextDefinition: function() {
        return this._prepareTextDefinition(!1)
    },
    enableShadow: function(e, t, n, r) {
        n = n || .5, !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        var i = this._shadowOffset;
        if (i && i.x != e || i._y != t)
            i.x = e, i.y = t;
        this._shadowOpacity != n && (this._shadowOpacity = n), this._setColorsString(), this._shadowBlur != r && (this._shadowBlur = r), this._needUpdateTexture = !0
    },
    _getShadowOffsetX: function() {
        return this._shadowOffset.x
    },
    _setShadowOffsetX: function(e) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0), this._shadowOffset.x != e && (this._shadowOffset.x = e, this._needUpdateTexture = !0)
    },
    _getShadowOffsetY: function() {
        return this._shadowOffset._y
    },
    _setShadowOffsetY: function(e) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0), this._shadowOffset._y != e && (this._shadowOffset._y = e, this._needUpdateTexture = !0)
    },
    _getShadowOffset: function() {
        return cc.p(this._shadowOffset.x, this._shadowOffset.y)
    },
    _setShadowOffset: function(e) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        if (this._shadowOffset.x != e.x || this._shadowOffset.y != e.y)
            this._shadowOffset.x = e.x, this._shadowOffset.y = e.y, this._needUpdateTexture = !0
    },
    _getShadowOpacity: function() {
        return this._shadowOpacity
    },
    _setShadowOpacity: function(e) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0), this._shadowOpacity != e && (this._shadowOpacity = e, this._setColorsString(), this._needUpdateTexture = !0)
    },
    _getShadowBlur: function() {
        return this._shadowBlur
    },
    _setShadowBlur: function(e) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0), this._shadowBlur != e && (this._shadowBlur = e, this._needUpdateTexture = !0)
    },
    disableShadow: function() {
        this._shadowEnabled && (this._shadowEnabled = !1, this._needUpdateTexture = !0)
    },
    enableStroke: function(e, t) {
        this._strokeEnabled === !1 && (this._strokeEnabled = !0);
        var n = this._strokeColor;
        if (n.r !== e.r || n.g !== e.g || n.b !== e.b)
            n.r = e.r, n.g = e.g, n.b = e.b, this._setColorsString();
        this._strokeSize !== t && (this._strokeSize = t || 0), this._needUpdateTexture = !0
    },
    _getStrokeStyle: function() {
        return this._strokeColor
    },
    _setStrokeStyle: function(e) {
        this._strokeEnabled === !1 && (this._strokeEnabled = !0);
        var t = this._strokeColor;
        if (t.r !== e.r || t.g !== e.g || t.b !== e.b)
            t.r = e.r, t.g = e.g, t.b = e.b, this._setColorsString(), this._needUpdateTexture = !0
    },
    _getLineWidth: function() {
        return this._strokeSize
    },
    _setLineWidth: function(e) {
        this._strokeEnabled === !1 && (this._strokeEnabled = !0), this._strokeSize !== e && (this._strokeSize = e || 0, this._needUpdateTexture = !0)
    },
    disableStroke: function() {
        this._strokeEnabled && (this._strokeEnabled = !1, this._needUpdateTexture = !0)
    },
    setFontFillColor: null,
    _getFillStyle: function() {
        return this._textFillColor
    },
    _updateWithTextDefinition: function(e, t) {
        e.fontDimensions ? (this._dimensions.width = e.boundingWidth, this._dimensions.height = e.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0), this._hAlignment = e.textAlign, this._vAlignment = e.verticalAlign, this._fontName = e.fontName, this._fontSize = e.fontSize || 12, this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize), e.shadowEnabled && this.enableShadow(e.shadowOffsetX, e.shadowOffsetY, e.shadowOpacity, e.shadowBlur), e.strokeEnabled && this.enableStroke(e.strokeStyle, e.lineWidth), this.setFontFillColor(e.fillStyle), t && this._updateTexture()
    },
    _prepareTextDefinition: function(e) {
        var t = new cc.FontDefinition;
        e ? (t.fontSize = this._fontSize, t.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, t.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (t.fontSize = this._fontSize, t.boundingWidth = this._dimensions.width, t.boundingHeight = this._dimensions.height), t.fontName = this._fontName, t.textAlign = this._hAlignment, t.verticalAlign = this._vAlignment;
        if (this._strokeEnabled) {
            t.strokeEnabled = !0;
            var n = this._strokeColor;
            t.strokeStyle = cc.color(n.r, n.g, n.b), t.lineWidth = this._strokeSize
        } else
            t.strokeEnabled = !1;
        this._shadowEnabled ? (t.shadowEnabled = !0, t.shadowBlur = this._shadowBlur, t.shadowOpacity = this._shadowOpacity, t.shadowOffsetX = (e ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, t.shadowOffsetY = (e ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : t._shadowEnabled = !1;
        var r = this._textFillColor;
        return t.fillStyle = cc.color(r.r, r.g, r.b), t
    },
    _fontClientHeight: 18,
    setString: function(e) {
        e = String(e), this._originalText != e && (this._originalText = e + "", this._updateString(), this._needUpdateTexture = !0)
    },
    _updateString: function() {
        this._string = this._originalText
    },
    setHorizontalAlignment: function(e) {
        e !== this._hAlignment && (this._hAlignment = e, this._needUpdateTexture = !0)
    },
    setVerticalAlignment: function(e) {
        e != this._vAlignment && (this._vAlignment = e, this._needUpdateTexture = !0)
    },
    setDimensions: function(e, t) {
        var n;
        t === undefined ? (n = e.width, t = e.height) : n = e;
        if (n != this._dimensions.width || t != this._dimensions.height)
            this._dimensions.width = n, this._dimensions.height = t, this._updateString(), this._needUpdateTexture = !0
    },
    _getBoundingWidth: function() {
        return this._dimensions.width
    },
    _setBoundingWidth: function(e) {
        e != this._dimensions.width && (this._dimensions.width = e, this._updateString(), this._needUpdateTexture = !0)
    },
    _getBoundingHeight: function() {
        return this._dimensions.height
    },
    _setBoundingHeight: function(e) {
        e != this._dimensions.height && (this._dimensions.height = e, this._updateString(), this._needUpdateTexture = !0)
    },
    setFontSize: function(e) {
        this._fontSize !== e && (this._fontSize = e, this._fontStyleStr = e + "px '" + this._fontName + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, e), this._needUpdateTexture = !0)
    },
    setFontName: function(e) {
        this._fontName && this._fontName != e && (this._fontName = e, this._fontStyleStr = this._fontSize + "px '" + e + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(e, this._fontSize), this._needUpdateTexture = !0)
    },
    _getFont: function() {
        return this._fontStyleStr
    },
    _setFont: function(e) {
        var t = cc.LabelTTF._fontStyleRE.exec(e);
        t && (this._fontSize = parseInt(t[1]), this._fontName = t[2], this._fontStyleStr = e, this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize), this._needUpdateTexture = !0)
    },
    _drawTTFInCanvas: function(e) {
        if (!e)
            return;
        var t = this._strokeShadowOffsetX,
            n = this._strokeShadowOffsetY,
            r = this._contentSize.height - n,
            i = this._vAlignment,
            s = this._hAlignment,
            o = this._fontClientHeight,
            u = this._strokeSize;
        e.setTransform(1, 0, 0, 1, 0 + t * .5, r + n * .5), e.font != this._fontStyleStr && (e.font = this._fontStyleStr), e.fillStyle = this._fillColorStr;
        var a = 0,
            f = 0,
            l = this._strokeEnabled;
        l && (e.lineWidth = u * 2, e.strokeStyle = this._strokeColorStr);
        if (this._shadowEnabled) {
            var c = this._shadowOffset;
            e.shadowColor = this._shadowColorStr, e.shadowOffsetX = c.x, e.shadowOffsetY = -c.y, e.shadowBlur = this._shadowBlur
        }
        e.textBaseline = cc.LabelTTF._textBaseline[i], e.textAlign = cc.LabelTTF._textAlign[s];
        var h = this._contentSize.width - t;
        s === cc.TEXT_ALIGNMENT_RIGHT ? a += h : s === cc.TEXT_ALIGNMENT_CENTER ? a += h / 2 : a += 0;
        if (this._isMultiLine) {
            var p = this._strings.length;
            i === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? f = o + r - o * p : i === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (f = o / 2 + (r - o * p) / 2);
            for (var d = 0; d < p; d++) {
                var v = this._strings[d],
                    m = -r + o * d + f;
                l && e.strokeText(v, a, m), e.fillText(v, a, m)
            }
        } else
            i === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? (l && e.strokeText(this._string, a, f), e.fillText(this._string, a, f)) : i === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? (f -= r, l && e.strokeText(this._string, a, f), e.fillText(this._string, a, f)) : (f -= r * .5, l && e.strokeText(this._string, a, f), e.fillText(this._string, a, f))
    },
    _getLabelContext: function() {
        if (this._labelContext)
            return this._labelContext;
        if (!this._labelCanvas) {
            var e = cc.newElement("canvas"),
                t = new cc.Texture2D;
            t.initWithElement(e), this.texture = t, this._labelCanvas = e
        }
        return this._labelContext = this._labelCanvas.getContext("2d"), this._labelContext
    },
    _checkWarp: function(e, t, n) {
        var r = e[t],
            i = this._measure(r);
        if (i > n && r.length > 1) {
            var s = r.length * (n / i) | 0,
                o = r.substr(s),
                u = i - this._measure(o),
                a, f = 0,
                l = 0;
            while (u > n && l++ < 100)
                s *= n / u, s |= 0, o = r.substr(s), u = i - this._measure(o);
            l = 0;
            while (u < n && l++ < 100) {
                if (o) {
                    var c = cc.LabelTTF._wordRex.exec(o);
                    f = c ? c[0].length : 1, a = o
                }
                s += f, o = r.substr(s), u = i - this._measure(o)
            }
            s -= f;
            var h = r.substr(0, s);
            if (cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(a || o)) {
                var p = cc.LabelTTF._lastWordRex.exec(h);
                s -= p ? p[0].length : 0, a = r.substr(s), h = r.substr(0, s)
            }
            if (cc.LabelTTF._firsrEnglish.test(a)) {
                var p = cc.LabelTTF._lastEnglish.exec(h);
                p && h !== p[0] && (s -= p[0].length, a = r.substr(s), h = r.substr(0, s))
            }
            e[t] = a || o, e.splice(t, 0, h)
        }
    },
    _updateTTF: function() {
        var e = this._dimensions.width,
            t, n, r = this._lineWidths;
        r.length = 0, this._isMultiLine = !1, this._measureConfig();
        if (e !== 0) {
            this._strings = this._string.split("\n");
            for (t = 0; t < this._strings.length; t++)
                this._checkWarp(this._strings, t, e)
        } else {
            this._strings = this._string.split("\n");
            for (t = 0, n = this._strings.length; t < n; t++)
                r.push(this._measure(this._strings[t]))
        }
        this._strings.length > 0 && (this._isMultiLine = !0);
        var i, s = 0,
            o = 0;
        this._strokeEnabled && (s = o = this._strokeSize * 2);
        if (this._shadowEnabled) {
            var u = this._shadowOffset;
            s += Math.abs(u.x) * 2, o += Math.abs(u.y) * 2
        }
        e === 0 ? this._isMultiLine ? i = cc.size(0 | Math.max.apply(Math, r) + s, 0 | this._fontClientHeight * this._strings.length + o) : i = cc.size(0 | this._measure(this._string) + s, 0 | this._fontClientHeight + o) : this._dimensions.height === 0 ? this._isMultiLine ? i = cc.size(0 | e + s, 0 | this._fontClientHeight * this._strings.length + o) : i = cc.size(0 | e + s, 0 | this._fontClientHeight + o) : i = cc.size(0 | e + s, 0 | this._dimensions.height + o), this.setContentSize(i), this._strokeShadowOffsetX = s, this._strokeShadowOffsetY = o;
        var a = this._anchorPoint;
        this._anchorPointInPoints.x = s * .5 + (i.width - s) * a.x, this._anchorPointInPoints.y = o * .5 + (i.height - o) * a.y
    },
    getContentSize: function() {
        return this._needUpdateTexture && this._updateTTF(), cc.Sprite.prototype.getContentSize.call(this)
    },
    _getWidth: function() {
        return this._needUpdateTexture && this._updateTTF(), cc.Sprite.prototype._getWidth.call(this)
    },
    _getHeight: function() {
        return this._needUpdateTexture && this._updateTTF(), cc.Sprite.prototype._getHeight.call(this)
    },
    _updateTexture: function() {
        var e = this._getLabelContext(),
            t = this._labelCanvas,
            n = this._contentSize;
        if (this._string.length === 0)
            return t.width = 1, t.height = n.height || 1, this._texture && this._texture.handleLoadedTexture(), this.setTextureRect(cc.rect(0, 0, 1, n.height)), !0;
        e.font = this._fontStyleStr, this._updateTTF();
        var r = n.width,
            i = n.height,
            s = t.width == r && t.height == i;
        return t.width = r, t.height = i, s && e.clearRect(0, 0, r, i), this._drawTTFInCanvas(e), this._texture && this._texture.handleLoadedTexture(), this.setTextureRect(cc.rect(0, 0, r, i)), !0
    },
    visit: function(e) {
        if (!this._string || this._string == "")
            return;
        this._needUpdateTexture && (this._needUpdateTexture = !1, this._updateTexture());
        var t = e || cc._renderContext;
        cc.Sprite.prototype.visit.call(this, t)
    },
    draw: null,
    _setTextureCoords: function(e) {
        var t = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (!t)
            return;
        var n = t.pixelsWidth,
            r = t.pixelsHeight,
            i, s, o, u, a, f = this._quad;
        this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (i = (2 * e.x + 1) / (2 * n), s = i + (e.height * 2 - 2) / (2 * n), o = (2 * e.y + 1) / (2 * r), u = o + (e.width * 2 - 2) / (2 * r)) : (i = e.x / n, s = (e.x + e.height) / n, o = e.y / r, u = (e.y + e.width) / r), this._flippedX && (a = o, o = u, u = a), this._flippedY && (a = i, i = s, s = a), f.bl.texCoords.u = i, f.bl.texCoords.v = o, f.br.texCoords.u = i, f.br.texCoords.v = u, f.tl.texCoords.u = s, f.tl.texCoords.v = o, f.tr.texCoords.u = s, f.tr.texCoords.v = u) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (i = (2 * e.x + 1) / (2 * n), s = i + (e.width * 2 - 2) / (2 * n), o = (2 * e.y + 1) / (2 * r), u = o + (e.height * 2 - 2) / (2 * r)) : (i = e.x / n, s = (e.x + e.width) / n, o = e.y / r, u = (e.y + e.height) / r), this._flippedX && (a = i, i = s, s = a), this._flippedY && (a = o, o = u, u = a), f.bl.texCoords.u = i, f.bl.texCoords.v = u, f.br.texCoords.u = s, f.br.texCoords.v = u, f.tl.texCoords.u = i, f.tl.texCoords.v = o, f.tr.texCoords.u = s, f.tr.texCoords.v = o), this._quadDirty = !0
    }
});
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var _p = cc.LabelTTF.prototype;
    _p.setColor = function(e) {
        cc.Node.prototype.setColor.call(this, e), this._setColorsString()
    }, _p._setColorsString = function() {
        this._needUpdateTexture = !0;
        var e = this._displayedColor,
            t = this._displayedOpacity,
            n = this._strokeColor,
            r = this._textFillColor;
        this._shadowColorStr = "rgba(" + (0 | e.r * .5) + "," + (0 | e.g * .5) + "," + (0 | e.b * .5) + "," + this._shadowOpacity + ")", this._fillColorStr = "rgba(" + (0 | e.r / 255 * r.r) + "," + (0 | e.g / 255 * r.g) + "," + (0 | e.b / 255 * r.b) + ", " + t / 255 + ")", this._strokeColorStr = "rgba(" + (0 | e.r / 255 * n.r) + "," + (0 | e.g / 255 * n.g) + "," + (0 | e.b / 255 * n.b) + ", " + t / 255 + ")"
    }, _p.updateDisplayedColor = function(e) {
        cc.Node.prototype.updateDisplayedColor.call(this, e), this._setColorsString()
    }, _p.setOpacity = function(e) {
        if (this._opacity === e)
            return;
        cc.Sprite.prototype.setOpacity.call(this, e), this._setColorsString(), this._needUpdateTexture = !0
    }, _p.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity, _p.initWithStringAndTextDefinition = function(e, t) {
        return this._updateWithTextDefinition(t, !1), this.string = e, !0
    }, _p.setFontFillColor = function(e) {
        var t = this._textFillColor;
        if (t.r != e.r || t.g != e.g || t.b != e.b)
            t.r = e.r, t.g = e.g, t.b = e.b, this._setColorsString(), this._needUpdateTexture = !0
    }, _p.draw = cc.Sprite.prototype.draw, _p.setTextureRect = function(e, t, n) {
        this._rectRotated = t || !1, n = n || e, this.setContentSize(n), this.setVertexRect(e);
        var r = this._textureRect_Canvas;
        r.x = e.x, r.y = e.y, r.width = e.width, r.height = e.height, r.validRect = !(r.width === 0 || r.height === 0 || r.x < 0 || r.y < 0);
        var i = this._unflippedOffsetPositionFromCenter;
        this._flippedX && (i.x = -i.x), this._flippedY && (i.y = -i.y), this._offsetPosition.x = i.x + (this._contentSize.width - this._rect.width) / 2, this._offsetPosition.y = i.y + (this._contentSize.height - this._rect.height) / 2, this._batchNode && (this.dirty = !0)
    }, _p = null
} else
    cc.assert(cc.isFunction(cc._tmp.WebGLLabelTTF), cc._LogInfos.MissingFile, "LabelTTFWebGL.js"), cc._tmp.WebGLLabelTTF(), delete cc._tmp.WebGLLabelTTF;
cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js"), cc._tmp.PrototypeLabelTTF(), delete cc._tmp.PrototypeLabelTTF, cc.LabelTTF._textAlign = ["left", "center", "right"], cc.LabelTTF._textBaseline = ["top", "middle", "bottom"], cc.LabelTTF.wrapInspection = !0, cc.LabelTTF._wordRex = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+|\S)/, cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>、‘“》？。，！]/, cc.LabelTTF._lastWordRex = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+|\S)$/, cc.LabelTTF._lastEnglish = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+$/, cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]/, cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/, cc.LabelTTF.create = function(e, t, n, r, i, s) {
    return new cc.LabelTTF(e, t, n, r, i, s)
}, cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create, cc.USE_LA88_LABELS ? cc.LabelTTF._SHADER_PROGRAM = cc.SHADER_POSITION_TEXTURECOLOR : cc.LabelTTF._SHADER_PROGRAM = cc.SHADER_POSITION_TEXTUREA8COLOR, cc.LabelTTF.__labelHeightDiv = cc.newElement("div"), cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial", cc.LabelTTF.__labelHeightDiv.style.position = "absolute", cc.LabelTTF.__labelHeightDiv.style.left = "-100px", cc.LabelTTF.__labelHeightDiv.style.top = "-100px", cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal", document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : cc._addEventListener(window, "load", function() {
    this.removeEventListener("load", arguments.callee, !1), document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
}, !1), cc.LabelTTF.__getFontHeightByDiv = function(e, t) {
    var n = cc.LabelTTF.__fontHeightCache[e + "." + t];
    if (n > 0)
        return n;
    var r = cc.LabelTTF.__labelHeightDiv;
    return r.innerHTML = "ajghl~!", r.style.fontFamily = e, r.style.fontSize = t + "px", n = r.clientHeight, cc.LabelTTF.__fontHeightCache[e + "." + t] = n, r.innerHTML = "", n
}, cc.LabelTTF.__fontHeightCache = {}, cc._LogInfos = {
    ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
    ActionManager_removeAction: "cocos2d: removeAction: Target not found",
    ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
    ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
    ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
    ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag = %s): Action not found",
    configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
    configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
    configuration_loadConfigFile_2: "Please load the resource first : %s",
    Director_resume: "cocos2d: Director: Error in gettimeofday",
    Director_setProjection: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
    Director_popScene: "running scene should not null",
    Director_pushScene: "the scene should not null",
    arrayVerifyType: "element type is wrong!",
    Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
    Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
    Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
    Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
    Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
    Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
    Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
    Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
    Node_getRotation: "RotationX != RotationY. Don't know which one to return",
    Node_getScale: "ScaleX != ScaleY. Don't know which one to return",
    Node_addChild: "An Node can't be added as a child of itself.",
    Node_addChild_2: "child already added. It can't be added again",
    Node_addChild_3: "child must be non-null",
    Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
    Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
    Node_removeChildByTag: "argument tag is an invalid tag",
    Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag = %s): child not found!",
    Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
    Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
    Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
    Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
    Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
    Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
    Node_reorderChild: "child must be non-null",
    Node_runAction: "cc.Node.runAction(): action must be non-null",
    Node_schedule: "callback function must be non-null",
    Node_schedule_2: "interval must be positive",
    Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
    AtlasNode_initWithTileFile: "",
    AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    _EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
    _EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
    _EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
    _EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
    EventListener_create: "Invalid parameter.",
    __getListenerID: "Don't call this method if the event is for touch.",
    eventManager__forceAddEventListener: "Invalid scene graph priority!",
    eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
    eventManager_removeListeners: "Invalid listener type!",
    eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
    eventManager_addListener_2: "Invalid parameters.",
    eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
    eventManager_addListener_4: "The listener has been registered, please don't register it again.",
    LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
    LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
    EGLView_setDesignResolutionSize: "Resolution not valid",
    EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
    inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
    swap: "cc.swap is being modified from original macro, please check usage",
    checkGLErrorDebug: "WebGL error %s",
    animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
    animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
    animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
    animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
    animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
    animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
    Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
    Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
    Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
    Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
    Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
    Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
    Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
    Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
    Sprite_initWithSpriteFrameName1: " is null, please check.",
    Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
    Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
    Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
    Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
    Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
    Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
    Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
    Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
    Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    Sprite_setSpriteFrame: "Invalid spriteFrameName",
    Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
    Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    Sprite_addChild_6: "cc.SpriteBatchNode.addChild(): child should be non-null",
    SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
    SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
    SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
    SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
    SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
    SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
    SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild():child should be non-null",
    spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
    spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
    spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
    spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
    spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
    spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
    spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
    CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
    CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
    CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
    CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
    TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
    TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
    TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
    TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
    TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
    TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
    TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
    TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
    TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
    TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
    TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
    TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
    TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
    TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
    textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
    textureCache_addPVRImage: "addPVRImage does not support on HTML5",
    textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
    textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id=%s %s x %s",
    textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
    textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
    textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
    Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
    Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
    Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
    Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
    Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
    Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
    Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
    Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithData: "NSInternalInconsistencyException",
    MissingFile: "Missing file: %s",
    radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
    RectWidth: "Rect width exceeds maximum margin: %s",
    RectHeight: "Rect height exceeds maximum margin: %s",
    EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
    EventManager__updateListeners_2: "_inDispatch should be 1 here."
}, cc._logToWebPage = function(e) {
    if (!cc._canvas)
        return;
    var t = cc._logList,
        n = document;
    if (!t) {
        var r = n.createElement("Div"),
            i = r.style;
        r.setAttribute("id", "logInfoDiv"), cc._canvas.parentNode.appendChild(r), r.setAttribute("width", "200"), r.setAttribute("height", cc._canvas.height), i.zIndex = "99999", i.position = "absolute", i.top = "0", i.left = "0", t = cc._logList = n.createElement("textarea");
        var s = t.style;
        t.setAttribute("rows", "20"), t.setAttribute("cols", "30"), t.setAttribute("disabled", !0), r.appendChild(t), s.backgroundColor = "transparent", s.borderBottom = "1px solid #cccccc", s.borderRightWidth = "0px", s.borderLeftWidth = "0px", s.borderTopWidth = "0px", s.borderTopStyle = "none", s.borderRightStyle = "none", s.borderLeftStyle = "none", s.padding = "0px", s.margin = 0
    }
    t.value = t.value + e + "\r\n", t.scrollTop = t.scrollHeight
}, cc._formatString = function(e) {
    if (!cc.isObject(e))
        return e;
    try {
        return JSON.stringify(e)
    } catch (t) {
        return ""
    }
}, cc._initDebugSetting = function(e) {
    var t = cc.game;
    if (e == t.DEBUG_MODE_NONE)
        return;
    var n;
    if (e > t.DEBUG_MODE_ERROR)
        n = cc._logToWebPage.bind(cc), cc.error = function() {
            n("ERROR :  " + cc.formatStr.apply(cc, arguments))
        }, cc.assert = function(e, t) {
            if (!e && t) {
                for (var r = 2; r < arguments.length; r++)
                    t = t.replace(/(%s)|(%d)/, cc._formatString(arguments[r]));
                n("Assert: " + t)
            }
        }, e != t.DEBUG_MODE_ERROR_FOR_WEB_PAGE && (cc.warn = function() {
            n("WARN :  " + cc.formatStr.apply(cc, arguments))
        }), e == t.DEBUG_MODE_INFO_FOR_WEB_PAGE && (cc.log = function() {
            n(cc.formatStr.apply(cc, arguments))
        });
    else {
        if (!console)
            return;
        cc.error = function() {
            return console.error.apply(console, arguments)
        }, cc.assert = function(e, t) {
            if (!e && t) {
                for (var n = 2; n < arguments.length; n++)
                    t = t.replace(/(%s)|(%d)/, cc._formatString(arguments[n]));
                throw t
            }
        }, e != t.DEBUG_MODE_ERROR && (cc.warn = function() {
            return console.warn.apply(console, arguments)
        }), e == t.DEBUG_MODE_INFO && (cc.log = function() {
            return console.log.apply(console, arguments)
        })
    }
}, cc._initDebugSetting(cc.game.config[cc.game.CONFIG_KEY.debugMode]), cc.HashElement = cc.Class.extend({
    actions: null,
    target: null,
    actionIndex: 0,
    currentAction: null,
    currentActionSalvaged: !1,
    paused: !1,
    hh: null,
    ctor: function() {
        this.actions = [], this.target = null, this.actionIndex = 0, this.currentAction = null, this.currentActionSalvaged = !1, this.paused = !1, this.hh = null
    }
}), cc.ActionManager = cc.Class.extend({
    _hashTargets: null,
    _arrayTargets: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _searchElementByTarget: function(e, t) {
        for (var n = 0; n < e.length; n++)
            if (t == e[n].target)
                return e[n];
        return null
    },
    ctor: function() {
        this._hashTargets = {}, this._arrayTargets = [], this._currentTarget = null, this._currentTargetSalvaged = !1
    },
    addAction: function(e, t, n) {
        if (!e)
            throw "cc.ActionManager.addAction(): action must be non-null";
        if (!t)
            throw "cc.ActionManager.addAction(): action must be non-null";
        var r = this._hashTargets[t.__instanceId];
        r || (r = new cc.HashElement, r.paused = n, r.target = t, this._hashTargets[t.__instanceId] = r, this._arrayTargets.push(r)), this._actionAllocWithHashElement(r), r.actions.push(e), e.startWithTarget(t)
    },
    removeAllActions: function() {
        var e = this._arrayTargets;
        for (var t = 0; t < e.length; t++) {
            var n = e[t];
            n && this.removeAllActionsFromTarget(n.target, !0)
        }
    },
    removeAllActionsFromTarget: function(e, t) {
        if (e == null)
            return;
        var n = this._hashTargets[e.__instanceId];
        n && (n.actions.indexOf(n.currentAction) !== -1 && !n.currentActionSalvaged && (n.currentActionSalvaged = !0), n.actions.length = 0, this._currentTarget == n && !t ? this._currentTargetSalvaged = !0 : this._deleteHashElement(n))
    },
    removeAction: function(e) {
        if (e == null)
            return;
        var t = e.getOriginalTarget(),
            n = this._hashTargets[t.__instanceId];
        if (n) {
            for (var r = 0; r < n.actions.length; r++)
                if (n.actions[r] == e) {
                    n.actions.splice(r, 1);
                    break
                }
        } else
            cc.log(cc._LogInfos.ActionManager_removeAction)
    },
    removeActionByTag: function(e, t) {
        e == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction), cc.assert(t, cc._LogInfos.ActionManager_addAction);
        var n = this._hashTargets[t.__instanceId];
        if (n) {
            var r = n.actions.length;
            for (var i = 0; i < r; ++i) {
                var s = n.actions[i];
                if (s && s.getTag() === e && s.getOriginalTarget() == t) {
                    this._removeActionAtIndex(i, n);
                    break
                }
            }
        }
    },
    getActionByTag: function(e, t) {
        e == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
        var n = this._hashTargets[t.__instanceId];
        if (n) {
            if (n.actions != null)
                for (var r = 0; r < n.actions.length; ++r) {
                    var i = n.actions[r];
                    if (i && i.getTag() === e)
                        return i
                }
            cc.log(cc._LogInfos.ActionManager_getActionByTag_2, e)
        }
        return null
    },
    numberOfRunningActionsInTarget: function(e) {
        var t = this._hashTargets[e.__instanceId];
        return t ? t.actions ? t.actions.length : 0 : 0
    },
    pauseTarget: function(e) {
        var t = this._hashTargets[e.__instanceId];
        t && (t.paused = !0)
    },
    resumeTarget: function(e) {
        var t = this._hashTargets[e.__instanceId];
        t && (t.paused = !1)
    },
    pauseAllRunningActions: function() {
        var e = [],
            t = this._arrayTargets;
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r && !r.paused && (r.paused = !0, e.push(r.target))
        }
        return e
    },
    resumeTargets: function(e) {
        if (!e)
            return;
        for (var t = 0; t < e.length; t++)
            e[t] && this.resumeTarget(e[t])
    },
    purgeSharedManager: function() {
        cc.director.getScheduler().unscheduleUpdateForTarget(this)
    },
    _removeActionAtIndex: function(e, t) {
        var n = t.actions[e];
        n == t.currentAction && !t.currentActionSalvaged && (t.currentActionSalvaged = !0), t.actions.splice(e, 1), t.actionIndex >= e && t.actionIndex--, t.actions.length == 0 && (this._currentTarget == t ? this._currentTargetSalvaged = !0 : this._deleteHashElement(t))
    },
    _deleteHashElement: function(e) {
        e && (delete this._hashTargets[e.target.__instanceId], cc.arrayRemoveObject(this._arrayTargets, e), e.actions = null, e.target = null)
    },
    _actionAllocWithHashElement: function(e) {
        e.actions == null && (e.actions = [])
    },
    update: function(e) {
        var t = this._arrayTargets,
            n;
        for (var r = 0; r < t.length; r++) {
            this._currentTarget = t[r], n = this._currentTarget;
            if (!n.paused)
                for (n.actionIndex = 0; n.actionIndex < n.actions.length; n.actionIndex++) {
                    n.currentAction = n.actions[n.actionIndex];
                    if (!n.currentAction)
                        continue;
                    n.currentActionSalvaged = !1, n.currentAction.step(e * (n.currentAction._speedMethod ? n.currentAction._speed : 1));
                    if (n.currentActionSalvaged)
                        n.currentAction = null;
                    else if (n.currentAction.isDone()) {
                        n.currentAction.stop();
                        var i = n.currentAction;
                        n.currentAction = null, this.removeAction(i)
                    }
                    n.currentAction = null
                }
            this._currentTargetSalvaged && n.actions.length === 0 && this._deleteHashElement(n)
        }
    }
}), cc.ACTION_TAG_INVALID = -1, cc.Action = cc.Class.extend({
    originalTarget: null,
    target: null,
    tag: cc.ACTION_TAG_INVALID,
    ctor: function() {
        this.originalTarget = null, this.target = null, this.tag = cc.ACTION_TAG_INVALID
    },
    copy: function() {
        return cc.log("copy is deprecated. Please use clone instead."), this.clone()
    },
    clone: function() {
        var e = new cc.Action;
        return e.originalTarget = null, e.target = null, e.tag = this.tag, e
    },
    isDone: function() {
        return !0
    },
    startWithTarget: function(e) {
        this.originalTarget = e, this.target = e
    },
    stop: function() {
        this.target = null
    },
    step: function(e) {
        cc.log("[Action step]. override me")
    },
    update: function(e) {
        cc.log("[Action update]. override me")
    },
    getTarget: function() {
        return this.target
    },
    setTarget: function(e) {
        this.target = e
    },
    getOriginalTarget: function() {
        return this.originalTarget
    },
    setOriginalTarget: function(e) {
        this.originalTarget = e
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(e) {
        this.tag = e
    },
    retain: function() {},
    release: function() {}
}), cc.action = function() {
    return new cc.Action
}, cc.Action.create = cc.action, cc.FiniteTimeAction = cc.Action.extend({
    _duration: 0,
    ctor: function() {
        cc.Action.prototype.ctor.call(this), this._duration = 0
    },
    getDuration: function() {
        return this._duration * (this._times || 1)
    },
    setDuration: function(e) {
        this._duration = e
    },
    reverse: function() {
        return cc.log("cocos2d: FiniteTimeAction#reverse: Implement me"), null
    },
    clone: function() {
        return new cc.FiniteTimeAction
    }
}), cc.Speed = cc.Action.extend({
    _speed: 0,
    _innerAction: null,
    ctor: function(e, t) {
        cc.Action.prototype.ctor.call(this), this._speed = 0, this._innerAction = null, e && this.initWithAction(e, t)
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(e) {
        this._speed = e
    },
    initWithAction: function(e, t) {
        if (!e)
            throw "cc.Speed.initWithAction(): action must be non nil";
        return this._innerAction = e, this._speed = t, !0
    },
    clone: function() {
        var e = new cc.Speed;
        return e.initWithAction(this._innerAction.clone(), this._speed), e
    },
    startWithTarget: function(e) {
        cc.Action.prototype.startWithTarget.call(this, e), this._innerAction.startWithTarget(e)
    },
    stop: function() {
        this._innerAction.stop(), cc.Action.prototype.stop.call(this)
    },
    step: function(e) {
        this._innerAction.step(e * this._speed)
    },
    isDone: function() {
        return this._innerAction.isDone()
    },
    reverse: function() {
        return new cc.Speed(this._innerAction.reverse(), this._speed)
    },
    setInnerAction: function(e) {
        this._innerAction != e && (this._innerAction = e)
    },
    getInnerAction: function() {
        return this._innerAction
    }
}), cc.speed = function(e, t) {
    return new cc.Speed(e, t)
}, cc.Speed.create = cc.speed, cc.Follow = cc.Action.extend({
    _followedNode: null,
    _boundarySet: !1,
    _boundaryFullyCovered: !1,
    _halfScreenSize: null,
    _fullScreenSize: null,
    _worldRect: null,
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    ctor: function(e, t) {
        cc.Action.prototype.ctor.call(this), this._followedNode = null, this._boundarySet = !1, this._boundaryFullyCovered = !1, this._halfScreenSize = null, this._fullScreenSize = null, this.leftBoundary = 0, this.rightBoundary = 0, this.topBoundary = 0, this.bottomBoundary = 0, this._worldRect = cc.rect(0, 0, 0, 0), e && (t ? this.initWithTarget(e, t) : this.initWithTarget(e))
    },
    clone: function() {
        var e = new cc.Follow,
            t = this._worldRect,
            n = new cc.Rect(t.x, t.y, t.width, t.height);
        return e.initWithTarget(this._followedNode, n), e
    },
    isBoundarySet: function() {
        return this._boundarySet
    },
    setBoudarySet: function(e) {
        this._boundarySet = e
    },
    initWithTarget: function(e, t) {
        if (!e)
            throw "cc.Follow.initWithAction(): followedNode must be non nil";
        var n = this;
        t = t || cc.rect(0, 0, 0, 0), n._followedNode = e, n._worldRect = t, n._boundarySet = !cc._rectEqualToZero(t), n._boundaryFullyCovered = !1;
        var r = cc.director.getWinSize();
        return n._fullScreenSize = cc.p(r.width, r.height), n._halfScreenSize = cc.pMult(n._fullScreenSize, .5), n._boundarySet && (n.leftBoundary = -(t.x + t.width - n._fullScreenSize.x), n.rightBoundary = -t.x, n.topBoundary = -t.y, n.bottomBoundary = -(t.y + t.height - n._fullScreenSize.y), n.rightBoundary < n.leftBoundary && (n.rightBoundary = n.leftBoundary = (n.leftBoundary + n.rightBoundary) / 2), n.topBoundary < n.bottomBoundary && (n.topBoundary = n.bottomBoundary = (n.topBoundary + n.bottomBoundary) / 2), n.topBoundary == n.bottomBoundary && n.leftBoundary == n.rightBoundary && (n._boundaryFullyCovered = !0)), !0
    },
    step: function(e) {
        var t = this._followedNode.x,
            n = this._followedNode.y;
        t = this._halfScreenSize.x - t, n = this._halfScreenSize.y - n;
        if (this._boundarySet) {
            if (this._boundaryFullyCovered)
                return;
            this.target.setPosition(cc.clampf(t, this.leftBoundary, this.rightBoundary), cc.clampf(n, this.bottomBoundary, this.topBoundary))
        } else
            this.target.setPosition(t, n)
    },
    isDone: function() {
        return !this._followedNode.running
    },
    stop: function() {
        this.target = null, cc.Action.prototype.stop.call(this)
    }
}), cc.follow = function(e, t) {
    return new cc.Follow(e, t)
}, cc.Follow.create = cc.follow, cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed: 0,
    _firstTick: !1,
    _easeList: null,
    _times: 1,
    _repeatForever: !1,
    _repeatMethod: !1,
    _speed: 1,
    _speedMethod: !1,
    ctor: function(e) {
        this._speed = 1, this._times = 1, this._repeatForever = !1, this.MAX_VALUE = 2, this._repeatMethod = !1, this._speedMethod = !1, cc.FiniteTimeAction.prototype.ctor.call(this), e !== undefined && this.initWithDuration(e)
    },
    getElapsed: function() {
        return this._elapsed
    },
    initWithDuration: function(e) {
        return this._duration = e === 0 ? cc.FLT_EPSILON : e, this._elapsed = 0, this._firstTick = !0, !0
    },
    isDone: function() {
        return this._elapsed >= this._duration
    },
    _cloneDecoration: function(e) {
        e._repeatForever = this._repeatForever, e._speed = this._speed, e._times = this._times, e._easeList = this._easeList, e._speedMethod = this._speedMethod, e._repeatMethod = this._repeatMethod
    },
    _reverseEaseList: function(e) {
        if (this._easeList) {
            e._easeList = [];
            for (var t = 0; t < this._easeList.length; t++)
                e._easeList.push(this._easeList[t].reverse())
        }
    },
    clone: function() {
        var e = new cc.ActionInterval(this._duration);
        return this._cloneDecoration(e), e
    },
    easing: function(e) {
        this._easeList ? this._easeList.length = 0 : this._easeList = [];
        for (var t = 0; t < arguments.length; t++)
            this._easeList.push(arguments[t]);
        return this
    },
    _computeEaseTime: function(e) {
        var t = this._easeList;
        if (!t || t.length === 0)
            return e;
        for (var n = 0, r = t.length; n < r; n++)
            e = t[n].easing(e);
        return e
    },
    step: function(e) {
        this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += e;
        var t = this._elapsed / (this._duration > 1.192092896e-7 ? this._duration : 1.192092896e-7);
        t = 1 > t ? t : 1, this.update(t > 0 ? t : 0), this._repeatMethod && this._times > 1 && this.isDone() && (this._repeatForever || this._times--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration))
    },
    startWithTarget: function(e) {
        cc.Action.prototype.startWithTarget.call(this, e), this._elapsed = 0, this._firstTick = !0
    },
    reverse: function() {
        return cc.log("cc.IntervalAction: reverse not implemented."), null
    },
    setAmplitudeRate: function(e) {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
    },
    getAmplitudeRate: function() {
        return cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass."), 0
    },
    speed: function(e) {
        return e <= 0 ? (cc.log("The speed parameter error"), this) : (this._speedMethod = !0, this._speed *= e, this)
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(e) {
        return this._speed = e, this
    },
    repeat: function(e) {
        return e = Math.round(e), isNaN(e) || e < 1 ? (cc.log("The repeat parameter error"), this) : (this._repeatMethod = !0, this._times *= e, this)
    },
    repeatForever: function() {
        return this._repeatMethod = !0, this._times = this.MAX_VALUE, this._repeatForever = !0, this
    }
}), cc.actionInterval = function(e) {
    return new cc.ActionInterval(e)
}, cc.ActionInterval.create = cc.actionInterval, cc.Sequence = cc.ActionInterval.extend({
    _actions: null,
    _split: null,
    _last: 0,
    ctor: function(e) {
        cc.ActionInterval.prototype.ctor.call(this), this._actions = [];
        var t = e instanceof Array ? e : arguments,
            n = t.length - 1;
        n >= 0 && t[n] == null && cc.log("parameters should not be ending with null in Javascript");
        if (n >= 0) {
            var r = t[0],
                i;
            for (var s = 1; s < n; s++)
                t[s] && (i = r, r = cc.Sequence._actionOneTwo(i, t[s]));
            this.initWithTwoActions(r, t[n])
        }
    },
    initWithTwoActions: function(e, t) {
        if (!e || !t)
            throw "cc.Sequence.initWithTwoActions(): arguments must all be non nil";
        var n = e._duration + t._duration;
        return this.initWithDuration(n), this._actions[0] = e, this._actions[1] = t, !0
    },
    clone: function() {
        var e = new cc.Sequence;
        return this._cloneDecoration(e), e.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone()), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._split = this._actions[0]._duration / this._duration, this._last = -1
    },
    stop: function() {
        this._last !== -1 && this._actions[this._last].stop(), cc.Action.prototype.stop.call(this)
    },
    update: function(e) {
        e = this._computeEaseTime(e);
        var t, n = 0,
            r = this._split,
            i = this._actions,
            s = this._last;
        e < r ? (t = r !== 0 ? e / r : 1, n === 0 && s === 1 && (i[1].update(0), i[1].stop())) : (n = 1, t = r === 1 ? 1 : (e - r) / (1 - r), s === -1 && (i[0].startWithTarget(this.target), i[0].update(1), i[0].stop()), s || (i[0].update(1), i[0].stop()));
        if (s === n && i[n].isDone())
            return;
        s !== n && i[n].startWithTarget(this.target), i[n].update(t), this._last = n
    },
    reverse: function() {
        var e = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        return this._cloneDecoration(e), this._reverseEaseList(e), e
    }
}), cc.sequence = function(e) {
    var t = e instanceof Array ? e : arguments;
    t.length > 0 && t[t.length - 1] == null && cc.log("parameters should not be ending with null in Javascript");
    var n = t[0];
    for (var r = 1; r < t.length; r++)
        t[r] && (n = cc.Sequence._actionOneTwo(n, t[r]));
    return n
}, cc.Sequence.create = cc.sequence, cc.Sequence._actionOneTwo = function(e, t) {
    var n = new cc.Sequence;
    return n.initWithTwoActions(e, t), n
}, cc.Repeat = cc.ActionInterval.extend({
    _times: 0,
    _total: 0,
    _nextDt: 0,
    _actionInstant: !1,
    _innerAction: null,
    ctor: function(e, t) {
        cc.ActionInterval.prototype.ctor.call(this), t !== undefined && this.initWithAction(e, t)
    },
    initWithAction: function(e, t) {
        var n = e._duration * t;
        return this.initWithDuration(n) ? (this._times = t, this._innerAction = e, e instanceof cc.ActionInstant && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0) : !1
    },
    clone: function() {
        var e = new cc.Repeat;
        return this._cloneDecoration(e), e.initWithAction(this._innerAction.clone(), this._times), e
    },
    startWithTarget: function(e) {
        this._total = 0, this._nextDt = this._innerAction._duration / this._duration, cc.ActionInterval.prototype.startWithTarget.call(this, e), this._innerAction.startWithTarget(e)
    },
    stop: function() {
        this._innerAction.stop(), cc.Action.prototype.stop.call(this)
    },
    update: function(e) {
        e = this._computeEaseTime(e);
        var t = this._innerAction,
            n = this._duration,
            r = this._times,
            i = this._nextDt;
        if (e >= i) {
            while (e > i && this._total < r)
                t.update(1), this._total++, t.stop(), t.startWithTarget(this.target), i += t._duration / n, this._nextDt = i;
            e >= 1 && this._total < r && this._total++, this._actionInstant || (this._total === r ? (t.update(1), t.stop()) : t.update(e - (i - t._duration / n)))
        } else
            t.update(e * r % 1)
    },
    isDone: function() {
        return this._total == this._times
    },
    reverse: function() {
        var e = new cc.Repeat(this._innerAction.reverse(), this._times);
        return this._cloneDecoration(e), this._reverseEaseList(e), e
    },
    setInnerAction: function(e) {
        this._innerAction != e && (this._innerAction = e)
    },
    getInnerAction: function() {
        return this._innerAction
    }
}), cc.repeat = function(e, t) {
    return new cc.Repeat(e, t)
}, cc.Repeat.create = cc.repeat, cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction: null,
    ctor: function(e) {
        cc.ActionInterval.prototype.ctor.call(this), this._innerAction = null, e && this.initWithAction(e)
    },
    initWithAction: function(e) {
        if (!e)
            throw "cc.RepeatForever.initWithAction(): action must be non null";
        return this._innerAction = e, !0
    },
    clone: function() {
        var e = new cc.RepeatForever;
        return this._cloneDecoration(e), e.initWithAction(this._innerAction.clone()), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._innerAction.startWithTarget(e)
    },
    step: function(e) {
        var t = this._innerAction;
        t.step(e), t.isDone() && (t.startWithTarget(this.target), t.step(t.getElapsed() - t._duration))
    },
    isDone: function() {
        return !1
    },
    reverse: function() {
        var e = new cc.RepeatForever(this._innerAction.reverse());
        return this._cloneDecoration(e), this._reverseEaseList(e), e
    },
    setInnerAction: function(e) {
        this._innerAction != e && (this._innerAction = e)
    },
    getInnerAction: function() {
        return this._innerAction
    }
}), cc.repeatForever = function(e) {
    return new cc.RepeatForever(e)
}, cc.RepeatForever.create = cc.repeatForever, cc.Spawn = cc.ActionInterval.extend({
    _one: null,
    _two: null,
    ctor: function(e) {
        cc.ActionInterval.prototype.ctor.call(this), this._one = null, this._two = null;
        var t = e instanceof Array ? e : arguments,
            n = t.length - 1;
        n >= 0 && t[n] == null && cc.log("parameters should not be ending with null in Javascript");
        if (n >= 0) {
            var r = t[0],
                i;
            for (var s = 1; s < n; s++)
                t[s] && (i = r, r = cc.Spawn._actionOneTwo(i, t[s]));
            this.initWithTwoActions(r, t[n])
        }
    },
    initWithTwoActions: function(e, t) {
        if (!e || !t)
            throw "cc.Spawn.initWithTwoActions(): arguments must all be non null";
        var n = !1,
            r = e._duration,
            i = t._duration;
        return this.initWithDuration(Math.max(r, i)) && (this._one = e, this._two = t, r > i ? this._two = cc.Sequence._actionOneTwo(t, cc.delayTime(r - i)) : r < i && (this._one = cc.Sequence._actionOneTwo(e, cc.delayTime(i - r))), n = !0), n
    },
    clone: function() {
        var e = new cc.Spawn;
        return this._cloneDecoration(e), e.initWithTwoActions(this._one.clone(), this._two.clone()), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._one.startWithTarget(e), this._two.startWithTarget(e)
    },
    stop: function() {
        this._one.stop(), this._two.stop(), cc.Action.prototype.stop.call(this)
    },
    update: function(e) {
        e = this._computeEaseTime(e), this._one && this._one.update(e), this._two && this._two.update(e)
    },
    reverse: function() {
        var e = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        return this._cloneDecoration(e), this._reverseEaseList(e), e
    }
}), cc.spawn = function(e) {
    var t = e instanceof Array ? e : arguments;
    t.length > 0 && t[t.length - 1] == null && cc.log("parameters should not be ending with null in Javascript");
    var n = t[0];
    for (var r = 1; r < t.length; r++)
        t[r] != null && (n = cc.Spawn._actionOneTwo(n, t[r]));
    return n
}, cc.Spawn.create = cc.spawn, cc.Spawn._actionOneTwo = function(e, t) {
    var n = new cc.Spawn;
    return n.initWithTwoActions(e, t), n
}, cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX: 0,
    _startAngleX: 0,
    _diffAngleX: 0,
    _dstAngleY: 0,
    _startAngleY: 0,
    _diffAngleY: 0,
    ctor: function(e, t, n) {
        cc.ActionInterval.prototype.ctor.call(this), t !== undefined && this.initWithDuration(e, t, n)
    },
    initWithDuration: function(e, t, n) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (this._dstAngleX = t || 0, this._dstAngleY = n || this._dstAngleX, !0) : !1
    },
    clone: function() {
        var e = new cc.RotateTo;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e);
        var t = e.rotationX % 360,
            n = this._dstAngleX - t;
        n > 180 && (n -= 360), n < -180 && (n += 360), this._startAngleX = t, this._diffAngleX = n, this._startAngleY = e.rotationY % 360;
        var r = this._dstAngleY - this._startAngleY;
        r > 180 && (r -= 360), r < -180 && (r += 360), this._diffAngleY = r
    },
    reverse: function() {
        cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
    },
    update: function(e) {
        e = this._computeEaseTime(e), this.target && (this.target.rotationX = this._startAngleX + this._diffAngleX * e, this.target.rotationY = this._startAngleY + this._diffAngleY * e)
    }
}), cc.rotateTo = function(e, t, n) {
    return new cc.RotateTo(e, t, n)
}, cc.RotateTo.create = cc.rotateTo, cc.RotateBy = cc.ActionInterval.extend({
    _angleX: 0,
    _startAngleX: 0,
    _angleY: 0,
    _startAngleY: 0,
    ctor: function(e, t, n) {
        cc.ActionInterval.prototype.ctor.call(this), t !== undefined && this.initWithDuration(e, t, n)
    },
    initWithDuration: function(e, t, n) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (this._angleX = t || 0, this._angleY = n || this._angleX, !0) : !1
    },
    clone: function() {
        var e = new cc.RotateBy;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._angleX, this._angleY), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._startAngleX = e.rotationX, this._startAngleY = e.rotationY
    },
    update: function(e) {
        e = this._computeEaseTime(e), this.target && (this.target.rotationX = this._startAngleX + this._angleX * e, this.target.rotationY = this._startAngleY + this._angleY * e)
    },
    reverse: function() {
        var e = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
        return this._cloneDecoration(e), this._reverseEaseList(e), e
    }
}), cc.rotateBy = function(e, t, n) {
    return new cc.RotateBy(e, t, n)
}, cc.RotateBy.create = cc.rotateBy, cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(e, t, n) {
        cc.ActionInterval.prototype.ctor.call(this), this._positionDelta = cc.p(0, 0), this._startPosition = cc.p(0, 0), this._previousPosition = cc.p(0, 0), t !== undefined && this.initWithDuration(e, t, n)
    },
    initWithDuration: function(e, t, n) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (t.x !== undefined && (n = t.y, t = t.x), this._positionDelta.x = t, this._positionDelta.y = n, !0) : !1
    },
    clone: function() {
        var e = new cc.MoveBy;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._positionDelta), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e);
        var t = e.getPositionX(),
            n = e.getPositionY();
        this._previousPosition.x = t, this._previousPosition.y = n, this._startPosition.x = t, this._startPosition.y = n
    },
    update: function(e) {
        e = this._computeEaseTime(e);
        if (this.target) {
            var t = this._positionDelta.x * e,
                n = this._positionDelta.y * e,
                r = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var i = this.target.getPositionX(),
                    s = this.target.getPositionY(),
                    o = this._previousPosition;
                r.x = r.x + i - o.x, r.y = r.y + s - o.y, t += r.x, n += r.y, o.x = t, o.y = n, this.target.setPosition(t, n)
            } else
                this.target.setPosition(r.x + t, r.y + n)
        }
    },
    reverse: function() {
        var e = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
        return this._cloneDecoration(e), this._reverseEaseList(e), e
    }
}), cc.moveBy = function(e, t, n) {
    return new cc.MoveBy(e, t, n)
}, cc.MoveBy.create = cc.moveBy, cc.MoveTo = cc.MoveBy.extend({
    _endPosition: null,
    ctor: function(e, t, n) {
        cc.MoveBy.prototype.ctor.call(this), this._endPosition = cc.p(0, 0), t !== undefined && this.initWithDuration(e, t, n)
    },
    initWithDuration: function(e, t, n) {
        return cc.MoveBy.prototype.initWithDuration.call(this, e, t, n) ? (t.x !== undefined && (n = t.y, t = t.x), this._endPosition.x = t, this._endPosition.y = n, !0) : !1
    },
    clone: function() {
        var e = new cc.MoveTo;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._endPosition), e
    },
    startWithTarget: function(e) {
        cc.MoveBy.prototype.startWithTarget.call(this, e), this._positionDelta.x = this._endPosition.x - e.getPositionX(), this._positionDelta.y = this._endPosition.y - e.getPositionY()
    }
}), cc.moveTo = function(e, t, n) {
    return new cc.MoveTo(e, t, n)
}, cc.MoveTo.create = cc.moveTo, cc.SkewTo = cc.ActionInterval.extend({
    _skewX: 0,
    _skewY: 0,
    _startSkewX: 0,
    _startSkewY: 0,
    _endSkewX: 0,
    _endSkewY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(e, t, n) {
        cc.ActionInterval.prototype.ctor.call(this), n !== undefined && this.initWithDuration(e, t, n)
    },
    initWithDuration: function(e, t, n) {
        var r = !1;
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) && (this._endSkewX = t, this._endSkewY = n, r = !0), r
    },
    clone: function() {
        var e = new cc.SkewTo;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._endSkewX, this._endSkewY), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._startSkewX = e.skewX % 180, this._deltaX = this._endSkewX - this._startSkewX, this._deltaX > 180 && (this._deltaX -= 360), this._deltaX < -180 && (this._deltaX += 360), this._startSkewY = e.skewY % 360, this._deltaY = this._endSkewY - this._startSkewY, this._deltaY > 180 && (this._deltaY -= 360), this._deltaY < -180 && (this._deltaY += 360)
    },
    update: function(e) {
        e = this._computeEaseTime(e), this.target.skewX = this._startSkewX + this._deltaX * e, this.target.skewY = this._startSkewY + this._deltaY * e
    }
}), cc.skewTo = function(e, t, n) {
    return new cc.SkewTo(e, t, n)
}, cc.SkewTo.create = cc.skewTo, cc.SkewBy = cc.SkewTo.extend({
    ctor: function(e, t, n) {
        cc.SkewTo.prototype.ctor.call(this), n !== undefined && this.initWithDuration(e, t, n)
    },
    initWithDuration: function(e, t, n) {
        var r = !1;
        return cc.SkewTo.prototype.initWithDuration.call(this, e, t, n) && (this._skewX = t, this._skewY = n, r = !0), r
    },
    clone: function() {
        var e = new cc.SkewBy;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._skewX, this._skewY), e
    },
    startWithTarget: function(e) {
        cc.SkewTo.prototype.startWithTarget.call(this, e), this._deltaX = this._skewX, this._deltaY = this._skewY, this._endSkewX = this._startSkewX + this._deltaX, this._endSkewY = this._startSkewY + this._deltaY
    },
    reverse: function() {
        var e = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
        return this._cloneDecoration(e), this._reverseEaseList(e), e
    }
}), cc.skewBy = function(e, t, n) {
    return new cc.SkewBy(e, t, n)
}, cc.SkewBy.create = cc.skewBy, cc.JumpBy = cc.ActionInterval.extend({
    _startPosition: null,
    _delta: null,
    _height: 0,
    _jumps: 0,
    _previousPosition: null,
    ctor: function(e, t, n, r, i) {
        cc.ActionInterval.prototype.ctor.call(this), this._startPosition = cc.p(0, 0), this._previousPosition = cc.p(0, 0), this._delta = cc.p(0, 0), r !== undefined && this.initWithDuration(e, t, n, r, i)
    },
    initWithDuration: function(e, t, n, r, i) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (i === undefined && (i = r, r = n, n = t.y, t = t.x), this._delta.x = t, this._delta.y = n, this._height = r, this._jumps = i, !0) : !1
    },
    clone: function() {
        var e = new cc.JumpBy;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._delta, this._height, this._jumps), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e);
        var t = e.getPositionX(),
            n = e.getPositionY();
        this._previousPosition.x = t, this._previousPosition.y = n, this._startPosition.x = t, this._startPosition.y = n
    },
    update: function(e) {
        e = this._computeEaseTime(e);
        if (this.target) {
            var t = e * this._jumps % 1,
                n = this._height * 4 * t * (1 - t);
            n += this._delta.y * e;
            var r = this._delta.x * e,
                i = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var s = this.target.getPositionX(),
                    o = this.target.getPositionY(),
                    u = this._previousPosition;
                i.x = i.x + s - u.x, i.y = i.y + o - u.y, r += i.x, n += i.y, u.x = r, u.y = n, this.target.setPosition(r, n)
            } else
                this.target.setPosition(i.x + r, i.y + n)
        }
    },
    reverse: function() {
        var e = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
        return this._cloneDecoration(e), this._reverseEaseList(e), e
    }
}), cc.jumpBy = function(e, t, n, r, i) {
    return new cc.JumpBy(e, t, n, r, i)
}, cc.JumpBy.create = cc.jumpBy, cc.JumpTo = cc.JumpBy.extend({
    _endPosition: null,
    ctor: function(e, t, n, r, i) {
        cc.JumpBy.prototype.ctor.call(this), this._endPosition = cc.p(0, 0), r !== undefined && this.initWithDuration(e, t, n, r, i)
    },
    initWithDuration: function(e, t, n, r, i) {
        return cc.JumpBy.prototype.initWithDuration.call(this, e, t, n, r, i) ? (i === undefined && (n = t.y, t = t.x), this._endPosition.x = t, this._endPosition.y = n, !0) : !1
    },
    startWithTarget: function(e) {
        cc.JumpBy.prototype.startWithTarget.call(this, e), this._delta.x = this._endPosition.x - this._startPosition.x, this._delta.y = this._endPosition.y - this._startPosition.y
    },
    clone: function() {
        var e = new cc.JumpTo;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._endPosition, this._height, this._jumps), e
    }
}), cc.jumpTo = function(e, t, n, r, i) {
    return new cc.JumpTo(e, t, n, r, i)
}, cc.JumpTo.create = cc.jumpTo, cc.bezierAt = function(e, t, n, r, i) {
    return Math.pow(1 - i, 3) * e + 3 * i * Math.pow(1 - i, 2) * t + 3 * Math.pow(i, 2) * (1 - i) * n + Math.pow(i, 3) * r
}, cc.BezierBy = cc.ActionInterval.extend({
    _config: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(e, t) {
        cc.ActionInterval.prototype.ctor.call(this), this._config = [], this._startPosition = cc.p(0, 0), this._previousPosition = cc.p(0, 0), t && this.initWithDuration(e, t)
    },
    initWithDuration: function(e, t) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (this._config = t, !0) : !1
    },
    clone: function() {
        var e = new cc.BezierBy;
        this._cloneDecoration(e);
        var t = [];
        for (var n = 0; n < this._config.length; n++) {
            var r = this._config[n];
            t.push(cc.p(r.x, r.y))
        }
        return e.initWithDuration(this._duration, t), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e);
        var t = e.getPositionX(),
            n = e.getPositionY();
        this._previousPosition.x = t, this._previousPosition.y = n, this._startPosition.x = t, this._startPosition.y = n
    },
    update: function(e) {
        e = this._computeEaseTime(e);
        if (this.target) {
            var t = this._config,
                n = 0,
                r = t[0].x,
                i = t[1].x,
                s = t[2].x,
                o = 0,
                u = t[0].y,
                a = t[1].y,
                f = t[2].y,
                l = cc.bezierAt(n, r, i, s, e),
                c = cc.bezierAt(o, u, a, f, e),
                h = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var p = this.target.getPositionX(),
                    d = this.target.getPositionY(),
                    v = this._previousPosition;
                h.x = h.x + p - v.x, h.y = h.y + d - v.y, l += h.x, c += h.y, v.x = l, v.y = c, this.target.setPosition(l, c)
            } else
                this.target.setPosition(h.x + l, h.y + c)
        }
    },
    reverse: function() {
        var e = this._config,
            t = [cc.pAdd(e[1], cc.pNeg(e[2])), cc.pAdd(e[0], cc.pNeg(e[2])), cc.pNeg(e[2])],
            n = new cc.BezierBy(this._duration, t);
        return this._cloneDecoration(n), this._reverseEaseList(n), n
    }
}), cc.bezierBy = function(e, t) {
    return new cc.BezierBy(e, t)
}, cc.BezierBy.create = cc.bezierBy, cc.BezierTo = cc.BezierBy.extend({
    _toConfig: null,
    ctor: function(e, t) {
        cc.BezierBy.prototype.ctor.call(this), this._toConfig = [], t && this.initWithDuration(e, t)
    },
    initWithDuration: function(e, t) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (this._toConfig = t, !0) : !1
    },
    clone: function() {
        var e = new cc.BezierTo;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._toConfig), e
    },
    startWithTarget: function(e) {
        cc.BezierBy.prototype.startWithTarget.call(this, e);
        var t = this._startPosition,
            n = this._toConfig,
            r = this._config;
        r[0] = cc.pSub(n[0], t), r[1] = cc.pSub(n[1], t), r[2] = cc.pSub(n[2], t)
    }
}), cc.bezierTo = function(e, t) {
    return new cc.BezierTo(e, t)
}, cc.BezierTo.create = cc.bezierTo, cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX: 1,
    _scaleY: 1,
    _startScaleX: 1,
    _startScaleY: 1,
    _endScaleX: 0,
    _endScaleY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(e, t, n) {
        cc.ActionInterval.prototype.ctor.call(this), t !== undefined && this.initWithDuration(e, t, n)
    },
    initWithDuration: function(e, t, n) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (this._endScaleX = t, this._endScaleY = n != null ? n : t, !0) : !1
    },
    clone: function() {
        var e = new cc.ScaleTo;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._endScaleX, this._endScaleY), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._startScaleX = e.scaleX, this._startScaleY = e.scaleY, this._deltaX = this._endScaleX - this._startScaleX, this._deltaY = this._endScaleY - this._startScaleY
    },
    update: function(e) {
        e = this._computeEaseTime(e), this.target && (this.target.scaleX = this._startScaleX + this._deltaX * e, this.target.scaleY = this._startScaleY + this._deltaY * e)
    }
}), cc.scaleTo = function(e, t, n) {
    return new cc.ScaleTo(e, t, n)
}, cc.ScaleTo.create = cc.scaleTo, cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget: function(e) {
        cc.ScaleTo.prototype.startWithTarget.call(this, e), this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX, this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
    },
    reverse: function() {
        var e = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        return this._cloneDecoration(e), this._reverseEaseList(e), e
    },
    clone: function() {
        var e = new cc.ScaleBy;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._endScaleX, this._endScaleY), e
    }
}), cc.scaleBy = function(e, t, n) {
    return new cc.ScaleBy(e, t, n)
}, cc.ScaleBy.create = cc.scaleBy, cc.Blink = cc.ActionInterval.extend({
    _times: 0,
    _originalState: !1,
    ctor: function(e, t) {
        cc.ActionInterval.prototype.ctor.call(this), t !== undefined && this.initWithDuration(e, t)
    },
    initWithDuration: function(e, t) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (this._times = t, !0) : !1
    },
    clone: function() {
        var e = new cc.Blink;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._times), e
    },
    update: function(e) {
        e = this._computeEaseTime(e);
        if (this.target && !this.isDone()) {
            var t = 1 / this._times,
                n = e % t;
            this.target.visible = n > t / 2
        }
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._originalState = e.visible
    },
    stop: function() {
        this.target.visible = this._originalState, cc.ActionInterval.prototype.stop.call(this)
    },
    reverse: function() {
        var e = new cc.Blink(this._duration, this._times);
        return this._cloneDecoration(e), this._reverseEaseList(e), e
    }
}), cc.blink = function(e, t) {
    return new cc.Blink(e, t)
}, cc.Blink.create = cc.blink, cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity: 0,
    _fromOpacity: 0,
    ctor: function(e, t) {
        cc.ActionInterval.prototype.ctor.call(this), t !== undefined && this.initWithDuration(e, t)
    },
    initWithDuration: function(e, t) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (this._toOpacity = t, !0) : !1
    },
    clone: function() {
        var e = new cc.FadeTo;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._toOpacity), e
    },
    update: function(e) {
        e = this._computeEaseTime(e);
        var t = this._fromOpacity !== undefined ? this._fromOpacity : 255;
        this.target.opacity = t + (this._toOpacity - t) * e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._fromOpacity = e.opacity
    }
}), cc.fadeTo = function(e, t) {
    return new cc.FadeTo(e, t)
}, cc.FadeTo.create = cc.fadeTo, cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: null,
    ctor: function(e) {
        cc.FadeTo.prototype.ctor.call(this), e && this.initWithDuration(e, 255)
    },
    reverse: function() {
        var e = new cc.FadeOut;
        return e.initWithDuration(this._duration, 0), this._cloneDecoration(e), this._reverseEaseList(e), e
    },
    clone: function() {
        var e = new cc.FadeIn;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._toOpacity), e
    },
    startWithTarget: function(e) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity), cc.FadeTo.prototype.startWithTarget.call(this, e)
    }
}), cc.fadeIn = function(e) {
    return new cc.FadeIn(e)
}, cc.FadeIn.create = cc.fadeIn, cc.FadeOut = cc.FadeTo.extend({
    ctor: function(e) {
        cc.FadeTo.prototype.ctor.call(this), e && this.initWithDuration(e, 0)
    },
    reverse: function() {
        var e = new cc.FadeIn;
        return e._reverseAction = this, e.initWithDuration(this._duration, 255), this._cloneDecoration(e), this._reverseEaseList(e), e
    },
    clone: function() {
        var e = new cc.FadeOut;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._toOpacity), e
    }
}), cc.fadeOut = function(e) {
    return new cc.FadeOut(e)
}, cc.FadeOut.create = cc.fadeOut, cc.TintTo = cc.ActionInterval.extend({
    _to: null,
    _from: null,
    ctor: function(e, t, n, r) {
        cc.ActionInterval.prototype.ctor.call(this), this._to = cc.color(0, 0, 0), this._from = cc.color(0, 0, 0), r !== undefined && this.initWithDuration(e, t, n, r)
    },
    initWithDuration: function(e, t, n, r) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (this._to = cc.color(t, n, r), !0) : !1
    },
    clone: function() {
        var e = new cc.TintTo;
        this._cloneDecoration(e);
        var t = this._to;
        return e.initWithDuration(this._duration, t.r, t.g, t.b), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._from = this.target.color
    },
    update: function(e) {
        e = this._computeEaseTime(e);
        var t = this._from,
            n = this._to;
        t && (this.target.color = cc.color(t.r + (n.r - t.r) * e, t.g + (n.g - t.g) * e, t.b + (n.b - t.b) * e))
    }
}), cc.tintTo = function(e, t, n, r) {
    return new cc.TintTo(e, t, n, r)
}, cc.TintTo.create = cc.tintTo, cc.TintBy = cc.ActionInterval.extend({
    _deltaR: 0,
    _deltaG: 0,
    _deltaB: 0,
    _fromR: 0,
    _fromG: 0,
    _fromB: 0,
    ctor: function(e, t, n, r) {
        cc.ActionInterval.prototype.ctor.call(this), r !== undefined && this.initWithDuration(e, t, n, r)
    },
    initWithDuration: function(e, t, n, r) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (this._deltaR = t, this._deltaG = n, this._deltaB = r, !0) : !1
    },
    clone: function() {
        var e = new cc.TintBy;
        return this._cloneDecoration(e), e.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e);
        var t = e.color;
        this._fromR = t.r, this._fromG = t.g, this._fromB = t.b
    },
    update: function(e) {
        e = this._computeEaseTime(e), this.target.color = cc.color(this._fromR + this._deltaR * e, this._fromG + this._deltaG * e, this._fromB + this._deltaB * e)
    },
    reverse: function() {
        var e = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        return this._cloneDecoration(e), this._reverseEaseList(e), e
    }
}), cc.tintBy = function(e, t, n, r) {
    return new cc.TintBy(e, t, n, r)
}, cc.TintBy.create = cc.tintBy, cc.DelayTime = cc.ActionInterval.extend({
    update: function(e) {},
    reverse: function() {
        var e = new cc.DelayTime(this._duration);
        return this._cloneDecoration(e), this._reverseEaseList(e), e
    },
    clone: function() {
        var e = new cc.DelayTime;
        return this._cloneDecoration(e), e.initWithDuration(this._duration), e
    }
}), cc.delayTime = function(e) {
    return new cc.DelayTime(e)
}, cc.DelayTime.create = cc.delayTime, cc.ReverseTime = cc.ActionInterval.extend({
    _other: null,
    ctor: function(e) {
        cc.ActionInterval.prototype.ctor.call(this), this._other = null, e && this.initWithAction(e)
    },
    initWithAction: function(e) {
        if (!e)
            throw "cc.ReverseTime.initWithAction(): action must be non null";
        if (e == this._other)
            throw "cc.ReverseTime.initWithAction(): the action was already passed in.";
        return cc.ActionInterval.prototype.initWithDuration.call(this, e._duration) ? (this._other = e, !0) : !1
    },
    clone: function() {
        var e = new cc.ReverseTime;
        return this._cloneDecoration(e), e.initWithAction(this._other.clone()), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._other.startWithTarget(e)
    },
    update: function(e) {
        e = this._computeEaseTime(e), this._other && this._other.update(1 - e)
    },
    reverse: function() {
        return this._other.clone()
    },
    stop: function() {
        this._other.stop(), cc.Action.prototype.stop.call(this)
    }
}), cc.reverseTime = function(e) {
    return new cc.ReverseTime(e)
}, cc.ReverseTime.create = cc.reverseTime, cc.Animate = cc.ActionInterval.extend({
    _animation: null,
    _nextFrame: 0,
    _origFrame: null,
    _executedLoops: 0,
    _splitTimes: null,
    ctor: function(e) {
        cc.ActionInterval.prototype.ctor.call(this), this._splitTimes = [], e && this.initWithAnimation(e)
    },
    getAnimation: function() {
        return this._animation
    },
    setAnimation: function(e) {
        this._animation = e
    },
    initWithAnimation: function(e) {
        if (!e)
            throw "cc.Animate.initWithAnimation(): animation must be non-NULL";
        var t = e.getDuration();
        if (this.initWithDuration(t * e.getLoops())) {
            this._nextFrame = 0, this.setAnimation(e), this._origFrame = null, this._executedLoops = 0;
            var n = this._splitTimes;
            n.length = 0;
            var r = 0,
                i = t / e.getTotalDelayUnits(),
                s = e.getFrames();
            cc.arrayVerifyType(s, cc.AnimationFrame);
            for (var o = 0; o < s.length; o++) {
                var u = s[o],
                    a = r * i / t;
                r += u.getDelayUnits(), n.push(a)
            }
            return !0
        }
        return !1
    },
    clone: function() {
        var e = new cc.Animate;
        return this._cloneDecoration(e), e.initWithAnimation(this._animation.clone()), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._animation.getRestoreOriginalFrame() && (this._origFrame = e.displayFrame()), this._nextFrame = 0, this._executedLoops = 0
    },
    update: function(e) {
        e = this._computeEaseTime(e);
        if (e < 1) {
            e *= this._animation.getLoops();
            var t = 0 | e;
            t > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), e %= 1
        }
        var n = this._animation.getFrames(),
            r = n.length,
            i = this._splitTimes;
        for (var s = this._nextFrame; s < r; s++) {
            if (!(i[s] <= e))
                break;
            this.target.setSpriteFrame(n[s].getSpriteFrame()), this._nextFrame = s + 1
        }
    },
    reverse: function() {
        var e = this._animation,
            t = e.getFrames(),
            n = [];
        cc.arrayVerifyType(t, cc.AnimationFrame);
        if (t.length > 0)
            for (var r = t.length - 1; r >= 0; r--) {
                var i = t[r];
                if (!i)
                    break;
                n.push(i.clone())
            }
        var s = new cc.Animation(n, e.getDelayPerUnit(), e.getLoops());
        s.setRestoreOriginalFrame(e.getRestoreOriginalFrame());
        var o = new cc.Animate(s);
        return this._cloneDecoration(o), this._reverseEaseList(o), o
    },
    stop: function() {
        this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame), cc.Action.prototype.stop.call(this)
    }
}), cc.animate = function(e) {
    return new cc.Animate(e)
}, cc.Animate.create = cc.animate, cc.TargetedAction = cc.ActionInterval.extend({
    _action: null,
    _forcedTarget: null,
    ctor: function(e, t) {
        cc.ActionInterval.prototype.ctor.call(this), t && this.initWithTarget(e, t)
    },
    initWithTarget: function(e, t) {
        return this.initWithDuration(t._duration) ? (this._forcedTarget = e, this._action = t, !0) : !1
    },
    clone: function() {
        var e = new cc.TargetedAction;
        return this._cloneDecoration(e), e.initWithTarget(this._forcedTarget, this._action.clone()), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._action.startWithTarget(this._forcedTarget)
    },
    stop: function() {
        this._action.stop()
    },
    update: function(e) {
        e = this._computeEaseTime(e), this._action.update(e)
    },
    getForcedTarget: function() {
        return this._forcedTarget
    },
    setForcedTarget: function(e) {
        this._forcedTarget != e && (this._forcedTarget = e)
    }
}), cc.targetedAction = function(e, t) {
    return new cc.TargetedAction(e, t)
}, cc.TargetedAction.create = cc.targetedAction, cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone: function() {
        return !0
    },
    step: function(e) {
        this.update(1)
    },
    update: function(e) {},
    reverse: function() {
        return this.clone()
    },
    clone: function() {
        return new cc.ActionInstant
    }
}), cc.Show = cc.ActionInstant.extend({
    update: function(e) {
        this.target.visible = !0
    },
    reverse: function() {
        return new cc.Hide
    },
    clone: function() {
        return new cc.Show
    }
}), cc.show = function() {
    return new cc.Show
}, cc.Show.create = cc.show, cc.Hide = cc.ActionInstant.extend({
    update: function(e) {
        this.target.visible = !1
    },
    reverse: function() {
        return new cc.Show
    },
    clone: function() {
        return new cc.Hide
    }
}), cc.hide = function() {
    return new cc.Hide
}, cc.Hide.create = cc.hide, cc.ToggleVisibility = cc.ActionInstant.extend({
    update: function(e) {
        this.target.visible = !this.target.visible
    },
    reverse: function() {
        return new cc.ToggleVisibility
    },
    clone: function() {
        return new cc.ToggleVisibility
    }
}), cc.toggleVisibility = function() {
    return new cc.ToggleVisibility
}, cc.ToggleVisibility.create = cc.toggleVisibility, cc.RemoveSelf = cc.ActionInstant.extend({
    _isNeedCleanUp: !0,
    ctor: function(e) {
        cc.FiniteTimeAction.prototype.ctor.call(this), e !== undefined && this.init(e)
    },
    update: function(e) {
        this.target.removeFromParent(this._isNeedCleanUp)
    },
    init: function(e) {
        return this._isNeedCleanUp = e, !0
    },
    reverse: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    },
    clone: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    }
}), cc.removeSelf = function(e) {
    return new cc.RemoveSelf(e)
}, cc.RemoveSelf.create = cc.removeSelf, cc.FlipX = cc.ActionInstant.extend({
    _flippedX: !1,
    ctor: function(e) {
        cc.FiniteTimeAction.prototype.ctor.call(this), this._flippedX = !1, e !== undefined && this.initWithFlipX(e)
    },
    initWithFlipX: function(e) {
        return this._flippedX = e, !0
    },
    update: function(e) {
        this.target.flippedX = this._flippedX
    },
    reverse: function() {
        return new cc.FlipX(!this._flippedX)
    },
    clone: function() {
        var e = new cc.FlipX;
        return e.initWithFlipX(this._flippedX), e
    }
}), cc.flipX = function(e) {
    return new cc.FlipX(e)
}, cc.FlipX.create = cc.flipX, cc.FlipY = cc.ActionInstant.extend({
    _flippedY: !1,
    ctor: function(e) {
        cc.FiniteTimeAction.prototype.ctor.call(this), this._flippedY = !1, e !== undefined && this.initWithFlipY(e)
    },
    initWithFlipY: function(e) {
        return this._flippedY = e, !0
    },
    update: function(e) {
        this.target.flippedY = this._flippedY
    },
    reverse: function() {
        return new cc.FlipY(!this._flippedY)
    },
    clone: function() {
        var e = new cc.FlipY;
        return e.initWithFlipY(this._flippedY), e
    }
}), cc.flipY = function(e) {
    return new cc.FlipY(e)
}, cc.FlipY.create = cc.flipY, cc.Place = cc.ActionInstant.extend({
    _x: 0,
    _y: 0,
    ctor: function(e, t) {
        cc.FiniteTimeAction.prototype.ctor.call(this), this._x = 0, this._y = 0, e !== undefined && (e.x !== undefined && (t = e.y, e = e.x), this.initWithPosition(e, t))
    },
    initWithPosition: function(e, t) {
        return this._x = e, this._y = t, !0
    },
    update: function(e) {
        this.target.setPosition(this._x, this._y)
    },
    clone: function() {
        var e = new cc.Place;
        return e.initWithPosition(this._x, this._y), e
    }
}), cc.place = function(e, t) {
    return new cc.Place(e, t)
}, cc.Place.create = cc.place, cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget: null,
    _callFunc: null,
    _function: null,
    _data: null,
    ctor: function(e, t, n) {
        cc.FiniteTimeAction.prototype.ctor.call(this), e !== undefined && (t === undefined ? this.initWithFunction(e) : this.initWithFunction(e, t, n))
    },
    initWithFunction: function(e, t, n) {
        return t ? (this._data = n, this._callFunc = e, this._selectorTarget = t) : e && (this._function = e), !0
    },
    execute: function() {
        this._callFunc != null ? this._callFunc.call(this._selectorTarget, this.target, this._data) : this._function && this._function.call(null, this.target)
    },
    update: function(e) {
        this.execute()
    },
    getTargetCallback: function() {
        return this._selectorTarget
    },
    setTargetCallback: function(e) {
        e != this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = e)
    },
    clone: function() {
        var e = new cc.CallFunc;
        return this._selectorTarget ? e.initWithFunction(this._callFunc, this._selectorTarget, this._data) : this._function && e.initWithFunction(this._function), e
    }
}), cc.callFunc = function(e, t, n) {
    return new cc.CallFunc(e, t, n)
}, cc.CallFunc.create = cc.callFunc, cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig: 0,
    _centerYOrig: 0,
    _centerZOrig: 0,
    _eyeXOrig: 0,
    _eyeYOrig: 0,
    _eyeZOrig: 0,
    _upXOrig: 0,
    _upYOrig: 0,
    _upZOrig: 0,
    ctor: function() {
        var e = this;
        cc.ActionInterval.prototype.ctor.call(e), e._centerXOrig = 0, e._centerYOrig = 0, e._centerZOrig = 0, e._eyeXOrig = 0, e._eyeYOrig = 0, e._eyeZOrig = 0, e._upXOrig = 0, e._upYOrig = 0, e._upZOrig = 0
    },
    startWithTarget: function(e) {
        var t = this;
        cc.ActionInterval.prototype.startWithTarget.call(t, e);
        var n = e.getCamera(),
            r = n.getCenter();
        t._centerXOrig = r.x, t._centerYOrig = r.y, t._centerZOrig = r.z;
        var i = n.getEye();
        t._eyeXOrig = i.x, t._eyeYOrig = i.y, t._eyeZOrig = i.z;
        var s = n.getUp();
        t._upXOrig = s.x, t._upYOrig = s.y, t._upZOrig = s.z
    },
    clone: function() {
        return new cc.ActionCamera
    },
    reverse: function() {
        return new cc.ReverseTime(this)
    }
}), cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: 0,
    _deltaRadius: 0,
    _angleZ: 0,
    _deltaAngleZ: 0,
    _angleX: 0,
    _deltaAngleX: 0,
    _radZ: 0,
    _radDeltaZ: 0,
    _radX: 0,
    _radDeltaX: 0,
    ctor: function(e, t, n, r, i, s, o) {
        cc.ActionCamera.prototype.ctor.call(this), o !== undefined && this.initWithDuration(e, t, n, r, i, s, o)
    },
    initWithDuration: function(e, t, n, r, i, s, o) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, e)) {
            var u = this;
            return u._radius = t, u._deltaRadius = n, u._angleZ = r, u._deltaAngleZ = i, u._angleX = s, u._deltaAngleX = o, u._radDeltaZ = cc.degreesToRadians(i), u._radDeltaX = cc.degreesToRadians(o), !0
        }
        return !1
    },
    sphericalRadius: function() {
        var e, t, n, r = this.target.getCamera(),
            i = r.getEye(),
            s = r.getCenter(),
            o = i.x - s.x,
            u = i.y - s.y,
            a = i.z - s.z,
            f = Math.sqrt(Math.pow(o, 2) + Math.pow(u, 2) + Math.pow(a, 2)),
            l = Math.sqrt(Math.pow(o, 2) + Math.pow(u, 2));
        return l === 0 && (l = cc.FLT_EPSILON), f === 0 && (f = cc.FLT_EPSILON), t = Math.acos(a / f), o < 0 ? n = Math.PI - Math.asin(u / l) : n = Math.asin(u / l), e = f / cc.Camera.getZEye(), {
            newRadius: e,
            zenith: t,
            azimuth: n
        }
    },
    startWithTarget: function(e) {
        var t = this;
        cc.ActionInterval.prototype.startWithTarget.call(t, e);
        var n = t.sphericalRadius();
        isNaN(t._radius) && (t._radius = n.newRadius), isNaN(t._angleZ) && (t._angleZ = cc.radiansToDegrees(n.zenith)), isNaN(t._angleX) && (t._angleX = cc.radiansToDegrees(n.azimuth)), t._radZ = cc.degreesToRadians(t._angleZ), t._radX = cc.degreesToRadians(t._angleX)
    },
    clone: function() {
        var e = new cc.OrbitCamera,
            t = this;
        return e.initWithDuration(t._duration, t._radius, t._deltaRadius, t._angleZ, t._deltaAngleZ, t._angleX, t._deltaAngleX), e
    },
    update: function(e) {
        e = this._computeEaseTime(e);
        var t = (this._radius + this._deltaRadius * e) * cc.Camera.getZEye(),
            n = this._radZ + this._radDeltaZ * e,
            r = this._radX + this._radDeltaX * e,
            i = Math.sin(n) * Math.cos(r) * t + this._centerXOrig,
            s = Math.sin(n) * Math.sin(r) * t + this._centerYOrig,
            o = Math.cos(n) * t + this._centerZOrig;
        this.target.getCamera().setEye(i, s, o)
    }
}), cc.orbitCamera = function(e, t, n, r, i, s, o) {
    return new cc.OrbitCamera(e, t, n, r, i, s, o)
}, cc.OrbitCamera.create = cc.orbitCamera, cc.ActionEase = cc.ActionInterval.extend({
    _inner: null,
    ctor: function(e) {
        cc.ActionInterval.prototype.ctor.call(this), e && this.initWithAction(e)
    },
    initWithAction: function(e) {
        if (!e)
            throw "cc.ActionEase.initWithAction(): action must be non nil";
        return this.initWithDuration(e.getDuration()) ? (this._inner = e, !0) : !1
    },
    clone: function() {
        var e = new cc.ActionEase;
        return e.initWithAction(this._inner.clone()), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._inner.startWithTarget(this.target)
    },
    stop: function() {
        this._inner.stop(), cc.ActionInterval.prototype.stop.call(this)
    },
    update: function(e) {
        this._inner.update(e)
    },
    reverse: function() {
        return new cc.ActionEase(this._inner.reverse())
    },
    getInnerAction: function() {
        return this._inner
    }
}), cc.actionEase = function(e) {
    return new cc.ActionEase(e)
}, cc.ActionEase.create = cc.actionEase, cc.EaseRateAction = cc.ActionEase.extend({
    _rate: 0,
    ctor: function(e, t) {
        cc.ActionEase.prototype.ctor.call(this), t !== undefined && this.initWithAction(e, t)
    },
    setRate: function(e) {
        this._rate = e
    },
    getRate: function() {
        return this._rate
    },
    initWithAction: function(e, t) {
        return cc.ActionEase.prototype.initWithAction.call(this, e) ? (this._rate = t, !0) : !1
    },
    clone: function() {
        var e = new cc.EaseRateAction;
        return e.initWithAction(this._inner.clone(), this._rate), e
    },
    reverse: function() {
        return new cc.EaseRateAction(this._inner.reverse(), 1 / this._rate)
    }
}), cc.easeRateAction = function(e, t) {
    return new cc.EaseRateAction(e, t)
}, cc.EaseRateAction.create = cc.easeRateAction, cc.EaseIn = cc.EaseRateAction.extend({
    update: function(e) {
        this._inner.update(Math.pow(e, this._rate))
    },
    reverse: function() {
        return new cc.EaseIn(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var e = new cc.EaseIn;
        return e.initWithAction(this._inner.clone(), this._rate), e
    }
}), cc.EaseIn.create = function(e, t) {
    return new cc.EaseIn(e, t)
}, cc.easeIn = function(e) {
    return {
        _rate: e,
        easing: function(e) {
            return Math.pow(e, this._rate)
        },
        reverse: function() {
            return cc.easeIn(1 / this._rate)
        }
    }
}, cc.EaseOut = cc.EaseRateAction.extend({
    update: function(e) {
        this._inner.update(Math.pow(e, 1 / this._rate))
    },
    reverse: function() {
        return new cc.EaseOut(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var e = new cc.EaseOut;
        return e.initWithAction(this._inner.clone(), this._rate), e
    }
}), cc.EaseOut.create = function(e, t) {
    return new cc.EaseOut(e, t)
}, cc.easeOut = function(e) {
    return {
        _rate: e,
        easing: function(e) {
            return Math.pow(e, 1 / this._rate)
        },
        reverse: function() {
            return cc.easeOut(1 / this._rate)
        }
    }
}, cc.EaseInOut = cc.EaseRateAction.extend({
    update: function(e) {
        e *= 2, e < 1 ? this._inner.update(.5 * Math.pow(e, this._rate)) : this._inner.update(1 - .5 * Math.pow(2 - e, this._rate))
    },
    clone: function() {
        var e = new cc.EaseInOut;
        return e.initWithAction(this._inner.clone(), this._rate), e
    },
    reverse: function() {
        return new cc.EaseInOut(this._inner.reverse(), this._rate)
    }
}), cc.EaseInOut.create = function(e, t) {
    return new cc.EaseInOut(e, t)
}, cc.easeInOut = function(e) {
    return {
        _rate: e,
        easing: function(e) {
            return e *= 2, e < 1 ? .5 * Math.pow(e, this._rate) : 1 - .5 * Math.pow(2 - e, this._rate)
        },
        reverse: function() {
            return cc.easeInOut(this._rate)
        }
    }
}, cc.EaseExponentialIn = cc.ActionEase.extend({
    update: function(e) {
        this._inner.update(e === 0 ? 0 : Math.pow(2, 10 * (e - 1)))
    },
    reverse: function() {
        return new cc.EaseExponentialOut(this._inner.reverse())
    },
    clone: function() {
        var e = new cc.EaseExponentialIn;
        return e.initWithAction(this._inner.clone()), e
    }
}), cc.EaseExponentialIn.create = function(e) {
    return new cc.EaseExponentialIn(e)
}, cc._easeExponentialInObj = {
    easing: function(e) {
        return e === 0 ? 0 : Math.pow(2, 10 * (e - 1))
    },
    reverse: function() {
        return cc._easeExponentialOutObj
    }
}, cc.easeExponentialIn = function() {
    return cc._easeExponentialInObj
}, cc.EaseExponentialOut = cc.ActionEase.extend({
    update: function(e) {
        this._inner.update(e == 1 ? 1 : -Math.pow(2, -10 * e) + 1)
    },
    reverse: function() {
        return new cc.EaseExponentialIn(this._inner.reverse())
    },
    clone: function() {
        var e = new cc.EaseExponentialOut;
        return e.initWithAction(this._inner.clone()), e
    }
}), cc.EaseExponentialOut.create = function(e) {
    return new cc.EaseExponentialOut(e)
}, cc._easeExponentialOutObj = {
    easing: function(e) {
        return e == 1 ? 1 : -Math.pow(2, -10 * e) + 1
    },
    reverse: function() {
        return cc._easeExponentialInObj
    }
}, cc.easeExponentialOut = function() {
    return cc._easeExponentialOutObj
}, cc.EaseExponentialInOut = cc.ActionEase.extend({
    update: function(e) {
        e != 1 && e !== 0 && (e *= 2, e < 1 ? e = .5 * Math.pow(2, 10 * (e - 1)) : e = .5 * (-Math.pow(2, -10 * (e - 1)) + 2)), this._inner.update(e)
    },
    reverse: function() {
        return new cc.EaseExponentialInOut(this._inner.reverse())
    },
    clone: function() {
        var e = new cc.EaseExponentialInOut;
        return e.initWithAction(this._inner.clone()), e
    }
}), cc.EaseExponentialInOut.create = function(e) {
    return new cc.EaseExponentialInOut(e)
}, cc._easeExponentialInOutObj = {
    easing: function(e) {
        return e !== 1 && e !== 0 ? (e *= 2, e < 1 ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (-Math.pow(2, -10 * (e - 1)) + 2)) : e
    },
    reverse: function() {
        return cc._easeExponentialInOutObj
    }
}, cc.easeExponentialInOut = function() {
    return cc._easeExponentialInOutObj
}, cc.EaseSineIn = cc.ActionEase.extend({
    update: function(e) {
        e = e === 0 || e === 1 ? e : -1 * Math.cos(e * Math.PI / 2) + 1, this._inner.update(e)
    },
    reverse: function() {
        return new cc.EaseSineOut(this._inner.reverse())
    },
    clone: function() {
        var e = new cc.EaseSineIn;
        return e.initWithAction(this._inner.clone()), e
    }
}), cc.EaseSineIn.create = function(e) {
    return new cc.EaseSineIn(e)
}, cc._easeSineInObj = {
    easing: function(e) {
        return e === 0 || e === 1 ? e : -1 * Math.cos(e * Math.PI / 2) + 1
    },
    reverse: function() {
        return cc._easeSineOutObj
    }
}, cc.easeSineIn = function() {
    return cc._easeSineInObj
}, cc.EaseSineOut = cc.ActionEase.extend({
    update: function(e) {
        e = e === 0 || e === 1 ? e : Math.sin(e * Math.PI / 2), this._inner.update(e)
    },
    reverse: function() {
        return new cc.EaseSineIn(this._inner.reverse())
    },
    clone: function() {
        var e = new cc.EaseSineOut;
        return e.initWithAction(this._inner.clone()), e
    }
}), cc.EaseSineOut.create = function(e) {
    return new cc.EaseSineOut(e)
}, cc._easeSineOutObj = {
    easing: function(e) {
        return e === 0 || e == 1 ? e : Math.sin(e * Math.PI / 2)
    },
    reverse: function() {
        return cc._easeSineInObj
    }
}, cc.easeSineOut = function() {
    return cc._easeSineOutObj
}, cc.EaseSineInOut = cc.ActionEase.extend({
    update: function(e) {
        e = e === 0 || e === 1 ? e : -0.5 * (Math.cos(Math.PI * e) - 1), this._inner.update(e)
    },
    clone: function() {
        var e = new cc.EaseSineInOut;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseSineInOut(this._inner.reverse())
    }
}), cc.EaseSineInOut.create = function(e) {
    return new cc.EaseSineInOut(e)
}, cc._easeSineInOutObj = {
    easing: function(e) {
        return e === 0 || e === 1 ? e : -0.5 * (Math.cos(Math.PI * e) - 1)
    },
    reverse: function() {
        return cc._easeSineInOutObj
    }
}, cc.easeSineInOut = function() {
    return cc._easeSineInOutObj
}, cc.EaseElastic = cc.ActionEase.extend({
    _period: .3,
    ctor: function(e, t) {
        cc.ActionEase.prototype.ctor.call(this), e && this.initWithAction(e, t)
    },
    getPeriod: function() {
        return this._period
    },
    setPeriod: function(e) {
        this._period = e
    },
    initWithAction: function(e, t) {
        return cc.ActionEase.prototype.initWithAction.call(this, e), this._period = t == null ? .3 : t, !0
    },
    reverse: function() {
        return cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass."), null
    },
    clone: function() {
        var e = new cc.EaseElastic;
        return e.initWithAction(this._inner.clone(), this._period), e
    }
}), cc.EaseElastic.create = function(e, t) {
    return new cc.EaseElastic(e, t)
}, cc.EaseElasticIn = cc.EaseElastic.extend({
    update: function(e) {
        var t = 0;
        if (e === 0 || e === 1)
            t = e;
        else {
            var n = this._period / 4;
            e -= 1, t = -Math.pow(2, 10 * e) * Math.sin((e - n) * Math.PI * 2 / this._period)
        }
        this._inner.update(t)
    },
    reverse: function() {
        return new cc.EaseElasticOut(this._inner.reverse(), this._period)
    },
    clone: function() {
        var e = new cc.EaseElasticIn;
        return e.initWithAction(this._inner.clone(), this._period), e
    }
}), cc.EaseElasticIn.create = function(e, t) {
    return new cc.EaseElasticIn(e, t)
}, cc._easeElasticInObj = {
    easing: function(e) {
        return e === 0 || e === 1 ? e : (e -= 1, -Math.pow(2, 10 * e) * Math.sin((e - .075) * Math.PI * 2 / .3))
    },
    reverse: function() {
        return cc._easeElasticOutObj
    }
}, cc.easeElasticIn = function(e) {
    return e && e !== .3 ? {
        _period: e,
        easing: function(e) {
            return e === 0 || e === 1 ? e : (e -= 1, -Math.pow(2, 10 * e) * Math.sin((e - this._period / 4) * Math.PI * 2 / this._period))
        },
        reverse: function() {
            return cc.easeElasticOut(this._period)
        }
    } : cc._easeElasticInObj
}, cc.EaseElasticOut = cc.EaseElastic.extend({
    update: function(e) {
        var t = 0;
        if (e === 0 || e == 1)
            t = e;
        else {
            var n = this._period / 4;
            t = Math.pow(2, -10 * e) * Math.sin((e - n) * Math.PI * 2 / this._period) + 1
        }
        this._inner.update(t)
    },
    reverse: function() {
        return new cc.EaseElasticIn(this._inner.reverse(), this._period)
    },
    clone: function() {
        var e = new cc.EaseElasticOut;
        return e.initWithAction(this._inner.clone(), this._period), e
    }
}), cc.EaseElasticOut.create = function(e, t) {
    return new cc.EaseElasticOut(e, t)
}, cc._easeElasticOutObj = {
    easing: function(e) {
        return e === 0 || e === 1 ? e : Math.pow(2, -10 * e) * Math.sin((e - .075) * Math.PI * 2 / .3) + 1
    },
    reverse: function() {
        return cc._easeElasticInObj
    }
}, cc.easeElasticOut = function(e) {
    return e && e !== .3 ? {
        _period: e,
        easing: function(e) {
            return e === 0 || e === 1 ? e : Math.pow(2, -10 * e) * Math.sin((e - this._period / 4) * Math.PI * 2 / this._period) + 1
        },
        reverse: function() {
            return cc.easeElasticIn(this._period)
        }
    } : cc._easeElasticOutObj
}, cc.EaseElasticInOut = cc.EaseElastic.extend({
    update: function(e) {
        var t = 0,
            n = this._period;
        if (e === 0 || e == 1)
            t = e;
        else {
            e *= 2, n || (n = this._period = .3 * 1.5);
            var r = n / 4;
            e -= 1, e < 0 ? t = -0.5 * Math.pow(2, 10 * e) * Math.sin((e - r) * Math.PI * 2 / n) : t = Math.pow(2, -10 * e) * Math.sin((e - r) * Math.PI * 2 / n) * .5 + 1
        }
        this._inner.update(t)
    },
    reverse: function() {
        return new cc.EaseElasticInOut(this._inner.reverse(), this._period)
    },
    clone: function() {
        var e = new cc.EaseElasticInOut;
        return e.initWithAction(this._inner.clone(), this._period), e
    }
}), cc.EaseElasticInOut.create = function(e, t) {
    return new cc.EaseElasticInOut(e, t)
}, cc.easeElasticInOut = function(e) {
    return e = e || .3, {
        _period: e,
        easing: function(e) {
            var t = 0,
                n = this._period;
            if (e === 0 || e === 1)
                t = e;
            else {
                e *= 2, n || (n = this._period = .3 * 1.5);
                var r = n / 4;
                e -= 1, e < 0 ? t = -0.5 * Math.pow(2, 10 * e) * Math.sin((e - r) * Math.PI * 2 / n) : t = Math.pow(2, -10 * e) * Math.sin((e - r) * Math.PI * 2 / n) * .5 + 1
            }
            return t
        },
        reverse: function() {
            return cc.easeElasticInOut(this._period)
        }
    }
}, cc.EaseBounce = cc.ActionEase.extend({
    bounceTime: function(e) {
        return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? (e -= 1.5 / 2.75, 7.5625 * e * e + .75) : e < 2.5 / 2.75 ? (e -= 2.25 / 2.75, 7.5625 * e * e + .9375) : (e -= 2.625 / 2.75, 7.5625 * e * e + .984375)
    },
    clone: function() {
        var e = new cc.EaseBounce;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseBounce(this._inner.reverse())
    }
}), cc.EaseBounce.create = function(e) {
    return new cc.EaseBounce(e)
}, cc.EaseBounceIn = cc.EaseBounce.extend({
    update: function(e) {
        var t = 1 - this.bounceTime(1 - e);
        this._inner.update(t)
    },
    reverse: function() {
        return new cc.EaseBounceOut(this._inner.reverse())
    },
    clone: function() {
        var e = new cc.EaseBounceIn;
        return e.initWithAction(this._inner.clone()), e
    }
}), cc.EaseBounceIn.create = function(e) {
    return new cc.EaseBounceIn(e)
}, cc._bounceTime = function(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? (e -= 1.5 / 2.75, 7.5625 * e * e + .75) : e < 2.5 / 2.75 ? (e -= 2.25 / 2.75, 7.5625 * e * e + .9375) : (e -= 2.625 / 2.75, 7.5625 * e * e + .984375)
}, cc._easeBounceInObj = {
    easing: function(e) {
        return 1 - cc._bounceTime(1 - e)
    },
    reverse: function() {
        return cc._easeBounceOutObj
    }
}, cc.easeBounceIn = function() {
    return cc._easeBounceInObj
}, cc.EaseBounceOut = cc.EaseBounce.extend({
    update: function(e) {
        var t = this.bounceTime(e);
        this._inner.update(t)
    },
    reverse: function() {
        return new cc.EaseBounceIn(this._inner.reverse())
    },
    clone: function() {
        var e = new cc.EaseBounceOut;
        return e.initWithAction(this._inner.clone()), e
    }
}), cc.EaseBounceOut.create = function(e) {
    return new cc.EaseBounceOut(e)
}, cc._easeBounceOutObj = {
    easing: function(e) {
        return cc._bounceTime(e)
    },
    reverse: function() {
        return cc._easeBounceInObj
    }
}, cc.easeBounceOut = function() {
    return cc._easeBounceOutObj
}, cc.EaseBounceInOut = cc.EaseBounce.extend({
    update: function(e) {
        var t = 0;
        e < .5 ? (e *= 2, t = (1 - this.bounceTime(1 - e)) * .5) : t = this.bounceTime(e * 2 - 1) * .5 + .5, this._inner.update(t)
    },
    clone: function() {
        var e = new cc.EaseBounceInOut;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseBounceInOut(this._inner.reverse())
    }
}), cc.EaseBounceInOut.create = function(e) {
    return new cc.EaseBounceInOut(e)
}, cc._easeBounceInOutObj = {
    easing: function(e) {
        var t;
        return e < .5 ? (e *= 2, t = (1 - cc._bounceTime(1 - e)) * .5) : t = cc._bounceTime(e * 2 - 1) * .5 + .5, t
    },
    reverse: function() {
        return cc._easeBounceInOutObj
    }
}, cc.easeBounceInOut = function() {
    return cc._easeBounceInOutObj
}, cc.EaseBackIn = cc.ActionEase.extend({
    update: function(e) {
        var t = 1.70158;
        e = e === 0 || e == 1 ? e : e * e * ((t + 1) * e - t), this._inner.update(e)
    },
    reverse: function() {
        return new cc.EaseBackOut(this._inner.reverse())
    },
    clone: function() {
        var e = new cc.EaseBackIn;
        return e.initWithAction(this._inner.clone()), e
    }
}), cc.EaseBackIn.create = function(e) {
    return new cc.EaseBackIn(e)
}, cc._easeBackInObj = {
    easing: function(e) {
        var t = 1.70158;
        return e === 0 || e === 1 ? e : e * e * ((t + 1) * e - t)
    },
    reverse: function() {
        return cc._easeBackOutObj
    }
}, cc.easeBackIn = function() {
    return cc._easeBackInObj
}, cc.EaseBackOut = cc.ActionEase.extend({
    update: function(e) {
        var t = 1.70158;
        e -= 1, this._inner.update(e * e * ((t + 1) * e + t) + 1)
    },
    reverse: function() {
        return new cc.EaseBackIn(this._inner.reverse())
    },
    clone: function() {
        var e = new cc.EaseBackOut;
        return e.initWithAction(this._inner.clone()), e
    }
}), cc.EaseBackOut.create = function(e) {
    return new cc.EaseBackOut(e)
}, cc._easeBackOutObj = {
    easing: function(e) {
        var t = 1.70158;
        return e -= 1, e * e * ((t + 1) * e + t) + 1
    },
    reverse: function() {
        return cc._easeBackInObj
    }
}, cc.easeBackOut = function() {
    return cc._easeBackOutObj
}, cc.EaseBackInOut = cc.ActionEase.extend({
    update: function(e) {
        var t = 2.5949095;
        e *= 2, e < 1 ? this._inner.update(e * e * ((t + 1) * e - t) / 2) : (e -= 2, this._inner.update(e * e * ((t + 1) * e + t) / 2 + 1))
    },
    clone: function() {
        var e = new cc.EaseBackInOut;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseBackInOut(this._inner.reverse())
    }
}), cc.EaseBackInOut.create = function(e) {
    return new cc.EaseBackInOut(e)
}, cc._easeBackInOutObj = {
    easing: function(e) {
        var t = 2.5949095;
        return e *= 2, e < 1 ? e * e * ((t + 1) * e - t) / 2 : (e -= 2, e * e * ((t + 1) * e + t) / 2 + 1)
    },
    reverse: function() {
        return cc._easeBackInOutObj
    }
}, cc.easeBackInOut = function() {
    return cc._easeBackInOutObj
}, cc.EaseBezierAction = cc.ActionEase.extend({
    _p0: null,
    _p1: null,
    _p2: null,
    _p3: null,
    ctor: function(e) {
        cc.ActionEase.prototype.ctor.call(this, e)
    },
    _updateTime: function(e, t, n, r, i) {
        return Math.pow(1 - i, 3) * e + 3 * i * Math.pow(1 - i, 2) * t + 3 * Math.pow(i, 2) * (1 - i) * n + Math.pow(i, 3) * r
    },
    update: function(e) {
        var t = this._updateTime(this._p0, this._p1, this._p2, this._p3, e);
        this._inner.update(t)
    },
    clone: function() {
        var e = new cc.EaseBezierAction;
        return e.initWithAction(this._inner.clone()), e.setBezierParamer(this._p0, this._p1, this._p2, this._p3), e
    },
    reverse: function() {
        var e = new cc.EaseBezierAction(this._inner.reverse());
        return e.setBezierParamer(this._p3, this._p2, this._p1, this._p0), e
    },
    setBezierParamer: function(e, t, n, r) {
        this._p0 = e || 0, this._p1 = t || 0, this._p2 = n || 0, this._p3 = r || 0
    }
}), cc.EaseBezierAction.create = function(e) {
    return new cc.EaseBezierAction(e)
}, cc.easeBezierAction = function(e, t, n, r) {
    return {
        easing: function(i) {
            return cc.EaseBezierAction.prototype._updateTime(e, t, n, r, i)
        },
        reverse: function() {
            return cc.easeBezierAction(r, n, t, e)
        }
    }
}, cc.EaseQuadraticActionIn = cc.ActionEase.extend({
    _updateTime: function(e) {
        return Math.pow(e, 2)
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseQuadraticActionIn;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseQuadraticActionIn(this._inner.reverse())
    }
}), cc.EaseQuadraticActionIn.create = function(e) {
    return new cc.EaseQuadraticActionIn(e)
}, cc._easeQuadraticActionIn = {
    easing: cc.EaseQuadraticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionIn
    }
}, cc.easeQuadraticActionIn = function() {
    return cc._easeQuadraticActionIn
}, cc.EaseQuadraticActionOut = cc.ActionEase.extend({
    _updateTime: function(e) {
        return -e * (e - 2)
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseQuadraticActionOut;
        return e.initWithAction(), e
    },
    reverse: function() {
        return new cc.EaseQuadraticActionOut(this._inner.reverse())
    }
}), cc.EaseQuadraticActionOut.create = function(e) {
    return new cc.EaseQuadraticActionOut(e)
}, cc._easeQuadraticActionOut = {
    easing: cc.EaseQuadraticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionOut
    }
}, cc.easeQuadraticActionOut = function() {
    return cc._easeQuadraticActionOut
}, cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
    _updateTime: function(e) {
        var t = e;
        return e *= 2, e < 1 ? t = e * e * .5 : (--e, t = -0.5 * (e * (e - 2) - 1)), t
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseQuadraticActionInOut;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseQuadraticActionInOut(this._inner.reverse())
    }
}), cc.EaseQuadraticActionInOut.create = function(e) {
    return new cc.EaseQuadraticActionInOut(e)
}, cc._easeQuadraticActionInOut = {
    easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionInOut
    }
}, cc.easeQuadraticActionInOut = function() {
    return cc._easeQuadraticActionInOut
}, cc.EaseQuarticActionIn = cc.ActionEase.extend({
    _updateTime: function(e) {
        return e * e * e * e
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseQuarticActionIn;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseQuarticActionIn(this._inner.reverse())
    }
}), cc.EaseQuarticActionIn.create = function(e) {
    return new cc.EaseQuarticActionIn(e)
}, cc._easeQuarticActionIn = {
    easing: cc.EaseQuarticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionIn
    }
}, cc.easeQuarticActionIn = function() {
    return cc._easeQuarticActionIn
}, cc.EaseQuarticActionOut = cc.ActionEase.extend({
    _updateTime: function(e) {
        return e -= 1, -(e * e * e * e - 1)
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseQuarticActionOut;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseQuarticActionOut(this._inner.reverse())
    }
}), cc.EaseQuarticActionOut.create = function(e) {
    return new cc.EaseQuarticActionOut(e)
}, cc._easeQuarticActionOut = {
    easing: cc.EaseQuarticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionOut
    }
}, cc.easeQuarticActionOut = function() {
    return cc._easeQuarticActionOut
}, cc.EaseQuarticActionInOut = cc.ActionEase.extend({
    _updateTime: function(e) {
        return e *= 2, e < 1 ? .5 * e * e * e * e : (e -= 2, -0.5 * (e * e * e * e - 2))
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseQuarticActionInOut;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseQuarticActionInOut(this._inner.reverse())
    }
}), cc.EaseQuarticActionInOut.create = function(e) {
    return new cc.EaseQuarticActionInOut(e)
}, cc._easeQuarticActionInOut = {
    easing: cc.EaseQuarticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionInOut
    }
}, cc.easeQuarticActionInOut = function() {
    return cc._easeQuarticActionInOut
}, cc.EaseQuinticActionIn = cc.ActionEase.extend({
    _updateTime: function(e) {
        return e * e * e * e * e
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseQuinticActionIn;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseQuinticActionIn(this._inner.reverse())
    }
}), cc.EaseQuinticActionIn.create = function(e) {
    return new cc.EaseQuinticActionIn(e)
}, cc._easeQuinticActionIn = {
    easing: cc.EaseQuinticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionIn
    }
}, cc.easeQuinticActionIn = function() {
    return cc._easeQuinticActionIn
}, cc.EaseQuinticActionOut = cc.ActionEase.extend({
    _updateTime: function(e) {
        return e -= 1, e * e * e * e * e + 1
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseQuinticActionOut;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseQuinticActionOut(this._inner.reverse())
    }
}), cc.EaseQuinticActionOut.create = function(e) {
    return new cc.EaseQuinticActionOut(e)
}, cc._easeQuinticActionOut = {
    easing: cc.EaseQuinticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionOut
    }
}, cc.easeQuinticActionOut = function() {
    return cc._easeQuinticActionOut
}, cc.EaseQuinticActionInOut = cc.ActionEase.extend({
    _updateTime: function(e) {
        return e *= 2, e < 1 ? .5 * e * e * e * e * e : (e -= 2, .5 * (e * e * e * e * e + 2))
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseQuinticActionInOut;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseQuinticActionInOut(this._inner.reverse())
    }
}), cc.EaseQuinticActionInOut.create = function(e) {
    return new cc.EaseQuinticActionInOut(e)
}, cc._easeQuinticActionInOut = {
    easing: cc.EaseQuinticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionInOut
    }
}, cc.easeQuinticActionInOut = function() {
    return cc._easeQuinticActionInOut
}, cc.EaseCircleActionIn = cc.ActionEase.extend({
    _updateTime: function(e) {
        return -1 * (Math.sqrt(1 - e * e) - 1)
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseCircleActionIn;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseCircleActionIn(this._inner.reverse())
    }
}), cc.EaseCircleActionIn.create = function(e) {
    return new cc.EaseCircleActionIn(e)
}, cc._easeCircleActionIn = {
    easing: cc.EaseCircleActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionIn
    }
}, cc.easeCircleActionIn = function() {
    return cc._easeCircleActionIn
}, cc.EaseCircleActionOut = cc.ActionEase.extend({
    _updateTime: function(e) {
        return e -= 1, Math.sqrt(1 - e * e)
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseCircleActionOut;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseCircleActionOut(this._inner.reverse())
    }
}), cc.EaseCircleActionOut.create = function(e) {
    return new cc.EaseCircleActionOut(e)
}, cc._easeCircleActionOut = {
    easing: cc.EaseCircleActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionOut
    }
}, cc.easeCircleActionOut = function() {
    return cc._easeCircleActionOut
}, cc.EaseCircleActionInOut = cc.ActionEase.extend({
    _updateTime: function(e) {
        return e *= 2, e < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : (e -= 2, .5 * (Math.sqrt(1 - e * e) + 1))
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseCircleActionInOut;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseCircleActionInOut(this._inner.reverse())
    }
}), cc.EaseCircleActionInOut.create = function(e) {
    return new cc.EaseCircleActionInOut(e)
}, cc._easeCircleActionInOut = {
    easing: cc.EaseCircleActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionInOut
    }
}, cc.easeCircleActionInOut = function() {
    return cc._easeCircleActionInOut
}, cc.EaseCubicActionIn = cc.ActionEase.extend({
    _updateTime: function(e) {
        return e * e * e
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseCubicActionIn;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseCubicActionIn(this._inner.reverse())
    }
}), cc.EaseCubicActionIn.
create = function(e) {
    return new cc.EaseCubicActionIn(e)
}, cc._easeCubicActionIn = {
    easing: cc.EaseCubicActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionIn
    }
}, cc.easeCubicActionIn = function() {
    return cc._easeCubicActionIn
}, cc.EaseCubicActionOut = cc.ActionEase.extend({
    _updateTime: function(e) {
        return e -= 1, e * e * e + 1
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseCubicActionOut;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseCubicActionOut(this._inner.reverse())
    }
}), cc.EaseCubicActionOut.create = function(e) {
    return new cc.EaseCubicActionOut(e)
}, cc._easeCubicActionOut = {
    easing: cc.EaseCubicActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionOut
    }
}, cc.easeCubicActionOut = function() {
    return cc._easeCubicActionOut
}, cc.EaseCubicActionInOut = cc.ActionEase.extend({
    _updateTime: function(e) {
        return e *= 2, e < 1 ? .5 * e * e * e : (e -= 2, .5 * (e * e * e + 2))
    },
    update: function(e) {
        this._inner.update(this._updateTime(e))
    },
    clone: function() {
        var e = new cc.EaseCubicActionInOut;
        return e.initWithAction(this._inner.clone()), e
    },
    reverse: function() {
        return new cc.EaseCubicActionInOut(this._inner.reverse())
    }
}), cc.EaseCubicActionInOut.create = function(e) {
    return new cc.EaseCubicActionInOut(e)
}, cc._easeCubicActionInOut = {
    easing: cc.EaseCubicActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionInOut
    }
}, cc.easeCubicActionInOut = function() {
    return cc._easeCubicActionInOut
}, cc.cardinalSplineAt = function(e, t, n, r, i, s) {
    var o = s * s,
        u = o * s,
        a = (1 - i) / 2,
        f = a * (-u + 2 * o - s),
        l = a * (-u + o) + (2 * u - 3 * o + 1),
        c = a * (u - 2 * o + s) + (-2 * u + 3 * o),
        h = a * (u - o),
        p = e.x * f + t.x * l + n.x * c + r.x * h,
        d = e.y * f + t.y * l + n.y * c + r.y * h;
    return cc.p(p, d)
}, cc.reverseControlPoints = function(e) {
    var t = [];
    for (var n = e.length - 1; n >= 0; n--)
        t.push(cc.p(e[n].x, e[n].y));
    return t
}, cc.cloneControlPoints = function(e) {
    var t = [];
    for (var n = 0; n < e.length; n++)
        t.push(cc.p(e[n].x, e[n].y));
    return t
}, cc.copyControlPoints = cc.cloneControlPoints, cc.getControlPointAt = function(e, t) {
    var n = Math.min(e.length - 1, Math.max(t, 0));
    return e[n]
}, cc.reverseControlPointsInline = function(e) {
    var t = e.length,
        n = 0 | t / 2;
    for (var r = 0; r < n; ++r) {
        var i = e[r];
        e[r] = e[t - r - 1], e[t - r - 1] = i
    }
}, cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points: null,
    _deltaT: 0,
    _tension: 0,
    _previousPosition: null,
    _accumulatedDiff: null,
    ctor: function(e, t, n) {
        cc.ActionInterval.prototype.ctor.call(this), this._points = [], n !== undefined && this.initWithDuration(e, t, n)
    },
    initWithDuration: function(e, t, n) {
        if (!t || t.length == 0)
            throw "Invalid configuration. It must at least have one control point";
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (this.setPoints(t), this._tension = n, !0) : !1
    },
    clone: function() {
        var e = new cc.CardinalSplineTo;
        return e.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension), e
    },
    startWithTarget: function(e) {
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this._deltaT = 1 / (this._points.length - 1), this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY()), this._accumulatedDiff = cc.p(0, 0)
    },
    update: function(e) {
        e = this._computeEaseTime(e);
        var t, n, r = this._points;
        if (e == 1)
            t = r.length - 1, n = 1;
        else {
            var i = this._deltaT;
            t = 0 | e / i, n = (e - i * t) / i
        }
        var s = cc.cardinalSplineAt(cc.getControlPointAt(r, t - 1), cc.getControlPointAt(r, t - 0), cc.getControlPointAt(r, t + 1), cc.getControlPointAt(r, t + 2), this._tension, n);
        if (cc.ENABLE_STACKABLE_ACTIONS) {
            var o, u;
            o = this.target.getPositionX() - this._previousPosition.x, u = this.target.getPositionY() - this._previousPosition.y;
            if (o != 0 || u != 0) {
                var a = this._accumulatedDiff;
                o = a.x + o, u = a.y + u, a.x = o, a.y = u, s.x += o, s.y += u
            }
        }
        this.updatePosition(s)
    },
    reverse: function() {
        var e = cc.reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, e, this._tension)
    },
    updatePosition: function(e) {
        this.target.setPosition(e), this._previousPosition = e
    },
    getPoints: function() {
        return this._points
    },
    setPoints: function(e) {
        this._points = e
    }
}), cc.cardinalSplineTo = function(e, t, n) {
    return new cc.CardinalSplineTo(e, t, n)
}, cc.CardinalSplineTo.create = cc.cardinalSplineTo, cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition: null,
    ctor: function(e, t, n) {
        cc.CardinalSplineTo.prototype.ctor.call(this), this._startPosition = cc.p(0, 0), n !== undefined && this.initWithDuration(e, t, n)
    },
    startWithTarget: function(e) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, e), this._startPosition.x = e.getPositionX(), this._startPosition.y = e.getPositionY()
    },
    reverse: function() {
        var e = this._points.slice(),
            t, n = e[0];
        for (var r = 1; r < e.length; ++r)
            t = e[r], e[r] = cc.pSub(t, n), n = t;
        var i = cc.reverseControlPoints(e);
        n = i[i.length - 1], i.pop(), n.x = -n.x, n.y = -n.y, i.unshift(n);
        for (var r = 1; r < i.length; ++r)
            t = i[r], t.x = -t.x, t.y = -t.y, t.x += n.x, t.y += n.y, i[r] = t, n = t;
        return cc.cardinalSplineBy(this._duration, i, this._tension)
    },
    updatePosition: function(e) {
        var t = this._startPosition,
            n = e.x + t.x,
            r = e.y + t.y;
        this._previousPosition.x = n, this._previousPosition.y = r, this.target.setPosition(n, r)
    },
    clone: function() {
        var e = new cc.CardinalSplineBy;
        return e.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension), e
    }
}), cc.cardinalSplineBy = function(e, t, n) {
    return new cc.CardinalSplineBy(e, t, n)
}, cc.CardinalSplineBy.create = cc.cardinalSplineBy, cc.CatmullRomTo = cc.CardinalSplineTo.extend({
    ctor: function(e, t) {
        t && this.initWithDuration(e, t)
    },
    initWithDuration: function(e, t) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, e, t, .5)
    },
    clone: function() {
        var e = new cc.CatmullRomTo;
        return e.initWithDuration(this._duration, cc.copyControlPoints(this._points)), e
    }
}), cc.catmullRomTo = function(e, t) {
    return new cc.CatmullRomTo(e, t)
}, cc.CatmullRomTo.create = cc.catmullRomTo, cc.CatmullRomBy = cc.CardinalSplineBy.extend({
    ctor: function(e, t) {
        cc.CardinalSplineBy.prototype.ctor.call(this), t && this.initWithDuration(e, t)
    },
    initWithDuration: function(e, t) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, e, t, .5)
    },
    clone: function() {
        var e = new cc.CatmullRomBy;
        return e.initWithDuration(this._duration, cc.copyControlPoints(this._points)), e
    }
}), cc.catmullRomBy = function(e, t) {
    return new cc.CatmullRomBy(e, t)
}, cc.CatmullRomBy.create = cc.catmullRomBy, cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction: function(e, t) {}
}), cc.ActionTween = cc.ActionInterval.extend({
    key: "",
    from: 0,
    to: 0,
    delta: 0,
    ctor: function(e, t, n, r) {
        cc.ActionInterval.prototype.ctor.call(this), this.key = "", r !== undefined && this.initWithDuration(e, t, n, r)
    },
    initWithDuration: function(e, t, n, r) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, e) ? (this.key = t, this.to = r, this.from = n, !0) : !1
    },
    startWithTarget: function(e) {
        if (!e || !e.updateTweenAction)
            throw "cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function";
        cc.ActionInterval.prototype.startWithTarget.call(this, e), this.delta = this.to - this.from
    },
    update: function(e) {
        this.target.updateTweenAction(this.to - this.delta * (1 - e), this.key)
    },
    reverse: function() {
        return new cc.ActionTween(this.duration, this.key, this.to, this.from)
    },
    clone: function() {
        var e = new cc.ActionTween;
        return e.initWithDuration(this._duration, this.key, this.from, this.to), e
    }
}), cc.actionTween = function(e, t, n, r) {
    return new cc.ActionTween(e, t, n, r)
}, cc.ActionTween.create = cc.actionTween;
if (cc.sys._supportWebAudio) {
    var _ctx = cc.webAudioContext = new(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
    cc.WebAudio = cc.Class.extend({
        _events: null,
        _buffer: null,
        _sourceNode: null,
        _volumeNode: null,
        src: null,
        preload: null,
        autoplay: null,
        controls: null,
        mediagroup: null,
        currentTime: 0,
        startTime: 0,
        duration: 0,
        _loop: null,
        _volume: 1,
        _pauseTime: 0,
        _paused: !1,
        _stopped: !0,
        _loadState: -1,
        ctor: function(e) {
            var t = this;
            t._events = {}, t.src = e, _ctx.createGain ? t._volumeNode = _ctx.createGain() : t._volumeNode = _ctx.createGainNode(), t._onSuccess1 = t._onSuccess.bind(this), t._onError1 = t._onError.bind(this)
        },
        _play: function(e) {
            var t = this,
                n = t._sourceNode = _ctx.createBufferSource(),
                r = t._volumeNode;
            e = e || 0, n.buffer = t._buffer, r.gain.value = t._volume, n.connect(r), r.connect(_ctx.destination), n.loop = t._loop, n._stopped = !1, n.playbackState || (n.onended = function() {
                this._stopped = !0
            }), t._paused = !1, t._stopped = !1;
            if (n.start)
                n.start(0, e);
            else if (n.noteGrainOn) {
                var i = n.buffer.duration;
                t.loop ? n.noteGrainOn(0, e, i) : n.noteGrainOn(0, e, i - e)
            } else
                n.noteOn(0);
            t._pauseTime = 0
        },
        _stop: function() {
            var e = this,
                t = e._sourceNode;
            if (e._stopped)
                return;
            t.stop ? t.stop(0) : t.noteOff(0), e._stopped = !0
        },
        play: function() {
            var e = this;
            if (e._loadState == -1) {
                e._loadState = 0;
                return
            }
            if (e._loadState != 1)
                return;
            var t = e._sourceNode;
            if (!e._stopped && t && (t["playbackState"] == 2 || !t._stopped))
                return;
            e.startTime = _ctx.currentTime, this._play(0)
        },
        pause: function() {
            this._pauseTime = _ctx.currentTime, this._paused = !0, this._stop()
        },
        resume: function() {
            var e = this;
            if (e._paused) {
                var t = e._buffer ? (e._pauseTime - e.startTime) % e._buffer.duration : 0;
                this._play(t)
            }
        },
        stop: function() {
            this._pauseTime = 0, this._paused = !1, this._stop()
        },
        load: function() {
            var e = this;
            if (e._loadState == 1)
                return;
            e._loadState = -1, e.played = !1, e.ended = !0;
            var t = new XMLHttpRequest;
            t.open("GET", e.src, !0), t.responseType = "arraybuffer", t.onload = function() {
                _ctx.decodeAudioData(t.response, e._onSuccess1, e._onError1)
            }, t.send()
        },
        addEventListener: function(e, t) {
            this._events[e] = t.bind(this)
        },
        removeEventListener: function(e) {
            delete this._events[e]
        },
        canplay: function() {
            return cc.sys._supportWebAudio
        },
        _onSuccess: function(e) {
            var t = this;
            t._buffer = e;
            var n = t._events.success,
                r = t._events.canplaythrough;
            n && n(), r && r(), (t._loadState == 0 || t.autoplay == "autoplay" || t.autoplay == 1) && t._play(), t._loadState = 1
        },
        _onError: function() {
            var e = this._events.error;
            e && e(), this._loadState = -2
        },
        cloneNode: function() {
            var e = this,
                t = new cc.WebAudio(e.src);
            return t.volume = e.volume, t._loadState = e._loadState, t._buffer = e._buffer, (t._loadState == 0 || t._loadState == -1) && t.load(), t
        }
    });
    var _p = cc.WebAudio.prototype;
    _p.loop, cc.defineGetterSetter(_p, "loop", function() {
        return this._loop
    }, function(e) {
        this._loop = e, this._sourceNode && (this._sourceNode.loop = e)
    }), _p.volume, cc.defineGetterSetter(_p, "volume", function() {
        return this._volume
    }, function(e) {
        this._volume = e, this._volumeNode.gain.value = e
    }), _p.paused, cc.defineGetterSetter(_p, "paused", function() {
        return this._paused
    }), _p.ended, cc.defineGetterSetter(_p, "ended", function() {
        var e = this._sourceNode;
        return this._paused ? !1 : this._stopped && !e ? !0 : e["playbackState"] == null ? e._stopped : e["playbackState"] == 3
    }), _p.played, cc.defineGetterSetter(_p, "played", function() {
        var e = this._sourceNode;
        return e && (e["playbackState"] == 2 || !e._stopped)
    })
}
cc.AudioEngine = cc.Class.extend({
    _soundSupported: !1,
    _currMusic: null,
    _currMusicPath: null,
    _musicPlayState: 0,
    _audioID: 0,
    _effects: {},
    _audioPool: {},
    _effectsVolume: 1,
    _maxAudioInstance: 5,
    _effectPauseCb: null,
    _playings: [],
    ctor: function() {
        var e = this;
        e._soundSupported = cc._audioLoader._supportedAudioTypes.length > 0, e._effectPauseCb && (e._effectPauseCb = e._effectPauseCb.bind(e))
    },
    willPlayMusic: function() {
        return !1
    },
    getEffectsVolume: function() {
        return this._effectsVolume
    },
    playMusic: function(e, t) {
        var n = this;
        if (!n._soundSupported)
            return;
        var r = n._currMusic;
        r && this._stopAudio(r), cc.sys.isMobile && cc.sys.os == cc.sys.OS_IOS ? (r = n._getAudioByUrl(e), n._currMusic = r.cloneNode(), n._currMusicPath = e) : e != n._currMusicPath && (r = n._getAudioByUrl(e), n._currMusic = r, n._currMusicPath = e);
        if (!n._currMusic)
            return;
        n._currMusic.loop = t || !1, n._playMusic(n._currMusic)
    },
    _getAudioByUrl: function(e) {
        var t = cc.loader,
            n = t.getRes(e);
        return n || (t.load(e), n = t.getRes(e)), n
    },
    _playMusic: function(e) {
        e.ended || (e.stop ? e.stop() : (e.pause(), e.readyState > 2 && (e.currentTime = 0))), this._musicPlayState = 2, e.play()
    },
    stopMusic: function(e) {
        if (this._musicPlayState > 0) {
            var t = this._currMusic;
            if (!t)
                return;
            if (!this._stopAudio(t))
                return;
            e && cc.loader.release(this._currMusicPath), this._currMusic = null, this._currMusicPath = null, this._musicPlayState = 0
        }
    },
    _stopAudio: function(e) {
        return e && !e.ended ? (e.stop ? e.stop() : (e.pause(), e.readyState > 2 && e.duration && e.duration != Infinity && (e.currentTime = e.duration)), !0) : !1
    },
    pauseMusic: function() {
        this._musicPlayState == 2 && (this._currMusic.pause(), this._musicPlayState = 1)
    },
    resumeMusic: function() {
        if (this._musicPlayState == 1) {
            var e = this._currMusic;
            this._resumeAudio(e), this._musicPlayState = 2
        }
    },
    _resumeAudio: function(e) {
        e && !e.ended && (e.resume ? e.resume() : e.play())
    },
    rewindMusic: function() {
        this._currMusic && this._playMusic(this._currMusic)
    },
    getMusicVolume: function() {
        return this._musicPlayState == 0 ? 0 : this._currMusic.volume
    },
    setMusicVolume: function(e) {
        this._musicPlayState > 0 && (this._currMusic.volume = Math.min(Math.max(e, 0), 1))
    },
    isMusicPlaying: function() {
        return this._musicPlayState == 2 && this._currMusic && !this._currMusic.ended
    },
    _getEffectList: function(e) {
        var t = this._audioPool[e];
        return t || (t = this._audioPool[e] = []), t
    },
    _getEffect: function(e) {
        var t = this,
            n;
        if (!t._soundSupported)
            return null;
        var r = this._getEffectList(e);
        if (cc.sys.isMobile && cc.sys.os == cc.sys.OS_IOS)
            n = this._getEffectAudio(r, e);
        else {
            for (var i = 0, s = r.length; i < s; i++) {
                var o = r[i];
                if (o.ended) {
                    n = o, n.readyState > 2 && (n.currentTime = 0), window.chrome && n.load();
                    break
                }
            }
            n || (n = this._getEffectAudio(r, e), n && r.push(n))
        }
        return n
    },
    _getEffectAudio: function(e, t) {
        var n;
        return e.length >= this._maxAudioInstance ? (cc.log("Error: " + t + " greater than " + this._maxAudioInstance), null) : (n = this._getAudioByUrl(t), n ? (n = n.cloneNode(!0), this._effectPauseCb && cc._addEventListener(n, "pause", this._effectPauseCb), n.volume = this._effectsVolume, n) : null)
    },
    playEffect: function(e, t) {
        var n = this._getEffect(e);
        if (!n)
            return null;
        n.loop = t || !1, n.play();
        var r = this._audioID++;
        return this._effects[r] = n, r
    },
    setEffectsVolume: function(e) {
        e = this._effectsVolume = Math.min(Math.max(e, 0), 1);
        var t = this._effects;
        for (var n in t)
            t[n].volume = e
    },
    pauseEffect: function(e) {
        var t = this._effects[e];
        t && !t.ended && t.pause()
    },
    pauseAllEffects: function() {
        var e = this._effects;
        for (var t in e) {
            var n = e[t];
            n.ended || n.pause()
        }
    },
    resumeEffect: function(e) {
        this._resumeAudio(this._effects[e])
    },
    resumeAllEffects: function() {
        var e = this._effects;
        for (var t in e)
            this._resumeAudio(e[t])
    },
    stopEffect: function(e) {
        this._stopAudio(this._effects[e]), delete this._effects[e]
    },
    stopAllEffects: function() {
        var e = this._effects;
        for (var t in e)
            this._stopAudio(e[t]), delete e[t]
    },
    unloadEffect: function(e) {
        var t = cc.loader,
            n = this._effects,
            r = this._getEffectList(e);
        t.release(e);
        if (r.length == 0)
            return;
        var i = r[0].src;
        delete this._audioPool[e];
        for (var s in n)
            n[s].src == i && (this._stopAudio(n[s]), delete n[s])
    },
    end: function() {
        this.stopMusic(), this.stopAllEffects()
    },
    _pausePlaying: function() {
        var e = this,
            t = e._effects,
            n;
        for (var r in t)
            n = t[r], n && !n.ended && !n.paused && (e._playings.push(n), n.pause());
        e.isMusicPlaying() && (e._playings.push(e._currMusic), e._currMusic.pause())
    },
    _resumePlaying: function() {
        var e = this,
            t = this._playings;
        for (var n = 0, r = t.length; n < r; n++)
            e._resumeAudio(t[n]);
        t.length = 0
    }
}), !cc.sys._supportWebAudio && !cc.sys._supportMultipleAudio && (cc.AudioEngineForSingle = cc.AudioEngine.extend({
    _waitingEffIds: [],
    _pausedEffIds: [],
    _currEffect: null,
    _maxAudioInstance: 2,
    _effectCache4Single: {},
    _needToResumeMusic: !1,
    _expendTime4Music: 0,
    _isHiddenMode: !1,
    _playMusic: function(e) {
        this._stopAllEffects(), this._super(e)
    },
    resumeMusic: function() {
        var e = this;
        e._musicPlayState == 1 && (e._stopAllEffects(), e._needToResumeMusic = !1, e._expendTime4Music = 0, e._super())
    },
    playEffect: function(e, t) {
        var n = this,
            r = n._currEffect,
            i = t ? n._getEffect(e) : n._getSingleEffect(e);
        if (!i)
            return null;
        i.loop = t || !1;
        var s = n._audioID++;
        return n._effects[s] = i, n.isMusicPlaying() && (n.pauseMusic(), n._needToResumeMusic = !0), r ? (r != i && n._waitingEffIds.push(n._currEffectId), n._waitingEffIds.push(s), r.pause()) : (n._currEffect = i, n._currEffectId = s, i.play()), s
    },
    pauseEffect: function(e) {
        cc.log("pauseEffect not supported in single audio mode!")
    },
    pauseAllEffects: function() {
        var e = this,
            t = e._waitingEffIds,
            n = e._pausedEffIds,
            r = e._currEffect;
        if (!r)
            return;
        for (var i = 0, s = t.length; i < s; i++)
            n.push(t[i]);
        t.length = 0, n.push(e._currEffectId), r.pause()
    },
    resumeEffect: function(e) {
        cc.log("resumeEffect not supported in single audio mode!")
    },
    resumeAllEffects: function() {
        var e = this,
            t = e._waitingEffIds,
            n = e._pausedEffIds;
        e.isMusicPlaying() && (e.pauseMusic(), e._needToResumeMusic = !0);
        for (var r = 0, i = n.length; r < i; r++)
            t.push(n[r]);
        n.length = 0;
        if (!e._currEffect && t.length >= 0) {
            var s = t.pop(),
                o = e._effects[s];
            o && (e._currEffectId = s, e._currEffect = o, e._resumeAudio(o))
        }
    },
    stopEffect: function(e) {
        var t = this,
            n = t._currEffect,
            r = t._waitingEffIds,
            i = t._pausedEffIds;
        if (n && this._currEffectId == e)
            this._stopAudio(n);
        else {
            var s = r.indexOf(e);
            s >= 0 ? r.splice(s, 1) : (s = i.indexOf(e), s >= 0 && i.splice(s, 1))
        }
    },
    stopAllEffects: function() {
        var e = this;
        e._stopAllEffects(), !e._currEffect && e._needToResumeMusic && (e._resumeAudio(e._currMusic), e._musicPlayState = 2, e._needToResumeMusic = !1, e._expendTime4Music = 0)
    },
    unloadEffect: function(e) {
        var t = this,
            n = cc.loader,
            r = t._effects,
            i = t._effectCache4Single,
            s = t._getEffectList(e),
            o = t._currEffect;
        n.release(e);
        if (s.length == 0 && !i[e])
            return;
        var u = s.length > 0 ? s[0].src : i[e].src;
        delete t._audioPool[e], delete i[e];
        for (var a in r)
            r[a].src == u && delete r[a];
        o && o.src == u && t._stopAudio(o)
    },
    _getSingleEffect: function(e) {
        var t = this,
            n = t._effectCache4Single[e],
            r = cc.loader,
            i = t._waitingEffIds,
            s = t._pausedEffIds,
            o = t._effects;
        if (n)
            n.readyState > 2 && (n.currentTime = 0);
        else {
            n = t._getAudioByUrl(e);
            if (!n)
                return null;
            n = n.cloneNode(!0), t._effectPauseCb && cc._addEventListener(n, "pause", t._effectPauseCb), n.volume = t._effectsVolume, t._effectCache4Single[e] = n
        }
        for (var u = 0, a = i.length; u < a;)
            o[i[u]] == n ? i.splice(u, 1) : u++;
        for (var u = 0, a = s.length; u < a;)
            o[s[u]] == n ? s.splice(u, 1) : u++;
        return n._isToPlay = !0, n
    },
    _stopAllEffects: function() {
        var e = this,
            t = e._currEffect,
            n = e._audioPool,
            r = e._effectCache4Single,
            i = e._waitingEffIds,
            s = e._pausedEffIds;
        if (!t && i.length == 0 && s.length == 0)
            return;
        for (var o in r) {
            var u = r[o];
            u.readyState > 2 && u.duration && u.duration != Infinity && (u.currentTime = u.duration)
        }
        i.length = 0, s.length = 0;
        for (var o in n) {
            var a = n[o];
            for (var f = 0, l = a.length; f < l; f++) {
                var u = a[f];
                u.loop = !1, u.readyState > 2 && u.duration && u.duration != Infinity && (u.currentTime = u.duration)
            }
        }
        t && e._stopAudio(t)
    },
    _effectPauseCb: function() {
        var e = this;
        if (e._isHiddenMode)
            return;
        var t = e._getWaitingEffToPlay();
        if (t)
            t._isToPlay ? (delete t._isToPlay, t.play()) : e._resumeAudio(t);
        else if (e._needToResumeMusic) {
            var n = e._currMusic;
            if (n.readyState > 2 && n.duration && n.duration != Infinity) {
                var r = n.currentTime + e._expendTime4Music;
                r -= n.duration * (r / n.duration | 0), n.currentTime = r
            }
            e._expendTime4Music = 0, e._resumeAudio(n), e._musicPlayState = 2, e._needToResumeMusic = !1
        }
    },
    _getWaitingEffToPlay: function() {
        var e = this,
            t = e._waitingEffIds,
            n = e._effects,
            r = e._currEffect,
            i = r ? r.currentTime - (r.startTime || 0) : 0;
        e._expendTime4Music += i;
        for (;;) {
            if (t.length == 0)
                break;
            var s = t.pop(),
                o = n[s];
            if (!o)
                continue;
            if (o._isToPlay || o.loop || o.duration && o.currentTime + i < o.duration) {
                e._currEffectId = s, e._currEffect = o;
                if (!o._isToPlay && o.readyState > 2 && o.duration && o.duration != Infinity) {
                    var u = o.currentTime + i;
                    u -= o.duration * (u / o.duration | 0), o.currentTime = u
                }
                return o._isToPlay = !1, o
            }
            o.readyState > 2 && o.duration && o.duration != Infinity && (o.currentTime = o.duration)
        }
        return e._currEffectId = null, e._currEffect = null, null
    },
    _pausePlaying: function() {
        var e = this,
            t = e._currEffect;
        e._isHiddenMode = !0;
        var n = e._musicPlayState == 2 ? e._currMusic : t;
        n && (e._playings.push(n), n.pause())
    },
    _resumePlaying: function() {
        var e = this,
            t = e._playings;
        e._isHiddenMode = !1, t.length > 0 && (e._resumeAudio(t[0]), t.length = 0)
    }
})), cc._audioLoader = {
    _supportedAudioTypes: null,
    getBasePath: function() {
        return cc.loader.audioPath
    },
    _load: function(e, t, n, r, i, s, o) {
        var u = this,
            a = cc.loader,
            f = cc.path,
            l = this._supportedAudioTypes,
            c = "";
        if (l.length == 0)
            return o("can not support audio!");
        if (r == -1)
            c = (f.extname(e) || "").toLowerCase(), u.audioTypeSupported(c) || (c = l[0], r = 0);
        else {
            if (!(r < l.length))
                return o("can not found the resource of audio! Last match url is : " + e);
            c = l[r]
        }
        if (i.indexOf(c) >= 0)
            return u._load(e, t, n, r + 1, i, s, o);
        e = f.changeExtname(e, c), i.push(c);
        var h = r == l.length - 1;
        s = u._loadAudio(e, s, function(a) {
            if (a)
                return u._load(e, t, n, r + 1, i, s, o);
            o(null, s)
        }, h), a.cache[t] = s
    },
    audioTypeSupported: function(e) {
        return e ? this._supportedAudioTypes.indexOf(e.toLowerCase()) >= 0 : !1
    },
    _loadAudio: function(e, t, n, r) {
        var i;
        !cc.isObject(window.cc) && cc.sys.browserType == "firefox" ? i = Audio : i = location.origin == "file://" ? Audio : cc.WebAudio || Audio, arguments.length == 2 ? (n = t, t = new i) : arguments.length > 3 && !t && (t = new i), t.src = e, t.preload = "auto";
        var s = navigator.userAgent;
        if (/Mobile/.test(s) && (/iPhone OS/.test(s) || /iPad/.test(s) || /Firefox/.test(s)) || /MSIE/.test(s))
            t.load(), n(null, t);
        else {
            var o = "canplaythrough",
                u = "error";
            cc._addEventListener(t, o, function() {
                n(null, t), this.removeEventListener(o, arguments.callee, !1), this.removeEventListener(u, arguments.callee, !1)
            }, !1);
            var a = function() {
                t.removeEventListener("emptied", a), t.removeEventListener(u, a), n("load " + e + " failed"), r && (this.removeEventListener(o, arguments.callee, !1), this.removeEventListener(u, arguments.callee, !1))
            };
            cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT && cc._addEventListener(t, "emptied", a, !1), cc._addEventListener(t, u, a, !1), t.load()
        }
        return t
    },
    load: function(e, t, n, r) {
        var i = [];
        this._load(e, t, n, -1, i, null, r)
    }
}, cc._audioLoader._supportedAudioTypes = function() {
    var e = cc.newElement("audio"),
        t = [];
    if (e.canPlayType) {
        var n = function(t) {
            var n = e.canPlayType(t);
            return n != "no" && n != ""
        };
        n('audio/ogg; codecs="vorbis"') && t.push(".ogg"), n("audio/mpeg") && t.push(".mp3"), n('audio/wav; codecs="1"') && t.push(".wav"), n("audio/mp4") && t.push(".mp4"), (n("audio/x-m4a") || n("audio/aac")) && t.push(".m4a")
    }
    return t
}(), cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], cc._audioLoader), cc.audioEngine = cc.AudioEngineForSingle ? new cc.AudioEngineForSingle : new cc.AudioEngine, cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
    cc.audioEngine._pausePlaying()
}), cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
    cc.audioEngine._resumePlaying()
}), cc._globalFontSize = cc.ITEM_SIZE, cc._globalFontName = "Arial", cc._globalFontNameRelease = !1, cc.MenuItem = cc.Node.extend({
    _enabled: !1,
    _target: null,
    _callback: null,
    _isSelected: !1,
    _className: "MenuItem",
    ctor: function(e, t) {
        var n = cc.Node.prototype;
        n.ctor.call(this), this._target = null, this._callback = null, this._isSelected = !1, this._enabled = !1, n.setAnchorPoint.call(this, .5, .5), this._target = t || null, this._callback = e || null, this._callback && (this._enabled = !0)
    },
    isSelected: function() {
        return this._isSelected
    },
    setOpacityModifyRGB: function(e) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    setTarget: function(e, t) {
        this._target = t, this._callback = e
    },
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(e) {
        this._enabled = e
    },
    initWithCallback: function(e, t) {
        return this.anchorX = .5, this.anchorY = .5, this._target = t, this._callback = e, this._enabled = !0, this._isSelected = !1, !0
    },
    rect: function() {
        var e = this._position,
            t = this._contentSize,
            n = this._anchorPoint;
        return cc.rect(e.x - t.width * n.x, e.y - t.height * n.y, t.width, t.height)
    },
    selected: function() {
        this._isSelected = !0
    },
    unselected: function() {
        this._isSelected = !1
    },
    setCallback: function(e, t) {
        this._target = t, this._callback = e
    },
    activate: function() {
        if (this._enabled) {
            var e = this._target,
                t = this._callback;
            if (!t)
                return;
            e && cc.isString(t) ? e[t](this) : e && cc.isFunction(t) ? t.call(e, this) : t(this)
        }
    }
});
var _p = cc.MenuItem.prototype;
_p.enabled, cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled), cc.MenuItem.create = function(e, t) {
    return new cc.MenuItem(e, t)
}, cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: null,
    _label: null,
    _orginalScale: 0,
    _colorBackup: null,
    ctor: function(e, t, n) {
        cc.MenuItem.prototype.ctor.call(this, t, n), this._disabledColor = null, this._label = null, this._orginalScale = 0, this._colorBackup = null, e && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(e), this.cascadeColor = !0, this.cascadeOpacity = !0)
    },
    getDisabledColor: function() {
        return this._disabledColor
    },
    setDisabledColor: function(e) {
        this._disabledColor = e
    },
    getLabel: function() {
        return this._label
    },
    setLabel: function(e) {
        e && (this.addChild(e), e.anchorX = 0, e.anchorY = 0, this.width = e.width, this.height = e.height), this._label && this.removeChild(this._label, !0), this._label = e
    },
    setEnabled: function(e) {
        if (this._enabled != e) {
            var t = this._label;
            e ? t.color = this._colorBackup : (this._colorBackup = t.color, t.color = this._disabledColor)
        }
        cc.MenuItem.prototype.setEnabled.call(this, e)
    },
    setOpacity: function(e) {
        this._label.opacity = e
    },
    getOpacity: function() {
        return this._label.opacity
    },
    setColor: function(e) {
        this._label.color = e
    },
    getColor: function() {
        return this._label.color
    },
    initWithLabel: function(e, t, n) {
        return this.initWithCallback(t, n), this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(e), this.cascadeColor = !0, this.cascadeOpacity = !0, !0
    },
    setString: function(e) {
        this._label.string = e, this.width = this._label.width, this.height = this._label.height
    },
    getString: function() {
        return this._label.string
    },
    activate: function() {
        this._enabled && (this.stopAllActions(), this.scale = this._originalScale, cc.MenuItem.prototype.activate.call(this))
    },
    selected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var e = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            e ? this.stopAction(e) : this._originalScale = this.scale;
            var t = cc.ScaleTo.create(.1, this._originalScale * 1.2);
            t.setTag(cc.ZOOM_ACTION_TAG), this.runAction(t)
        }
    },
    unselected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this), this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var e = cc.ScaleTo.create(.1, this._originalScale);
            e.setTag(cc.ZOOM_ACTION_TAG), this.runAction(e)
        }
    }
});
var _p = cc.MenuItemLabel.prototype;
_p.string, cc.defineGetterSetter(_p, "string", _p.getString, _p.setString), _p.disabledColor, cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor), _p.label, cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel), cc.MenuItemLabel.create = function(e, t, n) {
    return new cc.MenuItemLabel(e, t, n)
}, cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function(e, t, n, r, i, s, o) {
        var u;
        e && e.length > 0 && (u = cc.LabelAtlas.create(e, t, n, r, i)), cc.MenuItemLabel.prototype.ctor.call(this, u, s, o)
    },
    initWithString: function(e, t, n, r, i, s, o) {
        if (!e || e.length == 0)
            throw "cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0";
        var u = new cc.LabelAtlas;
        return u.initWithString(e, t, n, r, i), this.initWithLabel(u, s, o), !0
    }
}), cc.MenuItemAtlasFont.create = function(e, t, n, r, i, s, o) {
    return new cc.MenuItemAtlasFont(e, t, n, r, i, s, o)
}, cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null,
    _fontName: null,
    ctor: function(e, t, n) {
        var r;
        e && e.length > 0 ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, r = cc.LabelTTF.create(e, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = ""), cc.MenuItemLabel.prototype.ctor.call(this, r, t, n)
    },
    initWithString: function(e, t, n) {
        if (!e || e.length == 0)
            throw "Value should be non-null and its length should be greater than 0";
        this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize;
        var r = cc.LabelTTF.create(e, this._fontName, this._fontSize);
        return this.initWithLabel(r, t, n), !0
    },
    setFontSize: function(e) {
        this._fontSize = e, this._recreateLabel()
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(e) {
        this._fontName = e, this._recreateLabel()
    },
    getFontName: function() {
        return this._fontName
    },
    _recreateLabel: function() {
        var e = cc.LabelTTF.create(this._label.string, this._fontName, this._fontSize);
        this.setLabel(e)
    }
}), cc.MenuItemFont.setFontSize = function(e) {
    cc._globalFontSize = e
}, cc.MenuItemFont.fontSize = function() {
    return cc._globalFontSize
}, cc.MenuItemFont.setFontName = function(e) {
    cc._globalFontNameRelease && (cc._globalFontName = ""), cc._globalFontName = e, cc._globalFontNameRelease = !0
};
var _p = cc.MenuItemFont.prototype;
_p.fontSize, cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize), _p.fontName, cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName), cc.MenuItemFont.fontName = function() {
    return cc._globalFontName
}, cc.MenuItemFont.create = function(e, t, n) {
    return new cc.MenuItemFont(e, t, n)
}, cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null,
    _selectedImage: null,
    _disabledImage: null,
    ctor: function(e, t, n, r, i) {
        cc.MenuItem.prototype.ctor.call(this), this._normalImage = null, this._selectedImage = null, this._disabledImage = null;
        if (t !== undefined) {
            e = e, t = t;
            var s, o, u;
            i !== undefined ? (s = n, u = r, o = i) : r !== undefined && cc.isFunction(r) ? (s = n, u = r) : r !== undefined && cc.isFunction(n) ? (o = r, u = n, s = cc.Sprite.create(t)) : n === undefined && (s = cc.Sprite.create(t)), this.initWithNormalSprite(e, t, s, u, o)
        }
    },
    getNormalImage: function() {
        return this._normalImage
    },
    setNormalImage: function(e) {
        if (this._normalImage == e)
            return;
        e && (this.addChild(e, 0, cc.NORMAL_TAG), e.anchorX = 0, e.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = e, this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), e.textureLoaded && !e.textureLoaded() && e.addLoadedEventListener(function(e) {
            this.width = e.width, this.height = e.height
        }, this)
    },
    getSelectedImage: function() {
        return this._selectedImage
    },
    setSelectedImage: function(e) {
        if (this._selectedImage == e)
            return;
        e && (this.addChild(e, 0, cc.SELECTED_TAG), e.anchorX = 0, e.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = e, this._updateImagesVisibility()
    },
    getDisabledImage: function() {
        return this._disabledImage
    },
    setDisabledImage: function(e) {
        if (this._disabledImage == e)
            return;
        e && (this.addChild(e, 0, cc.DISABLE_TAG), e.anchorX = 0, e.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = e, this._updateImagesVisibility()
    },
    initWithNormalSprite: function(e, t, n, r, i) {
        this.initWithCallback(r, i), this.setNormalImage(e), this.setSelectedImage(t), this.setDisabledImage(n);
        var s = this._normalImage;
        return s && (this.width = s.width, this.height = s.height, s.textureLoaded && !s.textureLoaded() && s.addLoadedEventListener(function(e) {
            this.width = e.width, this.height = e.height, this.cascadeColor = !0, this.cascadeOpacity = !0
        }, this)), this.cascadeColor = !0, this.cascadeOpacity = !0, !0
    },
    setColor: function(e) {
        this._normalImage.color = e, this._selectedImage && (this._selectedImage.color = e), this._disabledImage && (this._disabledImage.color = e)
    },
    getColor: function() {
        return this._normalImage.color
    },
    setOpacity: function(e) {
        this._normalImage.opacity = e, this._selectedImage && (this._selectedImage.opacity = e), this._disabledImage && (this._disabledImage.opacity = e)
    },
    getOpacity: function() {
        return this._normalImage.opacity
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this), this._normalImage && (this._disabledImage && (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0)
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this), this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1))
    },
    setEnabled: function(e) {
        this._enabled != e && (cc.MenuItem.prototype.setEnabled.call(this, e), this._updateImagesVisibility())
    },
    _updateImagesVisibility: function() {
        var e = this._normalImage,
            t = this._selectedImage,
            n = this._disabledImage;
        this._enabled ? (e && (e.visible = !0), t && (t.visible = !1), n && (n.visible = !1)) : n ? (e && (e.visible = !1), t && (t.visible = !1), n && (n.visible = !0)) : (e && (e.visible = !0), t && (t.visible = !1))
    }
});
var _p = cc.MenuItemSprite.prototype;
_p.normalImage, cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage), _p.selectedImage, cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage), _p.disabledImage, cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage), cc.MenuItemSprite.create = function(e, t, n, r, i) {
    return new cc.MenuItemSprite(e, t, n, r, i || undefined)
}, cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function(e, t, n, r, i) {
        var s = null,
            o = null,
            u = null,
            a = null,
            f = null;
        e === undefined ? cc.MenuItemSprite.prototype.ctor.call(this) : (s = cc.Sprite.create(e), t && (o = cc.Sprite.create(t)), r === undefined ? a = n : i === undefined ? (a = n, f = r) : i && (u = cc.Sprite.create(n), a = r, f = i), cc.MenuItemSprite.prototype.ctor.call(this, s, o, u, a, f))
    },
    setNormalSpriteFrame: function(e) {
        this.setNormalImage(cc.Sprite.create(e))
    },
    setSelectedSpriteFrame: function(e) {
        this.setSelectedImage(cc.Sprite.create(e))
    },
    setDisabledSpriteFrame: function(e) {
        this.setDisabledImage(cc.Sprite.create(e))
    },
    initWithNormalImage: function(e, t, n, r, i) {
        var s = null,
            o = null,
            u = null;
        return e && (s = cc.Sprite.create(e)), t && (o = cc.Sprite.create(t)), n && (u = cc.Sprite.create(n)), this.initWithNormalSprite(s, o, u, r, i)
    }
}), cc.MenuItemImage.create = function(e, t, n, r, i) {
    return new cc.MenuItemImage(e, t, n, r, i)
}, cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null,
    _selectedIndex: 0,
    _opacity: null,
    _color: null,
    ctor: function() {
        cc.MenuItem.prototype.ctor.call(this), this._selectedIndex = 0, this.subItems = [], this._opacity = 0, this._color = cc.color.WHITE, arguments.length > 0 && this.initWithItems(Array.prototype.slice.apply(arguments))
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(e) {
        this._opacity = e;
        if (this.subItems && this.subItems.length > 0)
            for (var t = 0; t < this.subItems.length; t++)
                this.subItems[t].opacity = e;
        this._color.a = e
    },
    getColor: function() {
        var e = this._color;
        return cc.color(e.r, e.g, e.b, e.a)
    },
    setColor: function(e) {
        var t = this._color;
        t.r = e.r, t.g = e.g, t.b = e.b;
        if (this.subItems && this.subItems.length > 0)
            for (var n = 0; n < this.subItems.length; n++)
                this.subItems[n].setColor(e);
        e.a !== undefined && !e.a_undefined && this.setOpacity(e.a)
    },
    getSelectedIndex: function() {
        return this._selectedIndex
    },
    setSelectedIndex: function(e) {
        if (e != this._selectedIndex) {
            this._selectedIndex = e;
            var t = this.getChildByTag(cc.CURRENT_ITEM);
            t && t.removeFromParent(!1);
            var n = this.subItems[this._selectedIndex];
            this.addChild(n, 0, cc.CURRENT_ITEM);
            var r = n.width,
                i = n.height;
            this.width = r, this.height = i, n.setPosition(r / 2, i / 2)
        }
    },
    getSubItems: function() {
        return this.subItems
    },
    setSubItems: function(e) {
        this.subItems = e
    },
    initWithItems: function(e) {
        var t = e.length;
        cc.isFunction(e[e.length - 2]) ? (this.initWithCallback(e[e.length - 2], e[e.length - 1]), t -= 2) : cc.isFunction(e[e.length - 1]) ? (this.initWithCallback(e[e.length - 1], null), t -= 1) : this.initWithCallback(null, null);
        var n = this.subItems;
        n.length = 0;
        for (var r = 0; r < t; r++)
            e[r] && n.push(e[r]);
        return this._selectedIndex = cc.UINT_MAX, this.setSelectedIndex(0), this.cascadeColor = !0, this.cascadeOpacity = !0, !0
    },
    addSubItem: function(e) {
        this.subItems.push(e)
    },
    activate: function() {
        if (this._enabled) {
            var e = (this._selectedIndex + 1) % this.subItems.length;
            this.setSelectedIndex(e)
        }
        cc.MenuItem.prototype.activate.call(this)
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this), this.subItems[this._selectedIndex].selected()
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this), this.subItems[this._selectedIndex].unselected()
    },
    setEnabled: function(e) {
        if (this._enabled != e) {
            cc.MenuItem.prototype.setEnabled.call(this, e);
            var t = this.subItems;
            if (t && t.length > 0)
                for (var n = 0; n < t.length; n++)
                    t[n].enabled = e
        }
    },
    selectedItem: function() {
        return this.subItems[this._selectedIndex]
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this), this.setSelectedIndex(this._selectedIndex)
    }
});
var _p = cc.MenuItemToggle.prototype;
_p.selectedIndex, cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex), cc.MenuItemToggle.create = function() {
    arguments.length > 0 && arguments[arguments.length - 1] == null && cc.log("parameters should not be ending with null in Javascript");
    var e = new cc.MenuItemToggle;
    return e.initWithItems(Array.prototype.slice.apply(arguments)), e
}, cc.MENU_STATE_WAITING = 0, cc.MENU_STATE_TRACKING_TOUCH = 1, cc.MENU_HANDLER_PRIORITY = -128, cc.DEFAULT_PADDING = 5, cc.Menu = cc.Layer.extend({
    enabled: !1,
    _selectedItem: null,
    _state: -1,
    _touchListener: null,
    _className: "Menu",
    ctor: function(e) {
        cc.Layer.prototype.ctor.call(this), this._color = cc.color.WHITE, this.enabled = !1, this._opacity = 255, this._selectedItem = null, this._state = -1, this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        }), arguments.length > 0 && arguments[arguments.length - 1] == null && cc.log("parameters should not be ending with null in Javascript");
        var t = arguments.length,
            n;
        if (t == 0)
            n = [];
        else if (t == 1)
            e instanceof Array ? n = e : n = [e];
        else if (t > 1) {
            n = [];
            for (var r = 0; r < t; r++)
                arguments[r] && n.push(arguments[r])
        }
        this.initWithArray(n)
    },
    onEnter: function() {
        var e = this._touchListener;
        e._isRegistered() || cc.eventManager.addListener(e, this), cc.Node.prototype.onEnter.call(this)
    },
    isEnabled: function() {
        return this.enabled
    },
    setEnabled: function(e) {
        this.enabled = e
    },
    initWithItems: function(e) {
        var t = [];
        if (e)
            for (var n = 0; n < e.length; n++)
                e[n] && t.push(e[n]);
        return this.initWithArray(t)
    },
    initWithArray: function(e) {
        if (cc.Layer.prototype.init.call(this)) {
            this.enabled = !0;
            var t = cc.winSize;
            this.setPosition(t.width / 2, t.height / 2), this.setContentSize(t), this.setAnchorPoint(.5, .5), this.ignoreAnchorPointForPosition(!0);
            if (e)
                for (var n = 0; n < e.length; n++)
                    this.addChild(e[n], n);
            return this._selectedItem = null, this._state = cc.MENU_STATE_WAITING, this.cascadeColor = !0, this.cascadeOpacity = !0, !0
        }
        return !1
    },
    addChild: function(e, t, n) {
        if (!(e instanceof cc.MenuItem))
            throw "cc.Menu.addChild() : Menu only supports MenuItem objects as children";
        cc.Layer.prototype.addChild.call(this, e, t, n)
    },
    alignItemsVertically: function() {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsVerticallyWithPadding: function(e) {
        var t = -e,
            n = this._children,
            r, i, s, o, u;
        if (n && n.length > 0) {
            for (i = 0, r = n.length; i < r; i++)
                t += n[i].height * n[i].scaleY + e;
            var a = t / 2;
            for (i = 0, r = n.length; i < r; i++)
                u = n[i], o = u.height, s = u.scaleY, u.setPosition(0, a - o * s / 2), a -= o * s + e
        }
    },
    alignItemsHorizontally: function() {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsHorizontallyWithPadding: function(e) {
        var t = -e,
            n = this._children,
            r, i, s, o, u;
        if (n && n.length > 0) {
            for (r = 0, i = n.length; r < i; r++)
                t += n[r].width * n[r].scaleX + e;
            var a = -t / 2;
            for (r = 0, i = n.length; r < i; r++)
                u = n[r], s = u.scaleX, o = n[r].width, u.setPosition(a + o * s / 2, 0), a += o * s + e
        }
    },
    alignItemsInColumns: function() {
        arguments.length > 0 && arguments[arguments.length - 1] == null && cc.log("parameters should not be ending with null in Javascript");
        var e = [];
        for (var t = 0; t < arguments.length; t++)
            e.push(arguments[t]);
        var n = -5,
            r = 0,
            i = 0,
            s = 0,
            o, u, a, f = this._children;
        if (f && f.length > 0)
            for (t = 0, a = f.length; t < a; t++) {
                if (r >= e.length)
                    continue;
                o = e[r];
                if (!o)
                    continue;
                u = f[t].height, i = i >= u || isNaN(u) ? i : u, ++s, s >= o && (n += i + 5, s = 0, i = 0, ++r)
            }
        var l = cc.director.getWinSize();
        r = 0, i = 0, o = 0;
        var c = 0,
            h = 0,
            p = n / 2;
        if (f && f.length > 0)
            for (t = 0, a = f.length; t < a; t++) {
                var d = f[t];
                o == 0 && (o = e[r], c = l.width / (1 + o), h = c), u = d._getHeight(), i = i >= u || isNaN(u) ? i : u, d.setPosition(h - l.width / 2, p - u / 2), h += c, ++s, s >= o && (p -= i + 5, s = 0, o = 0, i = 0, ++r)
            }
    },
    alignItemsInRows: function() {
        arguments.length > 0 && arguments[arguments.length - 1] == null && cc.log("parameters should not be ending with null in Javascript");
        var e = [],
            t;
        for (t = 0; t < arguments.length; t++)
            e.push(arguments[t]);
        var n = [],
            r = [],
            i = -10,
            s = -5,
            o = 0,
            u = 0,
            a = 0,
            f, l, c, h, p = this._children;
        if (p && p.length > 0)
            for (t = 0, c = p.length; t < c; t++) {
                l = p[t];
                if (o >= e.length)
                    continue;
                f = e[o];
                if (!f)
                    continue;
                h = l.width, u = u >= h || isNaN(h) ? u : h, s += l.height + 5, ++a, a >= f && (n.push(u), r.push(s), i += u + 10, a = 0, u = 0, s = -5, ++o)
            }
        var d = cc.director.getWinSize();
        o = 0, u = 0, f = 0;
        var v = -i / 2,
            m = 0;
        if (p && p.length > 0)
            for (t = 0, c = p.length; t < c; t++)
                l = p[t], f == 0 && (f = e[o], m = r[o]), h = l._getWidth(), u = u >= h || isNaN(h) ? u : h, l.setPosition(v + n[o] / 2, m - d.height / 2), m -= l.height + 10, ++a, a >= f && (v += u + 5, a = 0, f = 0, u = 0, ++o)
    },
    removeChild: function(e, t) {
        if (e == null)
            return;
        if (!(e instanceof cc.MenuItem)) {
            cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children");
            return
        }
        this._selectedItem == e && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, e, t)
    },
    _onTouchBegan: function(e, t) {
        var n = t.getCurrentTarget();
        if (n._state != cc.MENU_STATE_WAITING || !n._visible || !n.enabled)
            return !1;
        for (var r = n.parent; r != null; r = r.parent)
            if (!r.isVisible())
                return !1;
        return n._selectedItem = n._itemForTouch(e), n._selectedItem ? (n._state = cc.MENU_STATE_TRACKING_TOUCH, n._selectedItem.selected(), !0) : !1
    },
    _onTouchEnded: function(e, t) {
        var n = t.getCurrentTarget();
        if (n._state !== cc.MENU_STATE_TRACKING_TOUCH) {
            cc.log("cc.Menu.onTouchEnded(): invalid state");
            return
        }
        n._selectedItem && (n._selectedItem.unselected(), n._selectedItem.activate()), n._state = cc.MENU_STATE_WAITING
    },
    _onTouchCancelled: function(e, t) {
        var n = t.getCurrentTarget();
        if (n._state !== cc.MENU_STATE_TRACKING_TOUCH) {
            cc.log("cc.Menu.onTouchCancelled(): invalid state");
            return
        }
        this._selectedItem && n._selectedItem.unselected(), n._state = cc.MENU_STATE_WAITING
    },
    _onTouchMoved: function(e, t) {
        var n = t.getCurrentTarget();
        if (n._state !== cc.MENU_STATE_TRACKING_TOUCH) {
            cc.log("cc.Menu.onTouchMoved(): invalid state");
            return
        }
        var r = n._itemForTouch(e);
        r != n._selectedItem && (n._selectedItem && n._selectedItem.unselected(), n._selectedItem = r, n._selectedItem && n._selectedItem.selected())
    },
    onExit: function() {
        this._state == cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem = null), this._state = cc.MENU_STATE_WAITING), cc.Node.prototype.onExit.call(this)
    },
    setOpacityModifyRGB: function(e) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _itemForTouch: function(e) {
        var t = e.getLocation(),
            n = this._children,
            r;
        if (n && n.length > 0)
            for (var i = n.length - 1; i >= 0; i--) {
                r = n[i];
                if (r.isVisible() && r.isEnabled()) {
                    var s = r.convertToNodeSpace(t),
                        o = r.rect();
                    o.x = 0, o.y = 0;
                    if (cc.rectContainsPoint(o, s))
                        return r
                }
            }
        return null
    }
});
var _p = cc.Menu.prototype;
_p.enabled, cc.Menu.create = function(e) {
    var t = arguments.length;
    t > 0 && arguments[t - 1] == null && cc.log("parameters should not be ending with null in Javascript");
    var n;
    return t == 0 ? n = new cc.Menu : t == 1 ? n = new cc.Menu(e) : n = new cc.Menu(Array.prototype.slice.call(arguments, 0)), n
};
var res = {
        grass: "res/grass.png",
        cloud: "res/cloud.png",
        popup: "res/popup.png",
        share: "res/share_end.png",
        bottom: "res/bottom.png",
        trick: "res/trick.png",
        floor: "res/floor.png"
    },
    g_resources = [];
for (var i in res)
    g_resources.push(res[i]);
//data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOsAAAC8CAMAAACuX6moAAAAXVBMVEUAAAAAAAAAAADnZmLnZmIAAADnZmIAAAAAAAAAAAAAAADnZmIAAAAAAAAAAADnZmIAAAAAAAAAAAAAAADnZmLnZmLnZmLnZmLnZmLnZmLnZmLnZmIAAADnZmLnZmKNG6PUAAAAHnRSTlMAs1S7dzREpxgMg+5rJEYRj5t3X5kzZszdIlWIBaq64OXfAAAJvElEQVR42qyawW7sIAxFkbDYsGADBIjC/3/m07xK1ZAL2EY9y+mcgoMhdiZmS81kbendW0u5GgWJyFrfe7f21pm10fNRV9BeRBNFJN2lD1wUjIgWXwMWgnCFYyLuXFwQaOZ6iFZq9nhmImEiZoWIo/qF4LMBhGY7MJFyLk7JOzka4O9MnngqPmZCsLLRkHTtzSuszGq7EDoXkeY5Kx4vzcWbuhOmaUSAhHmExD8weWCyUk6HbSgGmUmqPYNY1WQxpfS2DzDhqwOXnZiVMRnuUzEyofqY/2e5y892eXDccrufz6GsiGjimCJAJBdkJoZqvzO1xu3CPqPpvoO5+0Ddmu18sipoWJm37IYFGkuKIZzLbU3iTf1kQWRwTEmX/GqrZ4hFajY0eVAMRkfw47IhaVFd1i/TO9asC7NpJgtDqri/7MTnzdcAVmc21uR5QNTgJHaZJVwWmMGDCWMeT1aNxSVD8uRGF4rEpFkRXmDT8KCopomOiDopYOjExCunAcXDK1VkX7P40XVslmDEoHi+W7Ms0y0mhNOZbmFWWlLfYjN6HlhWdsZg2q15w/cimlzzguIBHvacMNYgXFZDcDb5hflwvYqHHDxM4SCMld4pXJjMEZu+r7hfojcH0LBcsG3ML3BJb+mJaKVm7UvyS4zmgGeSwm22K/ov6R1CMzP0ZutLElw1DZutQ/tCZxoCgqZnzLsveYvO6EkQAlx3yHUwpdX2A6kKyb7Aoqgn79M1TPrjGxZamjmZMfsSAlENhvAhzY7Ji50xX9WFvZn6kvYWq9GCIXzIk1o9wB7jBsb+IDJVU3Av/DACiErCbMKRO5o05Rp9zQ9Nkk2uqET+jIS1hqN5WdNGUaliJ589sgbs4UUe2h9N89swNs2iBybOoNmDaHKEG7r+SSXhZp2ah4Stnc+ocE0XH0yu3nK8yFO26Rpn1VtFt/uwCBW+AuZmfTzkF/w/BXWWTA8czfNqPXK/cKYCdw00rVmRML9uEEVgCHjV06z2AXl1PJGHv29MJONXEjzHlkP7O+m6ocMOzL5Gdhbaz5VZudoy4zp8uJJRYPVNjoMrNXt5JNvNr+po1n2ZkxZij4pou7DJSfOH/h1/Z/tA0XcIFW5FAxc1l5aTY8Q1J01OnicjdQYIVWja4dZnlUPCZJch+G3VGCHN9KHyJg1R3bDthNxMk1PXVSPewqvvLHhc8qYbJtcg/YVkVZPDPYJIXv6WhMIMw5FbQRSSzD6Em2tyVMGWZADeLMOtz2OJIsNzTY5lm5yRem0GIwNIzDhM7jl9e8ZKmhysGnFf40sR+rc1yUuOJjp9AYxOmpyy78pr7MgFkcpfunSYX7yINDMNQdXkIJX+sVsHKRDCMBRAhYZu3TgOTBnvf0xBsEXFovv3loEPzSJNvqdGnx404/xfLo6rb7wLdtq9BFPVqlFrc/sMUtV5dI4tO0Xk4Z3PL6KkpmwzuZs6E58jIt0pAwAAAAAAAAAAAMDarpnuug0CUZgz0mgYBIjlb97/OVuvxDGpuritm/L9aHOTa8PhzOboDgaDwWAwGAwGg8FgMBgMBoPBYDD4dwjFmv+FAja3gnR7pWR6xBLNG2IO5hsI1NwJC9pVoyOWMxK9Uwr0tNrt7JA6HxKpeYvzvzXq4ZrWc8hVuJ4cZksZgO9veP0llNN1BUAy72AA1Dmeqw6gLZ3gMh1XSX01hjCTtGc3aNv5y92qYOa9rUjIek77cqHWtn85bE7gTB9yxCb0LFcR7eSExgQA3n7D19g/Pgd3Vb466+KyUCovTshPFNI6hUJ4zQkvAITUMBBNH80HqddrZTgjbjnTnJMxNtd9vYypS9JXOg5aoX7KJQBp1aprEQcwn6jKe1vrJLX7frlKK6l4Y1AqIHaS0IorMB+reCcHsS1EOYdTJmdf4DetCSlMr6Ndc+9tqMRVagjnhS7QuVSSCjtFHU3bsB4Sd+dmD5DVlr5WLadtKNvJCTv7wfO/Ep5dr2shfPWXNle9RGW+WGsEW0OQdfkCrwQ4e4hvE+AIyfZqcZZdBtGhPPklz3heRur0XvHE3CKYWsNSKk6A7UwCgBwv1sqAtDU9pMq+SOseDMBrv++09OJ0KCZ2+U/32UITZsS2X4LfXmUfw14Hg0AO6/EVo2ZCMB5+r/cQOidKRP9Y7aEVWsyKcqqs2y1del5KKB+0WjncmFBa6yNzqdZ2vLtUeZ3ePNh69Cs+yXFAnI9pGxbsSSuKTk4+34wPU4UsF1mHLLC/SWveXY2dgUWk9rRyBuC5PN3HTe5FowSI5z2G24xsgeKePStohxEhXqfcFjJOzAGFNZeQ3ZIiPoM7Ce0tn7WqB1KGLVKfmuBUk3RSWIsgky616RDGagjtTX2Ko2W49ih23tIRmGtAmURFXYJZX6JntsNtCsPqgUBonjNS2xUhGHZb0WSHl9PbVFZk7fbWIrCB9y2ZEK/XSlvC5NngetrJrhV53oObE1uR2kfThUkNi+GtuFqPZqFlw2v0ap6kvC6SQXtrYRCTE6B9evXjK8q+541Qd62tjLEjXfuR7sdA8Gqmn+Hb1QDKolbQOisDkdKrraUtlLDQfL0oXXnvavuprmKVkvDxQagearTddmerZF4upnhI0LKOJvLcbQgAwtFWsftZekB8oMymcbHWuL0omCTxvM1m5wlJyx41LjHdgZaWVSO1eN6Mq8dN0DaCaMH8tKBqGmouIcJvdVTbO5O7c98g7Wht22PkyQX7jfywDoDN8IfHYhxS0IluM2Wg88085JIoJsgaRqklaYOEtKvVQ9eZmN6feinzsZR47mUIJ1uN6z/ZBgBkLiCIbx50NYn0Wrn47ygbMb89YdAh9dv4fUYFFw1Owa4GvrGHu18W2u+KKhXzhnr8emZbK/Rzgdj8IUJvB/f64ncwGAwGg8HgP8YGjuSLcykV+sw/u9DA5EvKmJDkie3DfBgPO2sULORSY/i4mfsxGekyVsR9pJWW47PI9LFWtnBFnqz8vOpzspJi+Lh4PVlZ4wda+QixlicrPfHnWbmrbF2EP670bCo/u4u8qPzMLrKqdPnHu0ioearHwfwbWKaSf2wgaEIBwP0Lw70y+SSrlT/YRR7sBUD2fPdc3kNWUmld5EeFurvH7hay2f1kF3lwkcnQW7egJWR/7bFSY5F7GzqHrPzyY6VGB8htDX1YriVf8SxiyQHppoZaJu8uGggsJUi5o6FTyPqydZErhN7SUMuR6JpnkTYYlXgzQx8hMHOz8iKhqd7L0MdDrb38WYR9vp2hl9IGI1dvP/1dI9THf2Cc/2U00n9hqNEY/wtDjWX+Lww1asN/Yah5qP5dQ78ADjykzyzM8iwAAAAASUVORK5CYII=
cc.LoaderScene = cc.Scene.extend({
    _interval: null,
    _label: null,
    _className: "LoaderScene",
    init: function() {
        var e = this,
            t = e._size = cc.winSize,
            n = "res/logo.png",
            r = e._bgLayer = new cc.LayerColor(cc.color(0, 0, 0, 0));
        e.addChild(r, 0);
        var i = e._footer = cc.LabelTTF.create("gzacwl.com", "Verdana", 14);
        i.attr({
            x: t.width / 2,
            y: 14
        }), i.setColor(cc.color(153, 153, 153)), e.addChild(i, 1);
        var s = e._logo = new cc.Sprite(n);
        s.attr({
            x: t.width / 2,
            y: t.height / 2
        }),
        e.addChild(s, 2);
        var o = e._layer = new cc.LayerColor(cc.color(231, 102, 98, 255));
        return o.attr({
            width: 0,
            height: 7,
            x: 0,
            y: t.height - 7,
            anchorX: 0,
            anchorY: 1
        }), e.addChild(o, 10), !0
    },
    onEnter: function() {
        var e = this;
        cc.Node.prototype.onEnter.call(e), e.schedule(e._startLoading, .3)
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this), this._layer.width = 0
    },
    initWithResources: function(e, t) {
        cc.isString(e) && (e = [e]), this.resources = e || [], this.cb = t
    },
    _startLoading: function() {
        var e = this;
        e.unschedule(e._startLoading);
        var t = e.resources;
        cc.loader.load(t, function(t, n, r) {
            var i = r / n * 100 | 0;
            i = Math.min(i, 100), e._layer.width = i / 100 * e._size.width
        }, function() {
            e.cb && e.cb()
        })
    }
}), cc.LoaderScene.preload = function(e, t) {
    var n = cc;
    return n.loaderScene || (n.loaderScene = new cc.LoaderScene, n.loaderScene.init()), n.loaderScene.initWithResources(e, t), cc.director.runScene(n.loaderScene), n.loaderScene
};
var moveTrick = cc.Sprite.extend({
        ctor: function(e, t, n) {
            var r = t || e.trick.width,
                i = n || e.trick.y;
            this._super(res.trick, cc.rect(0, 0, r, e.trick.height));
            var s = this._size = cc.winSize;
            return e.score % 2 == 0 ? (this.attr({
                anchorY: 0,
                x: r / 2,
                y: i
            }), this.runAction(cc.RepeatForever.create(cc.Sequence.create(cc.MoveTo.create(2, cc.p(s.width - r / 2, i)), cc.MoveTo.create(2, cc.p(r / 2, i)))))) : (this.attr({
                anchorY: 0,
                x: s.width - r / 2,
                y: i
            }), this.runAction(cc.RepeatForever.create(cc.Sequence.create(cc.MoveTo.create(2, cc.p(r / 2, i)), cc.MoveTo.create(2, cc.p(s.width - r / 2, i)))))), !0
        }
    }),
    makeFloor = cc.Sprite.extend({
        ctor: function(e, t, n, r) {
            var i = e.score % 2 == 0 ? 0 : e.trick.height + 10;
            return this._super(res.floor, cc.rect(0, i, r, e.trick.height)), this.attr({
                x: t,
                y: n,
                anchorX: .5,
                anchorY: 0
            }), !0
        }
    }),
    GameLayer = cc.Layer.extend({
        ctor: function() {
            this._super();
            var e = this,
                t = e._size = cc.winSize;
            e.init();
            var n = cc.EventListener.create({
                event: cc.EventListener.TOUCH_ONE_BY_ONE,
                swallowTouches: !1,
                onTouchBegan: function() {
                    var t = {
                            x: e._trick.x,
                            y: e._trick.y
                        },
                        n = {
                            x: (e.trick.x + t.x) / 2,
                            y: e.trick.y,
                            width: e.trick.width - Math.abs(e.trick.x - t.x)
                        };
                    Math.round(n.width) > 1 ? e.logic(n) : e.gameover()
                }
            });
            return cc.eventManager.addListener(n, this), !0
        },
        honor: function() {
            var e = this.score;
            return e == 0 ? "盖无能" : e >= 1 && e < 10 ? "盖中盖" : e >= 10 && e < 30 ? "超能盖" : e >= 30 && e < 50 ? "巨能盖" : e >= 50 && e < 100 ? "盖炸天" : e >= 100 && e < 200 ? "盖无双" : "独孤求盖"
        },
        initConfig: function() {
            var e = this;
            e.score = 0, e.trick = {
                x: e._size.width / 2,
                y: 94,
                width: 154,
                height: 30
            }
        },
        init: function() {
            var e = this,
                t = e._size;
            e.initConfig();
            var n = e._back = new cc.LayerColor(cc.color(175, 239, 253, 255));
            e.addChild(n);
            var r = e._grass = new cc.Sprite(res.grass);
            r.attr({
                x: 0,
                y: 0,
                anchorX: 0,
                anchorY: 0
            }), e.addChild(r);
            var i = e._cloud = new cc.Sprite(res.cloud);
            i.attr({
                x: 60,
                y: t.height,
                anchorX: 0,
                anchorY: 1
            }), i.runAction(cc.RepeatForever.create(cc.Sequence.create(cc.EaseSineInOut.create(cc.MoveBy.create(10, cc.p(-120, 0))), cc.EaseSineInOut.create(cc.MoveBy.create(10, cc.p(120, 0)))))), n.addChild(i);
            var s = e._score = new cc.LabelTTF(e.score + "", "Verdana", 36, cc.size(80, 40), cc.TEXT_ALIGNMENT_CENTER);
            s.setColor(cc.color(90, 60, 30, 255)), s.attr({
                x: t.width / 2,
                y: t.height - 40,
                anchorX: .5,
                anchorY: 1
            }), e.addChild(s, 99);
            var o = e._floors = new cc.Layer;
            e.addChild(o, 98);
            var u = e._trick = new moveTrick(e);
            e._floors.addChild(u);
            var a = e._bottom = new cc.Sprite(res.bottom);
            a.attr({
                x: t.width / 2,
                y: 0,
                anchorY: 0
            }), e._floors.addChild(a, 100)
            // game begin
            _hmt.push(["_trackEvent", "游戏开始", "自动开始游戏"]);
        },
        gameover: function() {
            var e = this;
            if (!e._over) {
                e._trick.stopAllActions(),
                e._cloud.stopAllActions(),
                e._floors.removeChild(e._trick),
                window.shareData.title = window.shareData.desc = document.title = "挑战《疯狂盖楼》，我盖了" + e.score + '层，获得了"' + e.honor() + '"称号！';
                LBShare.updateData(shareData);
                var t = e._over = new cc.LayerColor(cc.color(0, 0, 0, 125)),
                    n = e._box = new cc.Sprite(res.popup);
                n.attr({
                    x: e._size.width / 2,
                    y: e._size.height / 2
                }), t.addChild(n);
                var r = new cc.LabelTTF(e.score, "Verdana", 27, cc.size(60, 40), cc.TEXT_ALIGNMENT_CENTER);
                r.setColor(cc.color(89, 129, 39, 255)), r.attr({
                    x: 175,
                    y: 250
                }), n.addChild(r);
                var i = new cc.LabelTTF(e.honor(), "黑体", 38, cc.size(246, 50), cc.TEXT_ALIGNMENT_CENTER);
                i.setColor(cc.color(214, 0, 0, 255)), i.attr({
                    x: n.width / 2,
                    y: 170
                }), n.addChild(i), e.addChild(t, 102);
                var s = cc.EventListener.create({
                    event: cc.EventListener.TOUCH_ONE_BY_ONE,
                    swallowTouches: !1,
                    onTouchBegan: function(t, n) {
                        var r = t._point;
                        r.x >= 106 && r.x <= 220 && (r.y > e.height / 2 - 82 && r.y <= e.height / 2 - 43 ? e._mask || (e.initConfig(),
                        _hmt.push(["_trackEvent", "游戏重玩", "游戏重玩点击"]) ,cc.director.runScene(new GameScene)) :
                        r.y > e.height / 2 - 132 && r.y <= e.height / 2 - 93 && e.share())
                    }
                });
                cc.eventManager.addListener(s, t)
            }
            // game over
            _hmt.push(["_trackEvent", "游戏结束", "自动结束游戏"]);
            console.log('game over');


        },
        share: function() {
            // game share
            _hmt.push(["_trackEvent", "游戏分享", "分享按钮点击"]);
            console.log('游戏被用户分享');
            game_login();
            LBShare.callShare();
            return
        },
        logic: function(e) {
            var t = this;
            t.score++, t._score.setString(t.score);
            if (t.score > 7) {
                t._floors.runAction(cc.EaseSineInOut.create(cc.MoveBy.create(.2, cc.p(0, -30)))), t._grass.runAction(cc.EaseSineInOut.create(cc.MoveBy.create(.2, cc.p(0, -30))));
                var n = t._floors.children;
                for (var r = 0; r < n.length; r++)
                    n[r].y + n[r].height < -t._floors.y && t._floors.removeChild(n[r])
            }
            t.trick.x = e.x, t.trick.y = e.y + 30, t.trick.width = e.width, t._floors.removeChild(t._trick), t._trick = new moveTrick(t, e.width, t.trick.y), t._floors.addChild(t._trick), t._floor = new makeFloor(t, e.x, e.y, e.width), t._floors.addChild(t._floor)
        }
    }),
    GameScene = cc.Scene.extend({
        onEnter: function() {
            this._super();
            var e = new GameLayer;
            this.addChild(e)
        }
    });
    window.cc = cc;
    window.g_resources = g_resources;
    window.GameScene = GameScene;
}();
